settings
{
	main
	{
		Description: "Fight against an endless horde of zombies while completing various objectives.\r\n		Use power ups found in supply drops while you fight off the horde. 	\r\n		Get to the extraction point and watch the map get nuked.\r\n		Don't leave anyone behind!\r\n		\r\n		(Original Creator: Mazattack#1183) [Game Code: MPJFR] \r\n		Discord: https://discord.gg/3BhYtNfwMj		\r\nhttps://workshop.codes/MPJFR\r\n		Github: github.com/Mazattack1999/zsm-ow"
		Mode Name: "Zombie Survival Missions"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: After A Game
		Max Spectators: 7
		Max Team 1 Players: 6
		Max Team 2 Players: 0
		Return To Lobby: Never
		Swap Teams After Match: No
		Team Balancing: After A Game
	}

	modes
	{
		Assault
		{
			Allow Hero Switching: Off
			Capture Speed Modifier: 10%
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled

			disabled maps
			{
				Hanamura Winter
			}
		}

		Capture the Flag
		{
			Allow Hero Switching: Off
			Damage Interrupts Flag Interaction: On
			Flag Carrier Abilities: All
			Flag Dropped Lock Time: 10.0
			Flag Pickup Time: 5.0
			Flag Return Time: 0.0
			Flag Score Respawn Time: 20.0
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled

			disabled maps
			{
				Busan Downtown Lunar New Year
				Busan Sanctuary Lunar New Year
				Lijiang Control Center
				Lijiang Garden
				Lijiang Night Market
				Oasis City Center
				Oasis Gardens
				Oasis University
			}
		}

		Control
		{
			Allow Hero Switching: Off
			Capture Speed Modifier: 10%
			Game Mode Start: Manual
			Kill Cam: Off
			Scoring Speed Modifier: 10%
			Tank Role Passive Health Bonus: Always Enabled

			enabled maps
			{
				Antarctic Peninsula 972777519512068153
				Busan 972777519512068194 972777519512068153 972777519512068154
				Oasis 972777519512068292 972777519512068153 972777519512068154
			}
		}

		Escort
		{
			Allow Hero Switching: Off
			Game Mode Start: Manual
			Kill Cam: Off
			Payload Speed Modifier: 10%
			Tank Role Passive Health Bonus: Always Enabled
		}

		Flashpoint
		{
			Capture Speed Modifier: 10%
			First Active Control Point: A
			Score To Win: 10
			Scoring Speed Modifier: 10%
		}

		Hybrid
		{
			Allow Hero Switching: Off
			Capture Speed Modifier: 10%
			Game Mode Start: Manual
			Kill Cam: Off
			Payload Speed Modifier: 10%
			Tank Role Passive Health Bonus: Always Enabled

			disabled maps
			{
				King's Row
			}
		}

		Push
		{
			Allow Hero Switching: Off
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled
			TS-1 Push Speed Modifier: 10%
			TS-1 Walk Speed Modifier: 10%
		}

		Team Deathmatch
		{
			Allow Hero Switching: Off
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled

			enabled maps
			{
				Black Forest 972777519512063901
				Black Forest Winter 972777519512063901
				Castillo 972777519512063901
				Château Guillard 972777519512063901
				Château Guillard Halloween 972777519512063901
				Ecopoint: Antarctica 972777519512063901
				Ecopoint: Antarctica Winter 972777519512063901
				Kanezaka 972777519512063901
				Malevento 972777519512063901
				Necropolis 972777519512068153
				Petra 972777519512068154
			}
		}
	}

	heroes
	{
		Team 2
		{
			Ability Cooldown Time: 0%
			No Ammunition Requirement: On

			D.Va
			{
				Spawn Without Mech: On
			}
		}
	}

	workshop
	{
		Boss Size: 2.500
		Chance to mutate percentage: 25.000
		Default Enhancement: [9]
		Heavy Knockback Reduction Scalar Scalar: 0.500
		Radioactivity Damage Scalar: 2.000
		Size Growth Scalar: 1.500
		Size Reduction Scalar: 0.600
		Speed Scalar: 1.500
		Zombie Size: 1.000
	}

	extensions
	{
		Spawn More Dummy Bots
	}
}

variables
{
	global:
		0: objectivePositions
		1: walkCenter
		2: objectiveCaptureValue
		3: startPos
		4: count1
		5: count2
		6: specialEffectsStrings
		7: playersOnObjective
		8: testPos
		9: testPos2
		10: objectiveTypes
		11: objectiveRad
		12: losList
		13: reviveRadius
		14: botHeros
		15: chase1
		18: gameStatus
		19: startTime
		20: mustReviveTime
		21: supplyDropLanding
		22: supplyDropPosition
		23: powerUpIDs
		24: powerUpPositions
		25: supplyDropStatus
		26: powerUpText
		27: powerUpEffect
		28: startCamPos
		29: botSpawnRates
		30: startMenuSpacingAngle
		31: startCamDistance
		32: overtime
		33: difficultyVotes
		34: botMaxTeleportRange
		35: difficultySetting
		36: biteDamages
		37: biteDurations
		38: damageDealt
		39: botHealthValues
		40: throttleSpeeds
		41: randVal
		42: specialEffectsTiming
		43: evacRate
		44: evacuatingSurvivorList
		45: evacDestination
		46: zombieSetting
		47: bosses
		48: zombieVotes
		49: globalPlayerStats
		50: objectiveTypeVotes
		51: objectiveTypeSetting
		52: eliminationsNeededPerObjective
		53: invisibilityHeros
		54: healthpackPositions
		55: wordsOfEncouragement
		56: mapGrid
		58: attackSpawnRooms
		59: activeAttackSpawnRoom
		60: closestPlayerToObjective
		61: botSpawnPoints
		62: objectiveValue
		63: objectiveEntities
		64: objectiveEntityCount
		65: voting
		66: votingEndTime
		67: objectiveResourcePositions
		68: amountPerResource
		69: extractionZoneRad
		70: specialGameModeSetup
		71: resourcePowerUpDropCount
		72: availablePowerups
		73: specialGameMode
		74: objectiveSpacing
		75: enhancementOptions
		76: playerTargetList
		77: losHeightCheck
		78: survivorToRescue
		79: nonBossZombies
		80: availableMutations
		81: numberOfPowerUpsPerSupplyDrop
		82: objectiveDescription
		83: mixedObjectivesPool
		84: uniqueSkinCap
		85: users
		86: objectiveComplete
		87: objectiveColor
		88: objectiveCount1
		89: objectiveChase1
		90: spawnRoomIndex
		91: averageVote
		92: matchEndTime
		93: waypoints
		94: availableBosses
		95: spawnTimes
		96: numberOfBots
		97: customTelePositions
		98: currentBotHeroList
		99: botCurrentSpawnRate
		100: botRespawnCount
		101: botSpawnPointTimers

	player:
		0: averagePlayersPos
		1: targeting
		4: teleporting
		5: pPowerUpCount_bTeleCount
		6: pForceFieldCount1
		7: pForceFieldCount2_bCount1
		9: botTarget
		10: botThrottleSpeed
		11: playerActiveStatus
		12: reviving
		13: reviveStartTime
		14: reviveTimer
		15: interactEntity
		16: infected
		17: biteDamage
		18: biteDuration
		19: randVal
		20: crowdControlled
		21: deathTimer
		22: infectionLvl
		23: currentPowerUp
		24: powerUpTradeValues
		25: powerUpEffects
		26: powerUpUsePositionsAndInfo
		27: pNoCooldownsCount_bCount2
		28: pAirStrikeCount
		30: chase1
		31: chase2
		32: botFollowTarget
		34: playerMenuStatus
		35: startPos
		36: successfullyTeleported
		39: evacPos
		40: canWallPhase
		41: pHealBeaconCount
		42: pSentryTurretCount
		43: initialMaxHealth
		44: botSpecialTarget
		45: attached
		46: telePos
		47: invisible
		48: pCloakingDeviceCount
		49: path
		50: potentialTargets
		51: pSuperNanoCount
		52: size
		53: bossHealth
		54: wallCollisionEnabled
		55: specialFacing
		56: specialThrottling
		57: filteredBotSpawnPointGrid
		58: botTempValue
		59: objectiveValue
		60: generalPlayerBotEntities
		61: entityCount
		62: botHero
		63: playerObjectiveResourceValue
		64: pBouncePadCount1
		66: enhancementValues
		67: botSpecialPotentialTargets
		68: movementSpeed
		69: mutationValue
		70: health
		71: damageOverTimeDuration
		72: pUltimateChargerCount
		73: enhancementChase1
		74: playerCollisionEnabled
		75: pStunCount
		76: enhancementChase2
		77: initializing
		78: userIndex
		79: knockbackRecieved
		80: detectionRadius1
		81: pBouncePadCount2
		82: bouncePadBouncer
		83: pStunChase1
		84: enhancementCount1
		85: customTelePos
		86: damageDealt
		87: lastTarget
		88: abilityArray1
		89: abilityArray2
		90: waypoint
		91: testTarget
		92: canTeleport
		93: defaultOutlineColor
		94: outlineCount
		95: blinded
		96: updateOutlines
		97: afk
}

subroutines
{
	0: enterExitTeleport
	1: teleportBots
	2: nukeMap
	3: powerUpAssignment
	4: powerUpUsage
	5: playerForceField
	6: noCooldowns
	7: airStrike
	8: instantRevive
	9: randomActions
	10: enableDisableAbilities
	11: determineDifficulty
	12: setDifficulty
	13: botRespawnInitialization
	14: determineZombieMode
	15: setZombieMode
	16: healBeacon
	17: sentryTurret
	18: needReviveTextLines
	19: cloakingDevice
	20: determineObjectiveType
	21: setObjectiveType
	22: objectivesManagement
	23: superNano
	24: generateMapGrid
	25: successfulTeleportStatus
	26: updateBotSpawnPoints
	27: globalObjectiveEntityManagement
	28: playerObjectiveEntityManagement
	29: botEntityManagement
	30: bouncePad
	31: botTeleportCenter
	32: locateAveragePlayerLocation
	33: enablePowerups
	34: mutations
	35: enableMutations
	36: ultimateCharger
	37: botHeroRandomization
	38: enableEnhancements
	39: scavengerManagement
	40: setAvailableObjectives
	41: stun
	42: updateUsers
	43: botStatManagement
	44: fireSatellite
	45: selectTarget
	46: restoreDefaultFacingMovement
	47: setPrematchTimer
}

rule("Fix bot health")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.initializing != True;
		Event Player.teleporting != True;
		Health(Event Player) > Event Player.health + 5;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Player Health(Event Player, Event Player.health);
		Loop If Condition Is True;
	}
}

disabled rule("interact test")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Button Held(Host Player, Button(Interact)) == True;
	}

	actions
	{
		Heal(Host Player, Null, 100000);
		Set Damage Dealt(Host Player, 1000);
		disabled Set Ultimate Charge(Host Player, 100);
		Set Status(All Players(Team 1), Null, Unkillable, 9999);
		Teleport(Remove From Array(All Players(Team 1), Host Player), First Of(Global.objectivePositions));
		If(Global.objectiveTypes[0] == 1);
			Global.objectiveCaptureValue = 99.900;
		Else If(Global.objectiveTypes[0] == 2);
			Global.objectiveCaptureValue = 249;
		Else;
			Global.objectiveCaptureValue = 99;
		End;
		If(Is Button Held(Host Player, Button(Primary Fire)));
			All Players(Team 1).currentPowerUp = 12;
		End;
	}
}

disabled rule("============================================== GLOBAL STARTUP ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PREGAME QUICK TIPS FOR PLAYERS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
	}

	actions
	{
		Wait(10, Abort When False);
		Small Message(All Players(All Teams), Custom String("Quick Tip: {0}", Random Value In Array(Array(Custom String(
			"Hold [{0}] while voting to cycle backwards.", Input Binding String(Button(Secondary Fire))), Custom String(
			"Zombies infect {0} players by hitting them.", Icon String(Poison)), Custom String(
			"Zombies with different colored outlines have mutations that grant them special buffs."), Custom String(
			"Hacked {0} zombies cannot infect players.", Ability Icon String(Hero(Sombra), Button(Secondary Fire))), Custom String(
			"Shields {0} block most zombie attacks including roadhog gas attacks. ", Ability Icon String(Hero(Reinhardt), Button(
			Secondary Fire))), Custom String("Zombies cannot spawn close to players or within their field of view. "), Custom String(
			"Overheal abilities such as rally {0} protect players from infection.", Ability Icon String(Hero(Brigitte), Button(Ultimate))),
			Custom String("Healthpacks {0} only cure infection {1} before overtime.", Icon String(Plus), Icon String(Poison))))));
		Loop;
	}
}

rule("SPAWN BOTS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Server Load Average <= Workshop Setting Integer(Custom String("General"), Custom String(
			"Spawn Zombies When Server Load Average is Less Than"), 180, 100, 255, 2);
		disabled Number Of Players(Team 2) < Global.numberOfBots;
		Number Of Players(All Teams) < 24;
		((Count Of(Global.spawnTimes) > 0 && First Of(Global.spawnTimes) <= 0) || (Count Of(Global.spawnTimes) + Number Of Players(Team 2)
			< Global.numberOfBots)) == True;
	}

	actions
	{
		Call Subroutine(botHeroRandomization);
		If(Count Of(Global.spawnTimes) > 0 && First Of(Global.spawnTimes) <= 0);
			Modify Global Variable(spawnTimes, Remove From Array By Index, 0);
			Wait(0.250, Ignore Condition);
		Else;
			Wait(3, Ignore Condition);
		End;
		Loop If Condition Is True;
		Wait(Last Of(Sorted Array(Global.spawnTimes, Current Array Element)), Restart When True);
		"Reset spawn times array if conditions are not met"
		If(Count Of(Global.spawnTimes) > 0);
			Global.spawnTimes[0] = 0;
		End;
		Loop If Condition Is True;
	}
}

rule("botHeroRandomization")
{
	event
	{
		Subroutine;
		botHeroRandomization;
	}

	actions
	{
		Global.currentBotHeroList = Filtered Array(Global.botHeros, Number Of Heroes(Current Array Element, Team 2) > 0);
		"Determines if count of current different zombie types is less than the maximum amount allowed"
		If(Count Of(Global.currentBotHeroList) < Global.uniqueSkinCap - (Number Of Players(Team 1) <= Number Of Slots(Team 1)
			? Number Of Slots(Team 1) : Number Of Players(Team 1)));
			Global.randVal = Random Real(0, 100);
			Global.botCurrentSpawnRate = 0;
			Global.botRespawnCount = -1;
			While(Global.randVal > Global.botCurrentSpawnRate || Global.botRespawnCount < 0);
				Global.botRespawnCount += 1;
				Global.botCurrentSpawnRate += Global.botSpawnRates[Global.botRespawnCount];
			End;
			Create Dummy Bot(Global.botHeros[Global.botRespawnCount], Team 2, -1, Vector(500, 500, 500), Vector(0, 0, 0));
		Else;
			Create Dummy Bot(Last Of(Sorted Array(Global.botHeros, Global.botSpawnRates[Current Array Index])), Team 2, -1, Vector(500, 500,
				500), Vector(0, 0, 0));
		End;
		Global.currentBotHeroList = Empty Array;
	}
}

rule("SPAWN TIME CONTROL")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Count Of(Global.spawnTimes) > 0 || Global.botSpawnPointTimers > 0) == True;
	}

	actions
	{
		If(Count Of(Global.spawnTimes) > 0);
			Global.spawnTimes = Sorted Array(Mapped Array(Global.spawnTimes, Current Array Element - 1), Current Array Element);
		End;
		If(Count Of(Global.botSpawnPointTimers) > 0);
			Global.botSpawnPointTimers = Mapped Array(Global.botSpawnPointTimers, Max(0, Current Array Element - 1));
		End;
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("START GAME IF WAITING FOR PLAYERS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Waiting For Players == True;
	}

	actions
	{
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Scoring;
		Disable Built-In Game Mode Announcer;
		Start Game Mode;
		Small Message(Host Player, Custom String("Starting"));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("SKIP ASSEMBLING HEROES")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Is Assembling Heroes || (Global.specialGameModeSetup && Count Of(Filtered Array(All Players(Team 1),
			Current Array Element.playerActiveStatus)) == 0)) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Global.voting = True;
		Call Subroutine(enableEnhancements);
		"Set difficulty votes empty"
		Global.difficultyVotes = Array(Array(Null, True), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"),
			Custom String("Beginner"), True, 0)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"),
			Custom String("Normal"), True, 1)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"), Custom String(
			"Expert"), True, 2)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"), Custom String("Legendary"),
			True, 3)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"), Custom String("Insanity"), True, 4)));
		"Set zombie modes empty"
		Global.zombieVotes = Array(Array(Null, True), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"),
			Custom String("Wave 1"), True, 0)), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String(
			"Wave 2"), True, 1)), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String("Wave 3"),
			True, 2)), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String("Wave 4"), True, 3)),
			Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String("Wave 5"), True, 4)));
		Call Subroutine(setAvailableObjectives);
		"Set/Reset to default 0"
		Global.difficultySetting = 0;
		"Set/Reset to default 0"
		Global.zombieSetting = 0;
		"Set/Reset to default 0"
		Global.objectiveTypeSetting = 0;
		If(Is Assembling Heroes);
			Disable Inspector Recording;
			Set Match Time(0);
			Global.specialGameModeSetup = True;
			Wait(0.250, Ignore Condition);
		End;
		If(Is In Setup);
			Set Match Time(0);
			Wait(0.250, Ignore Condition);
		End;
		Set Match Time(3599);
		Wait Until(Count Of(Filtered Array(All Players(Team 1), Has Spawned(Current Array Element))) > 0 && Count Of(Global.mapGrid) > 0,
			9999);
		Set Match Time(60);
		Wait(0.016, Ignore Condition);
		Global.chase1 = Match Time;
		Chase Global Variable At Rate(chase1, 0, 1, None);
		Disable Built-In Game Mode Announcer;
		Disable Built-In Game Mode Completion;
	}
}

rule("setAvailableObjectives")
{
	event
	{
		Subroutine;
		setAvailableObjectives;
	}

	actions
	{
		"Set objective type votes empty"
		Global.objectiveTypeVotes[0] = Array(Null, True);
		"Set objective type votes empty"
		Global.objectiveTypeVotes[1] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Capture Points"), True, 0));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[2] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Eliminations"), True, 1));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[3] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Bosses"), True, 2));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[4] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Resource Collection"), True, 4));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[5] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Survivor Rescue"), True, 5));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[6] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Kill Zone"), True, 6));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[7] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Zombie Egg"), True, 7));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[8] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Satellite Uplink"), True, 8));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[9] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Graveyard"), True, 9));
		"Set objective type votes empty"
		Global.objectiveTypeVotes[10] = Array(Null, Workshop Setting Toggle(Custom String("Available Objective Types"), Custom String(
			"Mixed Objectives"), True, 10));
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[0] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Capture Points."),
			True, 1) ? 1 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[1] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Eliminations."),
			False, 2) ? 2 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[2] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Bosses."), True, 3)
			? 3 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[3] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String(
			"Resource Collection."), True, 4) ? 4 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[4] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Survivor Rescue."),
			True, 5) ? 5 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[5] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Kill Zone."), True,
			6) ? 6 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[6] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Zombie Egg."), True,
			7) ? 7 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[7] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Satellite Uplink."),
			True, 8) ? 8 : 0;
		"Mixed Objectives pool"
		Global.mixedObjectivesPool[8] = Workshop Setting Toggle(Custom String("Mixed Objectives Pool"), Custom String("Graveyard."), True,
			9) ? 9 : 0;
		"Removed disabled objectives"
		Modify Global Variable(mixedObjectivesPool, Remove From Array By Value, 0);
	}
}

rule("PREGAME SPAWN ROOM ROTATION")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		"Does not apply if game mode is special gamemode"
		Global.specialGameMode != True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Create Dummy Bot(Hero(Ana), Team 2, -1, Vector(0, 500, 0), Vector(0, 0, 0));
		Global.attackSpawnRooms = Empty Array;
		Global.spawnRoomIndex = 0;
		"Records spawn room locations"
		While(Count Of(Global.attackSpawnRooms) < (Current Game Mode == Game Mode(Assault) ? 2 : 3));
			Start Forcing Spawn Room(Team 2, Global.spawnRoomIndex);
			Wait(0.250, Ignore Condition);
			Respawn(All Players(Team 2));
			While(!Is In Spawn Room(First Of(All Players(Team 2))));
				Wait(0.016, Ignore Condition);
			End;
			Modify Global Variable(attackSpawnRooms, Append To Array, Position Of(First Of(All Players(Team 2))));
			Global.spawnRoomIndex += 1;
		End;
		"Accounts for first attack spawn rooms generally being bigger than other spawn rooms"
		Global.attackSpawnRooms[0] += Direction Towards(First Of(Global.attackSpawnRooms), Objective Position(0)) * 10;
		Wait(0.250, Ignore Condition);
		Destroy All Dummy Bots;
		"Rotates spawn rooms while waiting for game to start"
		While(Global.specialGameModeSetup);
			Global.spawnRoomIndex += 1;
			If((Current Game Mode == Game Mode(Assault) && Global.spawnRoomIndex > 1) || (Global.spawnRoomIndex > 2));
				Global.spawnRoomIndex = 0;
			End;
			"Open all spawn rooms"
			Start Forcing Spawn Room(All Teams, Global.spawnRoomIndex);
			Wait(1, Ignore Condition);
		End;
		"Change active spawn room to a location"
		Global.activeAttackSpawnRoom = Global.attackSpawnRooms[Global.spawnRoomIndex];
	}
}

rule("VARIABLE ASSIGNMENT")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		If(Current Game Mode == Game Mode(Capture the Flag));
			Global.attackSpawnRooms = First Of(Sorted Array(Spawn Points(Team 2), Distance Between(Current Array Element, Flag Position(
				Team 2))));
		Else If(Current Game Mode == Game Mode(Team Deathmatch));
		Else If(Current Game Mode == Game Mode(Push));
			"Prevent match time from reaching zero due to ws bug with push gamemode"
			Global.matchEndTime = 0.100;
		Else;
			Global.matchEndTime = 0;
		End;
		"Determines if current game mode is base or arcade"
		Global.specialGameMode = Array Contains(Array(Game Mode(Team Deathmatch), Game Mode(Capture the Flag), Game Mode(Push), Game Mode(
			Control)), Current Game Mode) ? True : False;
		Global.wordsOfEncouragement = Array(Custom String("Galatians 6:9"), Custom String("Romans 12:9-10"), Custom String("1 John 1:9"),
			Custom String("Proverbs 17:17"), Custom String("Psalm 42:5"), Custom String("Ephesians 4:32"), Custom String("Hebrews 12:11"));
		"Total amount of powerups"
		Global.availablePowerups = 11;
		Global.amountPerResource = 100 / (Current Game Mode != Game Mode(Team Deathmatch) ? 5 : 5.900);
		"Initial extraction zone radius"
		Global.extractionZoneRad = 300;
		Global.objectiveResourcePositions = Empty Array;
		Global.votingEndTime = 30;
		"Relative center of the map"
		While(Global.walkCenter == Null);
			Wait(1, Ignore Condition);
			Global.walkCenter = (Nearest Walkable Position(Vector(999, 999, 999)) + Nearest Walkable Position(Vector(-999, -999, -999))) / 2;
			Small Message(All Players(All Teams), Custom String("Loading..."));
		End;
		If(Current Game Mode == Game Mode(Control));
			Global.walkCenter = Objective Position(Objective Index);
		End;
		Start Rule(generateMapGrid, Do Nothing);
		Global.objectiveValue = 0;
		Global.objectiveEntities = Empty Array;
		Global.botSpawnPoints = Empty Array;
		Global.waypoints = Empty Array;
		Global.botSpawnPointTimers = Empty Array;
		Global.bosses = Empty Array;
		Global.healthpackPositions = Empty Array;
		Global.overtime = False;
		Global.gameStatus = False;
		"Heros that can be considered invisible due to the nature of some of their character abilities"
		Global.invisibilityHeros = Array(Hero(Sombra), Hero(Moira), Hero(Doomfist), Hero(Tracer));
		Global.users = Empty Array;
		Global.globalPlayerStats = Array(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
		Global.objectivePositions = Empty Array;
		Global.objectiveTypes = Empty Array;
		Global.objectiveRad = 10;
		Global.reviveRadius = 5;
		Global.mustReviveTime = 60;
		Global.playersOnObjective = Empty Array;
		Global.losList = Empty Array;
		Global.botMaxTeleportRange = Array(20, 40);
		Global.supplyDropStatus = True;
		Global.supplyDropLanding = Null;
		Global.supplyDropPosition = Null;
		Global.powerUpIDs = Empty Array;
		Global.powerUpPositions = Empty Array;
		Global.powerUpEffect = Empty Array;
		Global.powerUpText = Empty Array;
		Global.playerTargetList = Empty Array;
		Global.availableBosses = Empty Array;
		Global.spawnTimes = Empty Array;
		Global.customTelePositions = Empty Array;
		Global.losHeightCheck = 1.200;
		Call Subroutine(enablePowerups);
		Call Subroutine(enableMutations);
		Global.numberOfPowerUpsPerSupplyDrop = Workshop Setting Integer(Custom String("Power Ups"), Custom String(
			"Number of Powerups Per Supply Drop"), 5, 1, 10, -1);
		Global.uniqueSkinCap = Workshop Setting Integer(Custom String("General"), Custom String("Maximum Number of Unique Hero Skins"), 11,
			1, 11, 0);
		Global.objectiveComplete = False;
		Global.numberOfBots = Workshop Setting Integer(Custom String("General"), Custom String("Number of zombies"), 6, 1, 23, 1);
	}
}

rule("START GAME")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != False;
		Match Time <= 0.100;
		Count Of(Filtered Array(All Players(Team 1), Has Spawned(Current Array Element))) > 0;
	}

	actions
	{
		Pause Match Time;
		Global.walkCenter = Nearest Walkable Position(Global.walkCenter);
		Global.specialGameModeSetup = False;
		Enable Built-In Game Mode Music;
		Disable Built-In Game Mode Scoring;
		Disable Built-In Game Mode Announcer;
		Disable Inspector Recording;
		disabled Enable Inspector Recording;
		Destroy All Dummy Bots;
		Destroy All Effects;
		Destroy All HUD Text;
		Destroy All Icons;
		Destroy All In-World Text;
		Wait(0.250, Ignore Condition);
		Set Match Time(Global.startTime + Global.matchEndTime);
		Unpause Match Time;
		"Disabled survivor spawn room healing zone"
		Start Forcing Spawn Room(Team 1, Color(Blue));
		"Objective Description"
		Set Objective Description(All Players(All Teams), Global.objectiveDescription, Visible To and String);
	}
}

rule("generateMapGrid")
{
	event
	{
		Subroutine;
		generateMapGrid;
	}

	actions
	{
		Global.mapGrid = Empty Array;
		While(Count Of(Global.mapGrid) < 900);
			Global.testPos = Nearest Walkable Position((Count Of(Global.mapGrid) > 5 ? Random Value In Array(Global.mapGrid)
				: Global.walkCenter) + Direction From Angles(Random Real(0, 360), Random Real(-35, 35)) * Random Real(10, 100));
			"Do not grid points inside spawn rooms on CTF maps"
			If((Current Game Mode != Game Mode(Capture the Flag) && Current Game Mode != Game Mode(Push) && Current Game Mode != Game Mode(
				Control) && Current Game Mode != Game Mode(Flashpoint)) || (Is True For All(Spawn Points(Team 2), Distance Between(Position Of(
				Current Array Element), Global.testPos) > 50) && Is True For All(Spawn Points(Team 1), Distance Between(Position Of(
				Current Array Element), Global.testPos) > 40)));
				If(Count Of(Global.mapGrid) == 0 || Is True For All(Global.mapGrid, Distance Between(Current Array Element, Global.testPos)
					> 2.500));
					Modify Global Variable(mapGrid, Append To Array, Global.testPos);
				End;
			End;
			If(Global.specialGameModeSetup && Match Time + Global.matchEndTime < 2);
				Break;
			End;
			Wait(0.016, Ignore Condition);
		End;
		"0: Consecutive, 1: Minimum"
		Global.objectiveSpacing = Array(Min(60, Count Of(Global.mapGrid) / 11), Min(30, Count Of(Global.mapGrid) / 20));
	}
}

rule("determineZombieMode")
{
	event
	{
		Subroutine;
		determineZombieMode;
	}

	actions
	{
		Global.zombieSetting = 0;
		For Global Variable(count1, 1, Count Of(Global.zombieVotes), 1);
			If(Global.zombieVotes[Global.count1][1]);
				Global.zombieVotes[Global.count1] = Count Of(Filtered Array(All Players(Team 1),
					Current Array Element.playerActiveStatus && Current Array Element.playerMenuStatus[3] == Global.count1));
			Else;
				Global.zombieVotes[Global.count1] = -1;
			End;
		End;
		Global.averageVote = 0;
		For Global Variable(count1, 1, Count Of(Global.zombieVotes), 1);
			Global.averageVote += Global.zombieVotes[Global.count1] * Global.count1;
		End;
		Global.averageVote /= Count Of(Filtered Array(All Players(Team 1), Current Array Element.playerMenuStatus[2] > 0));
		For Global Variable(count1, 1, Count Of(Global.zombieVotes), 1);
			If(Global.zombieVotes[Global.zombieSetting] < Global.zombieVotes[Global.count1]);
				Global.zombieSetting = Global.count1;
			Else If(Global.zombieVotes[Global.count1] > 0 && Global.zombieVotes[Global.zombieSetting] == Global.zombieVotes[Global.count1]);
				"Pick Zombie mode closest to the average zombie vote"
				If(Absolute Value(Global.zombieSetting - Global.averageVote) > Absolute Value(Global.count1 - Global.averageVote));
					Global.zombieSetting = Global.count1;
				End;
			End;
		End;
		"If all players choose no preference set zombie mode to default"
		If(Global.zombieSetting == 0);
			Global.zombieSetting = 1;
		End;
		Start Rule(determineDifficulty, Restart Rule);
		Start Rule(setZombieMode, Restart Rule);
	}
}

rule("setZombieMode")
{
	event
	{
		Subroutine;
		setZombieMode;
	}

	actions
	{
		"Bot available hero list"
		Global.botHeros = Array(Hero(Reaper), Hero(Junkrat), Hero(Torbjörn), Hero(Roadhog), Hero(Reinhardt), Hero(Genji), Hero(Widowmaker),
			Hero(Orisa), Hero(Mercy), Hero(Wrecking Ball), Hero(Moira), Hero(D.Va), Hero(Pharah), Hero(Ramattra), Hero(Sombra));
		"Zombie types without a boss variation"
		Global.nonBossZombies = Array(Hero(Genji), Hero(Widowmaker), Hero(D.Va), Hero(Ramattra));
		"Wave 1"
		If(Global.zombieSetting == 1);
			Global.botSpawnRates = Array(60, 12, 6, 0, 0, 5, 4, 0, 3, 0, 3, 0, 4, 0, 3);
		"Wave 2"
		Else If(Global.zombieSetting == 2);
			Global.botSpawnRates = Array(50, 5, 8, 3, 2, 8, 3, 2, 3, 1, 7, 1, 2, 2, 3);
		"Wave 3"
		Else If(Global.zombieSetting == 3);
			Global.botSpawnRates = Array(5, 7, 13, 3, 2, 20, 8, 5, 3, 5, 15, 3, 5, 3, 3);
		"Wave 4"
		Else If(Global.zombieSetting == 4);
			Global.botSpawnRates = Array(3, 3, 4, 3, 2, 17, 3, 16, 2, 16, 10, 10, 5, 3, 3);
		"Wave 5"
		Else If(Global.zombieSetting == 5);
			Global.botSpawnRates = Array(1, 1, 1, 8, 14, 17, 1, 10, 2, 16, 10, 3, 10, 3, 3);
		End;
		"TESTING ONLY"
		disabled Global.botSpawnRates = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100);
	}
}

rule("determineDifficulty")
{
	event
	{
		Subroutine;
		determineDifficulty;
	}

	actions
	{
		Global.difficultySetting = 0;
		For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
			If(Global.difficultyVotes[Global.count1][1]);
				Global.difficultyVotes[Global.count1] = Count Of(Filtered Array(All Players(Team 1),
					Current Array Element.playerActiveStatus && Current Array Element.playerMenuStatus[2] == Global.count1));
			Else;
				Global.difficultyVotes[Global.count1] = -1;
			End;
		End;
		Global.averageVote = 0;
		For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
			Global.averageVote += Global.difficultyVotes[Global.count1] * Global.count1;
		End;
		Global.averageVote /= Count Of(Filtered Array(All Players(Team 1), Current Array Element.playerMenuStatus[2] > 0));
		For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
			"If difficulty being compared has more votes than current difficulty"
			If(Global.difficultyVotes[Global.difficultySetting] < Global.difficultyVotes[Global.count1]);
				Global.difficultySetting = Global.count1;
			Else If(
					Global.difficultyVotes[Global.count1] > 0 && Global.difficultyVotes[Global.difficultySetting] == Global.difficultyVotes[Global.count1]);
				"Pick difficulty closest to the average difficulty vote"
				If(Absolute Value(Global.difficultySetting - Global.averageVote) > Absolute Value(Global.count1 - Global.averageVote));
					Global.difficultySetting = Global.count1;
				End;
			End;
		End;
		"Default difficulty"
		If(Global.difficultySetting == 0);
			"If all difficulty options are disabled"
			If(Count Of(Filtered Array(Global.difficultyVotes, Current Array Element == -1)) >= Count Of(Global.difficultyVotes) - 1);
				Global.difficultySetting = 2;
			"If normal is disabled, default to easiest difficulty"
			Else If(Global.difficultyVotes[2] == -1);
				For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
					If(Global.difficultyVotes[Global.count1] != -1);
						Global.difficultySetting = Global.count1;
						Break;
					End;
				End;
			"Else set to beginner"
			Else;
				Global.difficultySetting = 1;
			End;
		End;
		Start Rule(determineObjectiveType, Restart Rule);
		Start Rule(setDifficulty, Restart Rule);
	}
}

rule("setDifficulty")
{
	event
	{
		Subroutine;
		setDifficulty;
	}

	actions
	{
		"Difficulty: Beginner"
		If(Global.difficultySetting == 1);
			Global.startTime = 600;
			"Bot Health Values"
			Global.botHealthValues = Array(213, 130, 75, 750, 1250, 100, 110, 500, 125, 450, 100, 400, 200, 250, 100);
			"Bot bite damage"
			Global.biteDamages = Array(5, 2.500, 2, 20, 0, 5, 2, 7.500, 5, 10, 10, 5, 30, 0, 3);
			"Bot bite durations"
			Global.biteDurations = Array(2, 2, 2.500, 2.500, 0, 1.500, 3.500, 2, 2, 1.500, 1, 1, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.550, 0.600, 0.750, 0.400, 0.500, 0.600, 0.300, 0.550, 0.450, 0.500, 0.750, 0.550, 0.400, 0.500,
				0.300);
			"Bot damage dealt"
			Global.damageDealt = Array(8.500, 60, 1, 1, 50, 75, 1, 25, 1, 50, 1, 50, 75, 50, 5);
		"Difficulty: Normal"
		Else If(Global.difficultySetting == 2);
			Global.startTime = 600;
			"Bot Health Values"
			Global.botHealthValues = Array(225, 170, 125, 900, 2000, 140, 140, 700, 160, 650, 135, 600, 275, 400, 150);
			"Bot bite damage"
			Global.biteDamages = Array(5, 2.500, 2, 20, 0, 5, 2, 7.500, 5, 10, 10, 5, 30, 0, 3);
			"Bot bite durations"
			Global.biteDurations = Array(2, 2, 2.500, 2.500, 0, 1.500, 3.500, 2, 2, 1.500, 1, 1, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.850, 0.900, 1, 0.600, 0.700, 0.800, 0.400, 0.750, 0.700, 0.650, 0.900, 0.800, 0.650, 0.700, 0.350);
			"Bot damage dealt"
			Global.damageDealt = Array(8.500, 60, 1, 1, 50, 75, 1, 25, 1, 50, 1, 50, 75, 50, 5);
		"Difficulty: Expert"
		Else If(Global.difficultySetting == 3);
			Global.startTime = 450;
			"Bot Health Values"
			Global.botHealthValues = Array(225, 170, 125, 900, 2000, 140, 140, 700, 160, 650, 135, 600, 275, 400, 150);
			"Bot bite damage"
			Global.biteDamages = Array(25, 15, 20, 65, 0, 20, 17.500, 20, 30, 20, 40, 12.500, 60, 0, 10);
			"Bot bite durations"
			Global.biteDurations = Array(3, 3, 3, 3, 0, 1.500, 4, 2, 2, 2, 1, 1.500, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.850, 0.900, 1, 0.600, 0.700, 0.800, 0.400, 0.750, 0.700, 0.650, 0.900, 0.800, 0.650, 0.700, 0.350);
			"Bot damage dealt"
			Global.damageDealt = Array(125, 125, 50, 50, 150, 175, 50, 150, 50, 150, 1, 90, 75, 100, 75);
		"Difficulty: Legendary"
		Else If(Global.difficultySetting == 4);
			Global.startTime = 450;
			"Bot Health Values"
			Global.botHealthValues = Array(300, 200, 125, 900, 2000, 160, 150, 800, 200, 750, 175, 600, 300, 400, 200);
			"Bot bite damage"
			Global.biteDamages = Array(35, 22, 25, 75, 0, 25, 20, 25, 35, 25, 90, 31, 70, 0, 20);
			"Bot bite durations"
			Global.biteDurations = Array(3, 3, 3, 3, 0, 1.500, 4, 2, 2, 2, 1, 1.500, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.900, 0.950, 1, 0.750, 0.850, 0.900, 0.700, 0.800, 0.800, 0.750, 0.900, 0.800, 0.650, 0.700, 0.500);
			"Bot damage dealt"
			Global.damageDealt = Array(150, 150, 100, 100, 200, 225, 100, 200, 100, 175, 50, 175, 100, 150, 150);
		"Difficulty: Insanity"
		Else If(Global.difficultySetting == 5);
			Global.startTime = 300;
			"Bot Health Values"
			Global.botHealthValues = Array(300, 250, 200, 1200, 2500, 200, 250, 1000, 250, 900, 200, 800, 350, 600, 275);
			"Bot bite damage"
			Global.biteDamages = Array(35, 30, 35, 85, 0, 30, 35, 35, 45, 40, 110, 60, 80, 0, 35);
			"Bot bite durations"
			Global.biteDurations = Array(3, 3, 3, 3, 0, 1.500, 4, 2, 2, 2, 1, 1.500, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(1, 1, 1, 1, 1, 1, 0.99, 1, 1, 1, 1, 1, 1, 1, 1);
			"Bot damage dealt"
			Global.damageDealt = Array(300, 300, 250, 150, 230, 450, 150, 400, 300, 350, 200, 250, 150, 200, 200);
		End;
	}
}

rule("determineObjectiveType")
{
	event
	{
		Subroutine;
		determineObjectiveType;
	}

	actions
	{
		Global.objectiveTypeSetting = 0;
		For Global Variable(count1, 1, Count Of(Global.objectiveTypeVotes), 1);
			If(Global.objectiveTypeVotes[Global.count1][1]);
				Global.objectiveTypeVotes[Global.count1] = Count Of(Filtered Array(All Players(Team 1),
					Current Array Element.playerActiveStatus && Current Array Element.playerMenuStatus[4] == Global.count1));
			Else;
				Global.objectiveTypeVotes[Global.count1] = -1;
			End;
		End;
		For Global Variable(count1, 1, Count Of(Global.objectiveTypeVotes), 1);
			If(Global.objectiveTypeVotes[Global.objectiveTypeSetting] < Global.objectiveTypeVotes[Global.count1]);
				Global.objectiveTypeSetting = Global.count1;
			Else If(Global.objectiveTypeVotes[Global.objectiveTypeSetting] == Global.objectiveTypeVotes[Global.count1]);
				"Pick random objective type to break tie"
				If(Global.objectiveTypeSetting != 0 && Random Integer(0, 1) == 0);
					Global.objectiveTypeSetting = Global.count1;
				End;
			End;
		End;
		"If all players choose no preference, randomize"
		If(Global.objectiveTypeSetting == 0);
			If(Last Of(Global.objectiveTypeVotes) != -1);
				Global.objectiveTypeSetting = Count Of(Global.objectiveTypeVotes) - 1;
			Else;
				While(Global.objectiveTypeSetting == 0 || Global.objectiveTypeVotes[Global.objectiveTypeSetting] == -1);
					Global.objectiveTypeSetting = Random Integer(1, Count Of(Global.objectiveTypeVotes) - 1);
				End;
			End;
		End;
		Global.voting = False;
		Start Rule(setObjectiveType, Restart Rule);
	}
}

rule("setObjectiveType")
{
	event
	{
		Subroutine;
		setObjectiveType;
	}

	actions
	{
		"Wait until game begins"
		Wait Until(Is Game In Progress && !Global.specialGameModeSetup, 99999);
		"Create objective positions"
		While(Count Of(Global.objectiveTypes) < Workshop Setting Integer(Custom String("General"), Custom String("Number of Objectives"),
			5, 0, 100, 0) + 1);
			If(Global.objectiveTypeSetting != Count Of(Global.objectiveTypeVotes) - 1);
				Modify Global Variable(objectiveTypes, Append To Array, Global.objectiveTypeSetting);
			Else;
				"Mixed objective assignment"
				Modify Global Variable(objectiveTypes, Append To Array, Random Value In Array(Remove From Array(Global.mixedObjectivesPool,
					Filtered Array(Global.objectiveTypes, Current Array Index > Count Of(Global.objectiveTypes) - 1 - (Count Of(
					Global.mixedObjectivesPool) - 1)))));
			End;
			Global.objectiveCount1 = 0;
			While(Count Of(Global.objectivePositions) < Count Of(Global.objectiveTypes));
				"Limits possible map grid points to set min and max range from last created objective position"
				Global.testPos = Random Value In Array(Count Of(Global.objectivePositions) == 0 ? Global.mapGrid : Filtered Array(Global.mapGrid,
					Distance Between(Current Array Element, Last Of(Global.objectivePositions)) > First Of(Global.objectiveSpacing)
					&& Distance Between(Current Array Element, Last Of(Global.objectivePositions)) < Min(100, First Of(Global.objectiveSpacing)
					* 3)));
				Global.testPos += Vector(0, 1, 0);
				Wait(0.016, Ignore Condition);
				"Minimum objective spacing"
				If(Count Of(Global.objectivePositions) == 0 || Is True For All(Array Slice(Global.objectivePositions, Count Of(
					Global.objectivePositions) - 5, 5), Distance Between(Global.testPos, Current Array Element) > Global.objectiveSpacing[1]));
					"Ensures bosses spawn with head room"
					If(Last Of(Global.objectiveTypes) != 3 || Is In Line of Sight(Global.testPos + Vector(0, 0, 0), Global.testPos + Vector(0, 10, 0),
						Barriers Do Not Block LOS));
						Modify Global Variable(objectivePositions, Append To Array, Global.testPos);
						Global.objectiveCount1 = 0;
					End;
				End;
				Global.objectiveCount1 += 1;
				"If Too many attempts"
				If(Global.objectiveCount1 > 50);
					Modify Global Variable(objectivePositions, Remove From Array By Index, Count Of(Global.objectivePositions) - 1);
					Modify Global Variable(objectivePositions, Remove From Array By Index, Count Of(Global.objectivePositions) - 1);
					Global.objectiveCount1 = 0;
				End;
			End;
		End;
		"Last objective must be extraction objective"
		Global.objectiveTypes[Count Of(Global.objectiveTypes) - 1] = 1;
		Call Subroutine(objectivesManagement);
		Global.gameStatus = True;
	}
}

rule("enableEnhancements")
{
	event
	{
		Subroutine;
		enableEnhancements;
	}

	actions
	{
		Global.enhancementOptions = Empty Array;
		Global.enhancementOptions[0] = True;
		Global.enhancementOptions[1] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Infection Resistance"), True,
			1);
		Global.enhancementOptions[2] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Scavenger"), True, 2);
		Global.enhancementOptions[3] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Laser Barricade"), True, 3);
		Global.enhancementOptions[4] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Brain Killer"), True, 4);
		Global.enhancementOptions[5] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Pyrotechnic"), True, 5);
		Global.enhancementOptions[6] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Plague Doctor"), True, 6);
		Global.enhancementOptions[7] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Born to Battle"), True, 7);
		Global.enhancementOptions[8] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Kevlar"), True, 8);
		Global.enhancementOptions[9] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Nano Nurse"), True, 9);
		Global.enhancementOptions[10] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Hitchhiker"), True, 10);
		Global.enhancementOptions[11] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("P.U.P."), True, 11);
	}
}

disabled rule("============================================== GLOBAL START MENU ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("GLOBAL MENU INITIALIZATION")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Count Of(Global.mapGrid) > 0;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Global.startCamDistance = 6.500;
		If(Global.specialGameMode);
			If(Current Game Mode == Game Mode(Capture the Flag) || Current Game Mode == Game Mode(Push));
				Global.startPos = Global.walkCenter + Direction From Angles(Random Real(0, 360), 0) * 300 + Vector(0, 15, 0);
			Else If(Current Game Mode == Game Mode(Control));
				Global.startPos = Global.walkCenter + Direction From Angles(Random Real(0, 360), 0) * 300 + Vector(0, 100, 0);
			Else;
				Global.startPos = Global.walkCenter + Direction From Angles(Random Real(0, 360), 0) * 150 + Vector(0, 30, 0);
			End;
			Global.startCamPos = Global.startPos + Vector(0, 1.500, 0) + Direction From Angles(Horizontal Angle From Direction(
				Direction Towards(Global.walkCenter, Global.startPos)), 0) * Global.startCamDistance;
			Wait(0.016, Ignore Condition);
			Create Dummy Bot(Hero(Reaper), Team 2, -1, Nearest Walkable Position(Global.startPos), Vector(0, 0, 1));
			Wait(0.016, Ignore Condition);
			Set Invisible(All Players(Team 2), All);
			Start Forcing Player Position(First Of(All Players(Team 2)), Global.startPos + Vector(0, 15, 0), True);
			Start Facing(All Players(Team 2), Vector(0, 0, 1), 100000, To World, Direction and Turn Rate);
		Else;
			While(Global.startPos == Null);
				Global.startPos = Objective Position(Random Integer(0, Current Game Mode != Game Mode(Assault) ? 2 : 1));
				disabled Global.startPos = Objective Position(1);
				Global.startCamPos = Global.startPos + Vector(0, 1.500, 0) + Direction From Angles(Random Real(0, 360), 0)
					* Global.startCamDistance;
				Global.startCamPos = Ray Cast Hit Position(Global.startCamPos, Global.startCamPos - Vector(0, 5, 0), Null, Null, False) + Vector(0,
					1.500, 0);
				Global.startPos = Vector(X Component Of(Global.startPos), Y Component Of(Global.startCamPos) - 1.500, Z Component Of(
					Global.startPos));
				Global.startPos = Ray Cast Hit Position(Global.startPos + Vector(0, 0.400, 0), Global.startPos - Vector(0, 5, 0), Null, Null,
					False);
				Global.startPos = Ray Cast Hit Position(Global.startCamPos - Vector(0, 0.750, 0), Global.startPos + Vector(0, 0.750, 0), Null,
					Null, False) - Vector(0, 0.750, 0);
				Global.startCamPos = Global.startPos + Vector(0, 1.500, 0) + Direction From Angles(Horizontal Angle From Direction(
					Direction Towards(Global.startPos, Global.startCamPos)), 0) * Global.startCamDistance;
				"Line of Sight Checks for each player position"
				For Global Variable(count1, -26, 27, 2);
					If(!Is In Line of Sight(Global.startCamPos, Global.startCamPos + Vector(0, -0.750, 0) + Direction From Angles(
						Horizontal Angle From Direction(Direction Towards(Global.startCamPos, Global.startPos)) + Global.count1, 0)
						* Global.startCamDistance, Barriers Do Not Block LOS) || !Is In Line of Sight(Global.startCamPos + Vector(0, -0.750, 0)
						+ Direction From Angles(Horizontal Angle From Direction(Direction Towards(Global.startCamPos, Global.startPos))
						+ Global.count1, 0) * Global.startCamDistance, Global.startCamPos, Barriers Do Not Block LOS));
						Global.startPos = Null;
						Break;
					End;
				End;
				Wait(0.016, Ignore Condition);
			End;
		End;
		Global.startMenuSpacingAngle = 40;
		"Start screen objective description"
		Set Objective Description(All Players(All Teams), Global.voting ? Custom String("Voting ends in {0}s", Round To Integer(
			Match Time - Global.votingEndTime, Up)) : Custom String("Select your hero"), Visible To and String);
	}
}

rule("EFFECTS/TEXTS")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Pre game objective description and match timer"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} | {1}s", Global.voting ? Custom String(
			"Voting will end in {0}s", Round To Integer(Match Time - Global.votingEndTime, Up)) : Custom String("Select your hero"),
			Round To Integer(Match Time, Up)), Top, -1, Color(Gray), Color(Gray), Custom Color(215, 215, 215, 255), Visible To and String,
			Default Visibility);
		"Creator/Game Code Promo"
		Create HUD Text(All Players(All Teams), Null, Null, Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Custom String(
			"Game Code: MPJFR") : Custom String("Game Mode Creator: Mazattack#1183"), Right, 0, Color(White), Color(White), Color(Blue),
			Visible To and String, Visible Always);
		"Discord Promo"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Discord Link in the Game Description"), Right, 1, Color(White),
			Color(White), Color(Purple), Visible To and String, Visible Always);
		"Workshop.codes/Github Promo"
		Create HUD Text(All Players(All Teams), Null, Null, Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Custom String(
			"Workshop.codes/MPJFR") : Custom String("github.com/Mazattack1999/zsm-ow"), Right, 2, Color(White), Color(White),
			Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Color(Orange) : Color(Green), Visible To String and Color,
			Visible Always);
		"Workshop.codes/Discord Promo"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.playerMenuStatus) < 2),
			Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Custom String("workshop.codes/MPJFR") : Custom String(
			"Discord link in the game description"), Global.startCamPos + Direction From Angles(Horizontal Angle From Direction(
			Direction Towards(Global.startCamPos, Global.startPos)), 30), 3, Do Not Clip, Visible To Position String and Color,
			Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Color(Orange) : Color(Purple), Visible Never);
		"Words of encouragement"
		Create In-World Text(All Players(All Teams), Custom String("Words of Encouragement: {0}", Random Value In Array(
			Global.wordsOfEncouragement)), Global.startCamPos + Direction From Angles(Horizontal Angle From Direction(Direction Towards(
			Global.startCamPos, Global.startPos)), 35), 1.500, Do Not Clip, Visible To and Position, Color(White), Visible Never);
		"Voting options reminder"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.playerMenuStatus) == 2),
			Global.voting ? Custom String("Voting options are available in the top left corner of your screen") : Custom String(
			"Voting is complete. See the game settings in the top left corner of your screen."),
			Global.startCamPos + Direction From Angles(Horizontal Angle From Direction(Direction Towards(Global.startCamPos,
			Global.startPos)), 30), 2, Do Not Clip, Visible To Position String and Color, Global.voting ? Color(Aqua) : Color(Purple),
			Visible Never);
		"Ready In World Text"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.playerMenuStatus) == 1), Custom String(
			"Ready [{0}]", Input Binding String(Button(Jump))), Local Player.startPos + Vector(0, 1.920, 0), 1, Do Not Clip,
			Visible To Position String and Color, Color(Green), Visible Never);
		"Change Hero In World Text"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.playerMenuStatus)
			== 1 && Match Time > 2.500), Custom String("Change Hero [{0}]", Input Binding String(Button(Crouch))),
			Local Player.startPos + Vector(0, 1.800, 0), 1, Do Not Clip, Visible To Position String and Color, Color(Orange),
			Visible Never);
		"Cancel In World Text"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.playerMenuStatus)
			== 2 && Match Time > 2.500), Custom String("Cancel [{0}]", Input Binding String(Button(Crouch))),
			Local Player.startPos + Vector(0, -0.600, 0), 1, Do Not Clip, Visible To Position String and Color, Custom Color(255, 49, 49,
			255), Visible Never);
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 0), Custom String(
			"Difficulty: No Preference"), Null, Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate))), Left,
			0, Color(Aqua), Color(Aqua), Color(Aqua), Visible To and String, Default Visibility);
		"Vote difficulty text: Beginner"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 1), Custom String(
			"Difficulty: Beginner"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(
			Ultimate))) : Custom String(""), Left, 0, Color(Green), Color(Green), Color(Green), Visible To and String, Default Visibility);
		"Vote difficulty text: Normal"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 2), Custom String(
			"Difficulty: Normal"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate)))
			: Custom String(""), Left, 0, Color(Yellow), Color(Yellow), Color(Yellow), Visible To and String, Default Visibility);
		"Vote difficulty text: Expert"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 3), Custom String(
			"Difficulty: Expert"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate)))
			: Custom String(""), Left, 0, Color(Orange), Color(Orange), Color(Orange), Visible To and String, Default Visibility);
		"Vote difficulty text: Legendary"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 4), Custom String(
			"Difficulty: Legendary"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(
			Ultimate))) : Custom String(""), Left, 0, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
		"Vote difficulty text: Insanity"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 5),
			Global.specialEffectsTiming ? Global.specialEffectsStrings : Custom String("Difficulty: Insanity"), Null,
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate))) : Custom String(""), Left,
			0, Global.specialEffectsTiming ? Color(White) : Color(Turquoise), Color(White), Global.specialEffectsTiming ? Color(White)
			: Color(Turquoise), Visible To String and Color, Default Visibility);
		"Vote zombie mode text: No preference"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 0), Custom String(
			"Zombie Wave: No Preference"), Null, Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))), Left,
			1, Color(Aqua), Color(Aqua), Color(Aqua), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 1"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 1), Custom String(
			"Wave 1 - The Beginning"), Custom String("Years after the outbreak begins, zombies start developing strange abilities."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Green), Color(White), Color(Green), Visible To and String, Default Visibility);
		"Vote game type text: Wave 2"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 2), Custom String(
			"Wave 2 - Darker Days"), Custom String("As the outbreak continues, zomibes with more powerful abilities appear."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Yellow), Color(White), Color(Yellow), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 3"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 3), Custom String(
			"Wave 3 - Tipping Point"), Custom String("The outbreak reaches its peak when there are few normal zombies left."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Orange), Color(White), Color(Orange), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 4"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 4), Custom String(
			"Wave 4 - Turning Tide"), Custom String("As mankind fights off the hoard, the number of weaker zombies begins to dwindle."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Red), Color(White), Color(Red), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 5 - The Final Days"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 5), Custom String(
			"Wave 5 - The Final Days"), Custom String("The outbreak is nearly over. Only the strongest zombies remain."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Global.specialEffectsTiming ? Color(White) : Color(Turquoise), Color(White), Global.specialEffectsTiming ? Color(White)
			: Color(Turquoise), Visible To String and Color, Default Visibility);
		"Vote objective type text: No preference"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 0), Custom String(
			"Objective Type: No Preference"), Null, Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 2))),
			Left, 2, Color(Aqua), Color(Aqua), Color(Aqua), Visible To and String, Default Visibility);
		"Vote objective type text: Capture Points Only"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 1), Custom String(
			"Objective Type: Capture Points {0}", Icon String(Flag)), Custom String(
			"Players must secure and capture locations around the map"), Global.voting ? Custom String("Change Vote (Press [{0}])",
			Input Binding String(Button(Ability 2))) : Custom String(""), Left, 2, Color(Orange), Color(Orange), Color(Orange),
			Visible To and String, Default Visibility);
		"Vote objective type text: Eliminations"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 2), Custom String(
			"Objective Type: Eliminations {0}", Icon String(Skull)), Custom String("Players must eliminate a set number of zombies"),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 2))) : Custom String(""), Left,
			2, Color(Blue), Color(Blue), Color(Blue), Visible To and String, Default Visibility);
		"Vote objective type text: Boss Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 3), Custom String(
			"Objective Type: Bosses {0}", Icon String(Warning)), Custom String("Spawns giant versions of zombies"),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 2))) : Custom String(""), Left,
			2, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
		"Vote objective type text: Resource Collection Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 4), Custom String(
			"Objective Type: Resource Collection {0}", Icon String(Plus)), Custom String(
			"Find scattered resources and bring them to a collection site"), Global.voting ? Custom String("Change Vote (Press [{0}])",
			Input Binding String(Button(Ability 2))) : Custom String(""), Left, 2, Color(Green), Color(Green), Color(Green),
			Visible To and String, Default Visibility);
		"Vote objective type text: Survivor Rescue Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 5), Custom String(
			"Objective Type: Survivor Rescue {0}", Icon String(Halo)), Custom String("Lead a survivor to an extraction site"),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 2))) : Custom String(""), Left,
			2, Color(Violet), Color(Violet), Color(Violet), Visible To and String, Default Visibility);
		"Vote objective type text: Kill Zone Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 6), Custom String(
			"Objective Type: Kill Zone {0}", Round To Integer(Total Time Elapsed * 1.250, Up) % 2 == 0 ? Icon String(Ring Thick)
			: Icon String(Ring Thin)), Custom String("Clear zombies from a designated area"), Global.voting ? Custom String(
			"Change Vote (Press [{0}])", Input Binding String(Button(Ability 2))) : Custom String(""), Left, 2, Color(Red), Color(Red),
			Color(Red), Visible To and String, Default Visibility);
		"Vote objective type text: Zombie Egg Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 7), Custom String(
			"Objective Type: Zombie Egg {0}", Icon String(Radioactive)), Custom String(
			"Survivors must destroy an object that is spawning zombies"), Global.voting ? Custom String("Change Vote (Press [{0}])",
			Input Binding String(Button(Ability 2))) : Custom String(""), Left, 2, Color(Lime Green), Color(Lime Green), Color(Lime Green),
			Visible To and String, Default Visibility);
		"Vote objective type text: Satellite Uplink Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 8), Custom String(
			"Objective Type: Satellite Uplink {0}", Icon String(Moon)), Custom String(
			"Survivors must repair terminals to communicate with a satellite"), Global.voting ? Custom String("Change Vote (Press [{0}])",
			Input Binding String(Button(Ability 2))) : Custom String(""), Left, 2, Custom Color(12, 129, 132, 255), Custom Color(12, 129,
			132, 255), Custom Color(12, 129, 132, 255), Visible To and String, Default Visibility);
		"Vote objective type text: Graveyard Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == 9), Custom String(
			"Objective Type: Graveyard {0}", Icon String(Skull)), Custom String(
			"Survivors must clear an area where zombies are coming out of the ground"), Global.voting ? Custom String(
			"Change Vote (Press [{0}])", Input Binding String(Button(Ability 2))) : Custom String(""), Left, 2, Color(Turquoise), Color(
			Turquoise), Color(Turquoise), Visible To and String, Default Visibility);
		"Vote objective type text: Mixed Objectives"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[4] == Count Of(
			Global.objectiveTypeVotes) - 1), Custom String("Objective Type: Mixed Objectives {0}", Icon String(Spiral)), Custom String(
			"Randomly assigns all types of objectives"), Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(
			Button(Ability 2))) : Custom String(""), Left, 2, Color(Purple), Color(Purple), Color(Purple), Visible To and String,
			Default Visibility);
		"Enhancement Selection: No Preference"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 0), Custom String(
			"Enhancement: No Preference"), Null, Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))),
			Left, 3, Color(Aqua), Color(Aqua), Color(Aqua), Visible To and String, Default Visibility);
		"Enhancement Selection: Infection Resistance"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 1), Custom String(
			"Enhancement: Infection Resistance {0}", Icon String(Poison 2)), Custom String("Infection level decreases slowly over time"),
			Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Green), Color(Green),
			Color(Green), Visible To and String, Default Visibility);
		"Enhancement Selection: Scavenger"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 2), Custom String(
			"Enhancement: Scavenger {0}", Ability Icon String(Hero Of(Local Player), Button(Primary Fire))), Custom String(
			"Player collects ammunition from zombies they kill"), Custom String("Change Selection (Press [{0}])", Input Binding String(
			Button(Melee))), Left, 3, Color(Gray), Color(Gray), Color(Gray), Visible To and String, Default Visibility);
		"Enhancement Selection: Laser Barricade"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 3), Custom String(
			"Enhancement: Laser Barricade {0}", Ability Icon String(Hero(Reinhardt), Button(Secondary Fire))), Custom String(
			"Player can place a wall that blocks zombies"), Custom String("Change Selection (Press [{0}])", Input Binding String(Button(
			Melee))), Left, 3, Color(Blue), Color(Blue), Color(Blue), Visible To and String, Default Visibility);
		"Enhancement Selection: Brain Killer"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 4), Custom String(
			"Enhancement: Brain Killer {0}", Icon String(Skull)), Custom String("Critical hits do more damage"), Custom String(
			"Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Red), Color(Red), Color(Red),
			Visible To and String, Default Visibility);
		"Enhancement Selection: Pyrotechnic"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 5), Custom String(
			"Enhancement: Pyrotechnic {0}", Icon String(Fire)), Custom String("Dealing damage, at close range, sets enemies on fire"),
			Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Orange), Color(Orange),
			Color(Orange), Visible To and String, Default Visibility);
		"Enhancement Selection: Plague Doctor"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 6), Custom String(
			"Enhancement: Plague Doctor {0}", Icon String(Plus)), Custom String(
			"Deal more healing to infected players while reducing their infection level"), Custom String("Change Selection (Press [{0}])",
			Input Binding String(Button(Melee))), Left, 3, Color(Green), Color(Green), Color(Green), Visible To and String,
			Default Visibility);
		"Enhancement Selection: Born to Battle"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 7), Custom String(
			"Enhancement: Born to Battle {0}", Icon String(Bolt)), Custom String(
			"Dealing a final blow will give the player a cooldown reset on the next ability they use"), Custom String(
			"Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Gray), Color(Gray), Color(Gray),
			Visible To and String, Default Visibility);
		"Enhancement Selection: Kevlar"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 8), Custom String(
			"Enhancement: Kevlar {0}", Icon String(Stop)), Custom String(
			"Survivor is equipped with armor that protects against infectious bites"), Custom String("Change Selection (Press [{0}])",
			Input Binding String(Button(Melee))), Left, 3, Custom Color(240, 129, 26, 255), Custom Color(240, 129, 26, 255), Custom Color(
			240, 129, 26, 255), Visible To and String, Default Visibility);
		"Enhancement Selection: Nano Nurse"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 9), Custom String(
			"Enhancement: Nano Nurse {0}", Icon String(Plus)), Custom String(
			"Survivor is infused with nano technology that regenerates health after taking damage "), Custom String(
			"Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Yellow), Color(Yellow), Color(Yellow),
			Visible To and String, Default Visibility);
		"Enhancement Selection: Hitchhiker"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 10), Custom String(
			"Enhancement: Hitchhiker {0}", Ability Icon String(Hero(Zenyatta), Button(Ultimate))), Custom String(
			"Survivor can ride on the backs of their teammates"), Custom String("Change Selection (Press [{0}])", Input Binding String(
			Button(Melee))), Left, 3, Color(Purple), Color(Purple), Color(Purple), Visible To and String, Default Visibility);
		"Enhancement Selection: P.U.P."
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 11), Custom String(
			"Enhancement: P.U.P. {0}", Icon String(Happy)), Custom String("Survivor is equipped with an autonomous friendly droid"),
			Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Blue), Color(Blue), Color(
			Blue), Visible To and String, Default Visibility);
	}
}

rule("SPECIAL EFFECT CONTROLS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Global.difficultySetting >= 5 || Global.specialGameModeSetup) == True;
	}

	actions
	{
		If(Global.specialGameModeSetup);
			Global.randVal = Random Integer(1, 6);
			If(Global.randVal == 1);
				Global.specialEffectsStrings = Custom String("fiiDultyc oteV: saInntyi");
			Else If(Global.randVal == 2);
				Global.specialEffectsStrings = Custom String("Your time has come");
			Else If(Global.randVal == 3);
				Global.specialEffectsStrings = Custom String("You will die");
			Else If(Global.randVal == 4);
				Global.specialEffectsStrings = Custom String("You won't win");
			Else If(Global.randVal == 5);
				Global.specialEffectsStrings = Custom String("Don't even try it");
			Else If(Global.randVal == 6);
				Global.specialEffectsStrings = Custom String("Your funeral...");
			End;
		End;
		Global.specialEffectsTiming = True;
		Wait(Random Real(0.063, 0.325), Abort When False);
		Global.specialEffectsTiming = False;
		Wait(Random Real(0.325, 1.500), Abort When False);
		Loop;
	}
}

rule("END VOTING")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.voting == True;
		Global.specialGameModeSetup == True;
		Match Time < Global.votingEndTime;
		Count Of(Filtered Array(All Players(Team 1), Current Array Element.playerMenuStatus[0] > 0)) > 0;
	}

	actions
	{
		Global.chase1 = Global.votingEndTime;
		Start Rule(determineZombieMode, Restart Rule);
		"Waits until votes have been counted"
		Wait Until(!Global.voting, 99999);
		All Players(Team 1).playerMenuStatus[2] = Global.difficultySetting;
		All Players(Team 1).playerMenuStatus[3] = Global.zombieSetting;
		All Players(Team 1).playerMenuStatus[4] = Global.objectiveTypeSetting;
		Big Message(All Players(All Teams), Custom String("Voting has ended!"));
		Start Rule(setPrematchTimer, Restart Rule);
	}
}

rule("setPrematchTimer")
{
	event
	{
		Subroutine;
		setPrematchTimer;
	}

	actions
	{
		"Cancel if hidden timer has not been set"
		Abort If(!Global.chase1);
		"Voting in progress"
		If(Global.voting);
			"Event player is voting"
			If(Event Player.playerMenuStatus[1] == 1);
				"Set match time to hidden timer"
				Set Match Time(Global.chase1);
			"Event Player is not voting"
			Else;
				"All players are finished voting"
				If(Match Time > 5 + Global.votingEndTime && Count Of(Filtered Array(All Players(Team 1),
					Current Array Element.playerMenuStatus[1] == 0 && First Of(Current Array Element.playerMenuStatus) > 0)) == Number Of Players(
					Team 1));
					Set Match Time(5 + Global.votingEndTime);
				Else If(Match Time > 20 + Global.votingEndTime && Count Of(Filtered Array(All Players(Team 1),
						Current Array Element.playerMenuStatus[1] == 0 && First Of(Current Array Element.playerMenuStatus) > 0)) == Count Of(
						Filtered Array(All Players(Team 1), Current Array Element.playerActiveStatus)));
					Set Match Time(20 + Global.votingEndTime);
				End;
			End;
		"Voting complete"
		Else;
			"Event Player deselects hero"
			If(Event Player.playerMenuStatus[0] < 2);
				Set Match Time(Global.chase1);
			Else;
				If(Match Time > 10 && Count Of(Filtered Array(All Players(Team 1), First Of(Current Array Element.playerMenuStatus) == 2))
					== Number Of Players(Team 1));
					Set Match Time(15);
					Wait(0.016, Ignore Condition);
					Set Match Time(10);
				Else If(Match Time > 20 && Count Of(Filtered Array(All Players(Team 1), First Of(Current Array Element.playerMenuStatus) == 2))
						== Count Of(Filtered Array(All Players(Team 1), Current Array Element.playerActiveStatus)));
					Set Match Time(20);
				End;
			End;
	}
}

rule("MUSIC/ANNOUNCER CONTROL")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.voting != True;
		Global.specialGameModeSetup == True;
	}

	actions
	{
		If(Match Time < 20);
			Enable Built-In Game Mode Music;
			Enable Built-In Game Mode Announcer;
			Wait Until(Match Time > 20 || !Global.specialGameModeSetup, 60);
		Else;
			Disable Built-In Game Mode Music;
			Disable Built-In Game Mode Announcer;
			Wait Until(Match Time < 20 || !Global.specialGameModeSetup, 60);
		End;
		Loop If Condition Is True;
	}
}

disabled rule("============================================== PLAYER START MENU ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYER MENU INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Global.startMenuSpacingAngle != 0;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Event Player.enhancementValues[0] = 0;
		If(Global.voting);
			"0) Hero Selection Status, 1) Voting Status, 2) Difficulty Vote, 3) Zombie Vote, 4) Objective Type Vote"
			Event Player.playerMenuStatus = Array(0, 0, 0, 0);
		Else;
			"0) Hero Selection Status, 1) Voting Status, 2) Difficulty Vote, 3) Zombie Vote, 4) Objective Type Vote"
			Event Player.playerMenuStatus[2] = Global.difficultySetting;
			Event Player.playerMenuStatus[3] = Global.zombieSetting;
			Event Player.playerMenuStatus[4] = Global.objectiveTypeSetting;
		End;
		Event Player.startPos = Global.startCamPos + Vector(0, -1.500, 0) + Direction From Angles(Horizontal Angle From Direction(
			Direction Towards(Global.startCamPos, Global.startPos)) + Global.startMenuSpacingAngle + Slot Of(Event Player) * (
			Global.startMenuSpacingAngle * -2 / Max(Number Of Slots(Team 1) - 1, 1)), 0) * Global.startCamDistance;
		If(!Global.specialGameMode);
			Event Player.startPos = Ray Cast Hit Position(Event Player.startPos + Vector(0, 3, 0), Event Player.startPos, All Players(
				All Teams), All Players(All Teams), False);
		End;
		Call Subroutine(enableDisableAbilities);
	}
}

rule("EFFECTS/TEXT")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Event Player.playerActiveStatus == True;
	}

	actions
	{
		If(!Global.specialGameMode);
			"Invis start ring"
			Create Effect(Filtered Array(All Players(All Teams), First Of(Event Player.playerMenuStatus) < 2), Ring, Color(Sky Blue),
				Event Player.startPos, 0.500, Visible To Position and Radius);
		Else;
			"Invis start light shaft"
			Create Effect(Filtered Array(All Players(All Teams), First Of(Event Player.playerMenuStatus) < 2), Light Shaft, Color(Sky Blue),
				Event Player.startPos + Vector(0, -10, 0), 0.500, Visible To Position and Radius);
		End;
		"In world hero text"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Event Player.playerMenuStatus) < 2), First Of(
			Event Player.playerMenuStatus) == 1 ? Hero Icon String(Hero Of(Event Player)) : Custom String("?"),
			Event Player.startPos + Vector(0, 0.500, 0), 3, Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
		"Selecting hero text"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Event Player.playerMenuStatus)
			< 2 && Event Player.playerMenuStatus[1] == 0), First Of(Event Player.playerMenuStatus) < 1 ? Custom String("SELECTING HERO...")
			: Custom String("Getting Ready..."), Event Player.startPos + Vector(0, 1.500, 0), 1.500, Do Not Clip,
			Visible To Position and String, Color(Sky Blue), Default Visibility);
		"Voting text"
		Create In-World Text(Filtered Array(All Players(All Teams), Event Player.playerMenuStatus[1] == 1), Custom String("Voting..."),
			Event Player.startPos + Vector(0, First Of(Event Player.playerMenuStatus) < 2 ? 1.500 : -1, 0), 1.500, Do Not Clip,
			Visible To Position and String, Color(Purple), Default Visibility);
		"Name text"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Event Player.playerMenuStatus) < 2), Event Player,
			Event Player.startPos + Vector(0, -1, 0), 1.500, Do Not Clip, Visible To Position and String, Color(Aqua), Default Visibility);
	}
}

rule("PLAYER SELECTS/RESELECTS HERO")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Global.startMenuSpacingAngle != 0;
		Event Player.playerMenuStatus[0] == 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Start Rule(setPrematchTimer, Restart Rule);
		Set Invisible(Event Player, All);
		Start Camera(Event Player, Global.startCamPos, Global.startPos + Vector(0, 1, 0), 0);
		Start Heal Over Time(Event Player, Null, 5, 1000);
		Set Status(Event Player, Null, Invincible, 9999);
		Set Status(Event Player, Null, Rooted, 9999);
		"If current game mode is team deathmatch"
		If(Global.specialGameMode);
			Attach Players(Event Player, First Of(All Players(Team 2)), Local Vector Of(Event Player.startPos, First Of(All Players(Team 2)),
				Rotation And Translation));
		Else;
			Teleport(Event Player, Event Player.startPos);
		End;
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player, Direction Towards(Event Player.startPos, Vector(X Component Of(Global.startCamPos), Y Component Of(
			Event Player.startPos), Z Component Of(Global.startCamPos))), To World);
		Wait(0.016, Ignore Condition);
		Event Player.playerMenuStatus[0] = 1;
		Wait(0.016, Ignore Condition);
		If(!Event Player.playerActiveStatus);
			Small Message(Event Player, Custom String(
				"Use the voting options in the top left corner of your screen to adjust the game settings"));
			Event Player.playerActiveStatus = True;
			Wait(5, Restart When True);
			"Force players that have not voted or selected an enhancement to lock in their hero"
			If((Global.voting && Is True For All(Array Slice(Event Player.playerMenuStatus, 2, 3),
				Current Array Element == 0 && Event Player.enhancementValues[0] == 0)) || (
				!Global.voting && Event Player.enhancementValues[0] == 0));
				Press Button(Event Player, Button(Jump));
			End;
		End;
		Loop If Condition Is True;
	}
}

rule("PLAYER MENU CONTROLS (JUMP AND CROUCH, CHANGE HERO/READY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Event Player.playerMenuStatus[0] > 0;
		(Is Button Held(Event Player, Button(Jump)) || Is Button Held(Event Player, Button(Crouch))) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		"Player indicates they are ready"
		If(Is Button Held(Event Player, Button(Jump)));
			If(First Of(Event Player.playerMenuStatus) < 2);
				Event Player.playerMenuStatus[0] += 1;
				If(First Of(Event Player.playerMenuStatus) == 2);
					Start Rule(setPrematchTimer, Restart Rule);
					Start Rule(randomActions, Restart Rule);
					Set Invisible(Event Player, None);
				End;
			End;
		"Not ready or change hero"
		Else If(Is Button Held(Event Player, Button(Crouch)) && Match Time > 2.500);
			Set Invisible(Event Player, All);
			If(First Of(Event Player.playerMenuStatus) > 0);
				Event Player.playerMenuStatus[0] += -1;
				Start Rule(setPrematchTimer, Restart Rule);
				If(First Of(Event Player.playerMenuStatus) == 0);
					"Update player voting status"
					Event Player.playerMenuStatus[1] = 0;
					Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
					Wait Until(!Has Spawned(Event Player), 1);
					Wait(0.016, Ignore Condition);
					Set Player Allowed Heroes(Event Player, All Heroes);
				End;
			End;
		End;
	}
}

rule("PLAYER MENU CONTROLS (ULTIMATE, DIFFICULTY VOTE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.voting == True;
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		"Update player voting status"
		Event Player.playerMenuStatus[1] = 1;
		If(!Is Button Held(Event Player, Button(Secondary Fire)));
			If(Event Player.playerMenuStatus[2] < Count Of(Global.difficultyVotes) - 1);
				Event Player.playerMenuStatus[2] += 1;
			Else;
				Event Player.playerMenuStatus[2] = 0;
			End;
			While(!Global.difficultyVotes[Event Player.playerMenuStatus[2]][1]);
				If(Event Player.playerMenuStatus[2] < Count Of(Global.difficultyVotes) - 1);
					Event Player.playerMenuStatus[2] += 1;
				Else;
					Event Player.playerMenuStatus[2] = 0;
				End;
			End;
		Else;
			If(Event Player.playerMenuStatus[2] > 0);
				Event Player.playerMenuStatus[2] += -1;
			Else;
				Event Player.playerMenuStatus[2] = Count Of(Global.difficultyVotes) - 1;
			End;
			While(!Global.difficultyVotes[Event Player.playerMenuStatus[2]][1]);
				If(Event Player.playerMenuStatus[2] > 0);
					Event Player.playerMenuStatus[2] += -1;
				Else;
					Event Player.playerMenuStatus[2] = Count Of(Global.difficultyVotes) - 1;
				End;
			End;
	}
}

rule("PLAYER MENU CONTROLS (ABILITY 1, ZOMBIE VOTE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.voting == True;
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		"Update player voting status"
		Event Player.playerMenuStatus[1] = 1;
		If(!Is Button Held(Event Player, Button(Secondary Fire)));
			If(Event Player.playerMenuStatus[3] < Count Of(Global.zombieVotes) - 1);
				Event Player.playerMenuStatus[3] += 1;
			Else;
				Event Player.playerMenuStatus[3] = 0;
			End;
			While(!Global.zombieVotes[Event Player.playerMenuStatus[3]][1]);
				If(Event Player.playerMenuStatus[3] < Count Of(Global.zombieVotes) - 1);
					Event Player.playerMenuStatus[3] += 1;
				Else;
					Event Player.playerMenuStatus[3] = 0;
				End;
			End;
		Else;
			If(Event Player.playerMenuStatus[3] > 0);
				Event Player.playerMenuStatus[3] += -1;
			Else;
				Event Player.playerMenuStatus[3] = Count Of(Global.zombieVotes) - 1;
			End;
			While(!Global.zombieVotes[Event Player.playerMenuStatus[3]][1]);
				If(Event Player.playerMenuStatus[3] > 0);
					Event Player.playerMenuStatus[3] += -1;
				Else;
					Event Player.playerMenuStatus[3] = Count Of(Global.zombieVotes) - 1;
				End;
			End;
	}
}

rule("PLAYER MENU CONTROLS (ABILITY 2, OBJECTIVE TYPE VOTE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.voting == True;
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Ability 2)) == True;
	}

	actions
	{
		"Update player voting status"
		Event Player.playerMenuStatus[1] = 1;
		If(!Is Button Held(Event Player, Button(Secondary Fire)));
			If(Event Player.playerMenuStatus[4] < Count Of(Global.objectiveTypeVotes) - 1);
				Event Player.playerMenuStatus[4] += 1;
			Else;
				Event Player.playerMenuStatus[4] = 0;
			End;
			While(!Global.objectiveTypeVotes[Event Player.playerMenuStatus[4]][1]);
				If(Event Player.playerMenuStatus[4] < Count Of(Global.objectiveTypeVotes) - 1);
					Event Player.playerMenuStatus[4] += 1;
				Else;
					Event Player.playerMenuStatus[4] = 0;
				End;
			End;
		Else;
			If(Event Player.playerMenuStatus[4] > 0);
				Event Player.playerMenuStatus[4] += -1;
			Else;
				Event Player.playerMenuStatus[4] = Count Of(Global.objectiveTypeVotes) - 1;
			End;
			While(!Global.objectiveTypeVotes[Event Player.playerMenuStatus[4]][1]);
				If(Event Player.playerMenuStatus[4] > 0);
					Event Player.playerMenuStatus[4] += -1;
				Else;
					Event Player.playerMenuStatus[4] = Count Of(Global.objectiveTypeVotes) - 1;
				End;
			End;
	}
}

rule("PLAYER MENU CONTROLS (MELEE , ENHANCEMENT SELECTION)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		If(!Is Button Held(Event Player, Button(Secondary Fire)));
			If(First Of(Event Player.enhancementValues) < Count Of(Global.enhancementOptions) - 1);
				Event Player.enhancementValues[0] += 1;
			Else;
				Event Player.enhancementValues[0] = 0;
			End;
			While(!Global.enhancementOptions[First Of(Event Player.enhancementValues)]);
				If(First Of(Event Player.enhancementValues) < Count Of(Global.enhancementOptions) - 1);
					Event Player.enhancementValues[0] += 1;
				Else;
					Event Player.enhancementValues[0] = 0;
				End;
			End;
		Else;
			If(First Of(Event Player.enhancementValues) > 0);
				Event Player.enhancementValues[0] += -1;
			Else;
				Event Player.enhancementValues[0] = Count Of(Global.enhancementOptions) - 1;
			End;
			While(!Global.enhancementOptions[First Of(Event Player.enhancementValues)]);
				If(First Of(Event Player.enhancementValues) > 0);
					Event Player.enhancementValues[0] += -1;
				Else;
					Event Player.enhancementValues[0] = Count Of(Global.enhancementOptions) - 1;
				End;
			End;
	}
}

rule("UPDATE PREGAME VOTING STATUS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Event Player.playerMenuStatus[1] == 1;
		Is Button Held(Event Player, Button(Ultimate)) == False;
		Is Button Held(Event Player, Button(Ability 1)) == False;
		Is Button Held(Event Player, Button(Ability 2)) == False;
	}

	actions
	{
		Start Rule(setPrematchTimer, Restart Rule);
		Wait(2, Abort When False);
		Event Player.playerMenuStatus[1] = 0;
		Start Rule(setPrematchTimer, Restart Rule);
	}
}

rule("PREVENT PLAYERS FROM LEAVING START EARLY")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		First Of(Event Player.playerMenuStatus) > 0;
		Distance Between(Position Of(Event Player), Vector(X Component Of(Event Player.startPos), Y Component Of(Position Of(
			Event Player)), Z Component Of(Event Player.startPos))) > 0.600;
	}

	actions
	{
		Wait(2, Abort When False);
		If(!Global.specialGameMode);
			Teleport(Event Player, Event Player.startPos);
		Else;
			Attach Players(Event Player, First Of(All Players(Team 2)), Local Vector Of(Event Player.startPos, First Of(All Players(Team 2)),
				Rotation And Translation));
		End;
		Loop If Condition Is True;
	}
}

rule("randomActions")
{
	event
	{
		Subroutine;
		randomActions;
	}

	actions
	{
		Event Player.randVal = Random Integer(1, 4);
		"Random emote"
		If(Event Player.randVal <= 1);
			Communicate(Event Player, Emote Up);
		Else If(Event Player.randVal <= 2);
			Communicate(Event Player, Emote Down);
		Else If(Event Player.randVal <= 3);
			Communicate(Event Player, Emote Left);
		Else If(Event Player.randVal <= 4);
			Communicate(Event Player, Emote Right);
		End;
		Wait(1, Ignore Condition);
		Event Player.randVal = Random Integer(1, 4);
		"Random voice line"
		If(Event Player.randVal <= 1);
			Communicate(Event Player, Voice Line Up);
		Else If(Event Player.randVal <= 2);
			Communicate(Event Player, Voice Line Down);
		Else If(Event Player.randVal <= 3);
			Communicate(Event Player, Voice Line Left);
		Else If(Event Player.randVal <= 4);
			Communicate(Event Player, Voice Line Right);
		End;
	}
}

rule("enableDisableAbilities")
{
	event
	{
		Subroutine;
		enableDisableAbilities;
	}

	actions
	{
		If(Global.specialGameModeSetup);
			Disable Hero HUD(Event Player);
			Set Primary Fire Enabled(Event Player, False);
			Set Secondary Fire Enabled(Event Player, False);
			Set Ability 1 Enabled(Event Player, False);
			Set Ability 2 Enabled(Event Player, False);
			Set Ultimate Ability Enabled(Event Player, False);
			Set Melee Enabled(Event Player, False);
		Else;
			Set Primary Fire Enabled(Event Player, True);
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Set Ultimate Ability Enabled(Event Player, True);
			Set Melee Enabled(Event Player, True);
			Enable Hero HUD(Event Player);
		End;
	}
}

disabled rule("============================================== GLOBAL GAME IN PROGRESS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("EFFECTS/TEXTS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != True;
	}

	actions
	{
		Wait(1, Ignore Condition);
		"Objective description and match timer"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}{1}", Global.objectiveDescription,
			Match Time > 0 + Global.matchEndTime ? Custom String(" | {0}", Match Time <= 60 ? Custom String("{0}s", Match Time)
			: Custom String("{0}:{2}{1}", Round To Integer(Match Time / 60, Down), Round To Integer(Match Time % 60, Down),
			Round To Integer(Match Time % 60, Down) < 10 ? 0 : Custom String(""))) : Custom String("")), Top, -1, Color(Gray), Color(Gray),
			Custom Color(215, 215, 215, 255), Visible To and String, Default Visibility);
		"Infected Hud"
		Create HUD Text(Filtered Array(All Players(All Teams), (Count Of(Global.healthpackPositions) == 0 || Health(Current Array Element)
			< Round To Integer(Current Array Element.infectionLvl, Down) ^ 4 / 16 * 20)
			&& Current Array Element.infected && Match Time > Global.matchEndTime), Custom String("{0} Find a healthpack {0}", Icon String(
			Plus)), Null, Null, Right, 0, Round To Integer(Total Time Elapsed * 2, Up) % 2 == 0 ? (Health(Local Player) < Round To Integer(
			Local Player.infectionLvl, Down) ^ 4 / 16 * 10 ? Color(Red) : Color(Lime Green)) : Color(White), Color(White), Color(White),
			Visible To and Color, Default Visibility);
		"Nearest Healthpack Distance"
		Create In-World Text(Filtered Array(All Players(Team 1), Count Of(Global.healthpackPositions)
			> 0 && Current Array Element.infected && Match Time > Global.matchEndTime), Custom String("Cure: {0}m", Distance Between(
			Position Of(Local Player), First Of(Sorted Array(Global.healthpackPositions, Angle Between Vectors(Facing Direction Of(
			Local Player), Direction Towards(Eye Position(Local Player), Current Array Element)))))), First Of(Sorted Array(
			Global.healthpackPositions, Angle Between Vectors(Facing Direction Of(Local Player), Direction Towards(Eye Position(
			Local Player), Current Array Element)))), 1, Do Not Clip, Visible To Position and String, Color(Green), Visible Never);
		"Nearest health pack icon"
		Create Icon(Filtered Array(All Players(Team 1), Count Of(Global.healthpackPositions)
			> 0 && Current Array Element.infected && Match Time > Global.matchEndTime), First Of(Sorted Array(Global.healthpackPositions,
			Angle Between Vectors(Facing Direction Of(Local Player), Direction Towards(Eye Position(Local Player),
			Current Array Element)))) + Vector(0, 0.750, 0) + Vector(0, 0.500 * Sine From Radians(Match Time * 1.500), 0), Poison,
			Visible To and Position, Color(Green), True);
		"SERVER LOAD"
		Create HUD Text(String Contains(Custom String("{0}", Local Player), Custom String("Mazattack")) ? Local Player : Empty Array,
			Custom String("Spawn Array: {0}, {1}, {2}", Global.spawnTimes[0], Global.spawnTimes[1],  Global.spawnTimes[2]), Custom String(
			"SERVER LOAD AVERAGE: {0}", Server Load Average), Custom String("SERVER LOAD PEAK: {0}", Server Load Peak), Right, 0, Color(
			White), Color(White), Color(White), Visible To and String, Default Visibility);
		If(Global.difficultySetting == 1);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Beginner | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Green), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 2);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Normal | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Yellow), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 3);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Expert | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Orange), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 4);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Legendary | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Red), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 5);
			"Vote text: Insanity"
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Insanity | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Global.specialEffectsTiming ? Color(White) : Color(Turquoise), Visible To and Color,
				Default Visibility);
		End;
	}
}

rule("PLAYER EXTRACTION CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Array Contains(Global.evacuatingSurvivorList, Event Player) == True;
	}

	actions
	{
		Event Player.chase2 = Position Of(Event Player);
		Chase Player Variable At Rate(Event Player, chase2, Event Player.chase2 + Vector(0, 200, 0), Global.evacRate,
			Destination and Rate);
		Start Forcing Player Position(Event Player, Event Player.chase2, True);
		Wait Until(Global.evacRate > 2, 99999);
		Chase Player Variable Over Time(Event Player, chase2, First Of(Global.objectivePositions) + Vector(0, 50, 0)
			+ Direction From Angles(360 / Count Of(Global.evacuatingSurvivorList) * Index Of Array Value(Global.evacuatingSurvivorList,
			Event Player), 0) * 3, 5, Destination and Duration);
		Wait Until(Global.evacRate < 10, 99999);
		Chase Player Variable At Rate(Event Player, chase2, Event Player.chase2 + Vector(0, 200, 0), Global.evacRate,
			Destination and Rate);
		Event Player.evacPos = Event Player.chase2 + Direction Towards(First Of(Global.objectivePositions), Global.evacDestination) * 700;
		Wait Until(Global.evacRate > 2, 99999);
		Chase Player Variable At Rate(Event Player, chase2, Event Player.evacPos, Global.evacRate, Destination and Rate);
	}
}

rule("ATTACK SPAWN ROOM CONTROL")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.specialGameModeSetup != True;
		"Does not apply if game mode is special mode"
		Global.specialGameMode != True;
		Is True For Any(Global.playerTargetList, Distance Between(Position Of(Current Array Element), Global.activeAttackSpawnRoom) < 45)
			== True;
	}

	actions
	{
		Global.spawnRoomIndex += 1;
		If(Global.spawnRoomIndex >= Count Of(Global.attackSpawnRooms));
			Global.spawnRoomIndex = 0;
		End;
		"Make sure players are clear of test spawn room before activating"
		If(Is True For All(Filtered Array(All Players(Team 1), Has Spawned(Current Array Element)), Distance Between(Position Of(
			Current Array Element), Global.attackSpawnRooms[Global.spawnRoomIndex]) > 45));
			Global.activeAttackSpawnRoom = Global.attackSpawnRooms[Global.spawnRoomIndex];
			Start Forcing Spawn Room(Team 2, Global.spawnRoomIndex);
		End;
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PREVENT MATCH TIME FROM UNPAUSING")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Match Time < Global.matchEndTime;
	}

	actions
	{
		Pause Match Time;
		Set Match Time(Global.matchEndTime);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("TRIGGER OVERTIME MUSIC")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Global.overtime == False;
		Match Time < Global.matchEndTime + 3;
		Count Of(Filtered Array(All Living Players(Team 2), Current Array Element.botTarget == Null && !Array Contains(Global.bosses,
			Current Array Element))) > 0;
	}

	actions
	{
		If(!Global.specialGameMode);
			Global.overtime = True;
			If(Current Game Mode == Game Mode(Escort));
				Teleport(First Of(Filtered Array(All Living Players(Team 2), Current Array Element.botTarget == Null && !Array Contains(
					Global.bosses, Current Array Element))), Payload Position);
			Else;
				Teleport(First Of(Filtered Array(All Living Players(Team 2), Current Array Element.botTarget == Null && !Array Contains(
					Global.bosses, Current Array Element))), Objective Position(0));
			End;
		End;
	}
}

rule("PLAYER LEAVES THE GAME")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	conditions
	{
		(Is True For Any(Global.playerTargetList, !Entity Exists(Current Array Element)) || Is True For Any(Global.playersOnObjective,
			!Entity Exists(Current Array Element))) == True;
	}

	actions
	{
		Modify Global Variable(playerTargetList, Remove From Array By Value, Filtered Array(Global.playerTargetList, !Entity Exists(
			Current Array Element)));
		Modify Global Variable(playersOnObjective, Remove From Array By Value, Filtered Array(Global.playersOnObjective, !Entity Exists(
			Current Array Element)));
		Wait(1, Restart When True);
		Loop If Condition Is True;
	}
}

rule("OBJECTIVE COMPLETE")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Global.objectiveComplete == True;
	}

	actions
	{
		Start Rule(objectivesManagement, Restart Rule);
	}
}

rule("objectivesManagement")
{
	event
	{
		Subroutine;
		objectivesManagement;
	}

	actions
	{
		If(Global.gameStatus);
			Global.playersOnObjective = Empty Array;
			Global.objectiveCaptureValue = 0;
			"Checks if current objective is capture point"
			If(First Of(Global.objectiveTypes) == 1);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), First Of(Global.objectivePositions), Global.objectiveRad * 2);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange), First Of(Global.objectivePositions), 200);
				Big Message(All Players(All Teams), Custom String("Objective Captured!"));
			"Checks if current objective is eliminations"
			Else If(First Of(Global.objectiveTypes) == 2);
				Big Message(All Players(All Teams), Custom String("Zombie wave defeated!"));
			"Checks if current objective is bosses"
			Else If(First Of(Global.objectiveTypes) == 3);
				Big Message(All Players(All Teams), Custom String("Giant zombie eliminated!"));
			"Checks if current objective is resource collection"
			Else If(First Of(Global.objectiveTypes) == 4);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Green), First Of(Global.objectivePositions), Global.objectiveRad);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Green), First Of(Global.objectivePositions), 200);
				Big Message(All Players(All Teams), Custom String("Sufficient resources collected!"));
			"Checks if current objective is survivor rescue"
			Else If(First Of(Global.objectiveTypes) == 5);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Violet), First Of(Global.objectivePositions), Global.objectiveRad);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Violet), First Of(Global.objectivePositions), 200);
				Big Message(All Players(All Teams), Custom String("The survivors have been rescued!"));
			"Checks if current objective is kill zone"
			Else If(First Of(Global.objectiveTypes) == 6);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Red), Global.objectiveChase1, 200);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Red), Global.objectiveChase1, Global.objectiveRad * 2);
				Big Message(All Players(All Teams), Custom String("The kill zone has been cleared!"));
			"Checks if current objective is Zombie Egg"
			Else If(First Of(Global.objectiveTypes) == 7);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), First Of(Global.objectivePositions), 200);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Lime Green), First Of(Global.objectivePositions),
					Global.objectiveRad * 2);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), First Of(Global.objectivePositions), 3);
				Big Message(All Players(All Teams), Custom String("The egg has been destroyed!"));
			"Checks if current objective is Satellite Uplink"
			Else If(First Of(Global.objectiveTypes) == 8);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), First Of(Global.objectivePositions), 200);
				Big Message(All Players(All Teams), Custom String("Firing sequence complete!"));
			"Checks if current objective is Graveyard"
			Else If(First Of(Global.objectiveTypes) == 9);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Turquoise), Global.objectiveChase1, 200);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Turquoise), Global.objectiveChase1, Global.objectiveRad * 2);
				Big Message(All Players(All Teams), Custom String("All graves have been destroyed!"));
			End;
			Wait(0.016, Ignore Condition);
			"Checks if current objective type is elimination only"
			If(Global.objectiveTypeSetting != 2);
				Modify Global Variable(objectivePositions, Remove From Array By Index, 0);
				Modify Global Variable(objectiveTypes, Remove From Array By Index, 0);
				Global.bosses = Empty Array;
				Global.survivorToRescue = Null;
			"Skips to extraction if mode is elimination only"
			Else;
				Global.objectivePositions = Array(Last Of(Global.objectivePositions));
				Global.objectiveTypes = Array(Last Of(Global.objectiveTypes));
			End;
		End;
		Wait(0.250, Ignore Condition);
		If(Count Of(Global.objectivePositions) == 1);
			Global.playersOnObjective = Empty Array;
			Global.objectiveDescription = Custom String("Proceed to the extraction point");
			"Shrink extraction zone radius down to size of extraction point"
			Chase Global Variable Over Time(extractionZoneRad, 0, 120, Destination and Duration);
			Global.objectiveRad = 10;
			Big Message(All Players(All Teams), Custom String("Get to the extraction point!"));
		Else;
			If(First Of(Global.objectiveTypes) == 1);
				Global.objectiveDescription = Custom String("Secure the capture point");
				Global.objectiveCaptureValue = 0;
				Global.objectiveRad = 10;
				If(Count Of(Global.objectivePositions) > 2);
					Big Message(All Players(All Teams), Custom String("Proceed to the next objective!"));
				Else If(Count Of(Global.objectivePositions) > 1);
					Big Message(All Players(All Teams), Custom String("Proceed to the last objective!"));
				End;
			Else If(First Of(Global.objectiveTypes) == 2);
				Global.objectiveDescription = Custom String("Eliminate zombies");
				Global.objectiveCaptureValue = 0;
				Global.eliminationsNeededPerObjective = 40;
				Big Message(All Players(All Teams), Custom String("Eliminate {0} zombies!",
					Global.objectiveTypeSetting != 2 ? Global.eliminationsNeededPerObjective : Global.eliminationsNeededPerObjective * (Count Of(
					Global.objectivePositions) - 1)));
			Else If(First Of(Global.objectiveTypes) == 3);
				Global.objectiveDescription = Custom String("Eliminate the boss");
				If(Count Of(Global.objectivePositions) > 2);
					Big Message(All Players(All Teams), Custom String("Eliminate the giant zombie!"));
				Else;
					Big Message(All Players(All Teams), Custom String("Eliminate the final giant zombie!"));
				End;
			Else If(First Of(Global.objectiveTypes) == 4);
				Global.objectiveDescription = Custom String("Collect resources");
				Global.objectiveCaptureValue = 0;
				Global.objectiveResourcePositions = Empty Array;
				All Players(Team 1).playerObjectiveResourceValue = 0;
				Global.objectiveRad = 5;
				Big Message(All Players(All Teams), Custom String("Collect resources and bring them to the collection site!"));
			Else If(First Of(Global.objectiveTypes) == 5);
				Global.objectiveDescription = Custom String("Rescue survivors");
				Global.survivorToRescue = Null;
				Global.objectiveRad = 10;
				Global.objectiveChase1 = Global.objectiveRad;
				Big Message(All Players(All Teams), Custom String("Locate survivors and bring them to the extraction site!"));
			Else If(First Of(Global.objectiveTypes) == 6);
				Global.objectiveDescription = Custom String("Clear the kill zone");
				Global.objectiveRad = 20;
				Global.eliminationsNeededPerObjective = 50;
				Global.objectiveChase1 = First Of(Global.objectivePositions);
				Big Message(All Players(All Teams), Custom String("Get to the{0} kill zone and clear zombies!", Count Of(Global.objectivePositions)
					== 2 ? Custom String(" final") : Custom String("")));
				Global.objectiveCaptureValue = 0;
			Else If(First Of(Global.objectiveTypes) == 7);
				Global.objectiveDescription = Custom String("Destroy the egg");
				Global.objectiveRad = 0;
				Big Message(All Players(All Teams), Custom String("Destroy the{0} zombie egg!", Count Of(Global.objectivePositions)
					== 2 ? Custom String(" final") : Custom String("")));
			Else If(First Of(Global.objectiveTypes) == 8);
				Global.objectiveDescription = Custom String("Repair satellite control terminals");
				Global.objectiveRad = 3;
				Global.objectiveColor = Custom Color(28, 169, 201, 255);
				Global.objectiveResourcePositions = Empty Array;
				Global.objectiveCaptureValue = Array(0, 0, 0);
				"Initial terminal spacing"
				Global.testPos2 = 50;
				Big Message(All Players(All Teams), Custom String("Repair the{0} satellite control terminals!", Count Of(Global.objectivePositions)
					== 2 ? Custom String(" final") : Custom String("")));
			Else If(First Of(Global.objectiveTypes) == 9);
				Global.objectiveDescription = Custom String("Destroy the graves");
				Global.objectiveRad = 15;
				Global.objectiveColor = Color(Turquoise);
				"All Grave Locations"
				Global.objectiveCaptureValue = Empty Array;
				"Number of graves"
				While(Count Of(Global.objectiveCaptureValue) < 30);
					Global.objectiveRad += 2;
					"All Grave Locations"
					Global.objectiveCaptureValue = Filtered Array(Global.mapGrid, Distance Between(First Of(Global.objectivePositions),
						Current Array Element) < Global.objectiveRad - 10);
					Wait(0.016, Ignore Condition);
				End;
				Global.objectiveCaptureValue = Filtered Array(Global.objectiveCaptureValue, Current Array Index < 30);
				"Active Grave Locations"
				Global.objectiveResourcePositions = Empty Array;
				"Max number of active graves "
				Global.survivorToRescue = 2;
				Big Message(All Players(All Teams), Custom String("Clear out the{0} graveyard!", Count Of(Global.objectivePositions)
					== 2 ? Custom String(" final") : Custom String("")));
			End;
		End;
		"Updates global objective entities"
		Call Subroutine(globalObjectiveEntityManagement);
		Global.objectiveComplete = False;
	}
}

rule("globalObjectiveEntityManagement")
{
	event
	{
		Subroutine;
		globalObjectiveEntityManagement;
	}

	actions
	{
		Global.objectiveValue = First Of(Global.objectiveTypes);
		"Destroy all current objective effects and texts"
		For Global Variable(objectiveEntityCount, 0, Count Of(Global.objectiveEntities), 1);
			Destroy Progress Bar HUD Text(Global.objectiveEntities[Global.objectiveEntityCount]);
			Destroy Progress Bar In-World Text(Global.objectiveEntities[Global.objectiveEntityCount]);
			Destroy Effect(Global.objectiveEntities[Global.objectiveEntityCount]);
			Destroy HUD Text(Global.objectiveEntities[Global.objectiveEntityCount]);
			Destroy Icon(Global.objectiveEntities[Global.objectiveEntityCount]);
			Destroy In-World Text(Global.objectiveEntities[Global.objectiveEntityCount]);
			Wait(0.016, Ignore Condition);
		End;
		Global.objectiveEntities = Empty Array;
		"Capture Point/Extraction Point"
		If(Global.objectiveValue == 1);
			"Extraction Point"
			If(Count Of(Global.objectivePositions) == 1);
				"Outside dome visual sphere"
				Create Effect(Filtered Array(All Players(Team 1), !Array Contains(Global.playersOnObjective, Current Array Element)
					&& Distance Between(Position Of(Current Array Element), First Of(Global.objectivePositions)) > Global.extractionZoneRad - 2),
					Sphere, Color(Lime Green), Local Player, Distance Between(Position Of(Local Player), Eye Position(Local Player)) * 0.950,
					Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Extraction zone noise"
				Create Effect(All Living Players(Team 1), Pick-up Sound, Color(White), Distance Between(First Of(Global.objectivePositions),
					Position Of(Local Player)) < Global.extractionZoneRad ? First Of(Global.objectivePositions) + Direction Towards(First Of(
					Global.objectivePositions), Position Of(Local Player)) * Global.extractionZoneRad : Position Of(Local Player), 200,
					Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Extraction distance"
				Create In-World Text(Remove From Array(All Players(All Teams), Global.playersOnObjective), Custom String("Distance: {0}m",
					Distance Between(First Of(Global.objectivePositions), Y Component Of(First Of(Global.objectivePositions)) - Y Component Of(
					Eye Position(Local Player)) < 2 ? Vector(X Component Of(Position Of(Local Player)), Y Component Of(First Of(
					Global.objectivePositions)), Z Component Of(Position Of(Local Player))) : Position Of(Local Player))), First Of(
					Global.objectivePositions), 1, Do Not Clip, Visible To and String, Color(Sky Blue), Visible Never);
				Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
				"Extraction point boundary 1"
				Create Effect(All Players(All Teams), Light Shaft, Color(Sky Blue), First Of(Global.objectivePositions) + Vector(0, -2, 0),
					Global.objectiveRad, Visible To);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Extraction point boundary 2"
				Create Effect(All Players(All Teams), Light Shaft, Color(Sky Blue), First Of(Global.objectivePositions) + Vector(0, 22, 0),
					Global.objectiveRad, Visible To);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Extraction point boundary 3"
				Create Effect(All Players(All Teams), Light Shaft, Color(Sky Blue), First Of(Global.objectivePositions) + Vector(0, 46, 0),
					Global.objectiveRad, Visible To);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Extraction zone dome"
				Create Effect(Filtered Array(All Living Players(Team 1), Global.extractionZoneRad < 200 && Distance Between(First Of(
					Global.objectivePositions), Position Of(Current Array Element)) > Global.extractionZoneRad - 50), Sphere, Color(Lime Green),
					First Of(Global.objectivePositions), Global.extractionZoneRad, Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Extraction icon"
				Create Icon(Remove From Array(All Players(All Teams), Global.playersOnObjective), First Of(Global.objectivePositions) + Vector(0,
					1, 0), Arrow: Down, Visible To, Color(Sky Blue), True);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Extraction text"
				Create In-World Text(Remove From Array(All Players(All Teams), Global.playersOnObjective), Custom String(
					"GET TO THE EXTRACTION POINT"), First Of(Global.objectivePositions) + Vector(0, 5, 0), 3, Do Not Clip,
					Visible To Position and String, Color(Sky Blue), Default Visibility);
				Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Capture Point"
			Else;
				"Objective distance"
				Create In-World Text(Remove From Array(All Players(All Teams), Global.playersOnObjective), Custom String("Distance: {0}m",
					Distance Between(Position Of(Local Player), First Of(Global.objectivePositions))), First Of(Global.objectivePositions), 1,
					Do Not Clip, Visible To and String, Color(Orange), Visible Never);
				Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
				"Objective boundary (Ring)"
				Create Effect(Global.playersOnObjective, Ring, Color(Orange), First Of(Global.objectivePositions) + Vector(0, -1, 0),
					Global.objectiveRad, Visible To);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Objective boundary (Light Shaft)"
				Create Effect(Global.playersOnObjective, Light Shaft, Color(Orange), First Of(Global.objectivePositions) + Vector(0, -30, 0),
					Global.objectiveRad, Visible To);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Objective beacon"
				Create Effect(Filtered Array(All Players(All Teams), Count Of(Global.playersOnObjective) > 0), Light Shaft, Color(Orange),
					First Of(Global.objectivePositions) + Vector(0, -2, 0), Global.objectiveRad / 20, Visible To);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Objective icon"
				Create Icon(Remove From Array(All Players(All Teams), Global.playersOnObjective), First Of(Global.objectivePositions) + Vector(0,
					1, 0), Arrow: Down, Visible To, Color(Orange), True);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Capture percentage text"
				Create In-World Text(Global.playersOnObjective, Custom String("CAPTURE PERCENTAGE: {0}%", Round To Integer(
					Global.objectiveCaptureValue, Down)), First Of(Global.objectivePositions) + Vector(0, 1, 0), 2, Do Not Clip,
					Visible To and String, Color(Orange), Default Visibility);
				Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
				"Capture percentage hud text"
				Create HUD Text(All Players(All Teams), Custom String("Capture Percentage: {0}%", Round To Integer(Global.objectiveCaptureValue,
					Down)), Custom String("Objectives remaining: {0}", Count Of(Global.objectivePositions) - 1), Count Of(
					Global.playersOnObjective) > 0 ? Count Of(Global.playersOnObjective) : Custom String(""), Top, 1, Color(Orange), Color(Orange),
					Color(Orange), Visible To and String, Default Visibility);
				Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			End;
		"Eliminations"
		Else If(Global.objectiveValue == 2);
			"Elimination Progress Bar"
			Create Progress Bar HUD Text(All Players(All Teams), Global.objectiveCaptureValue / (
				Global.objectiveTypeSetting != 2 ? Global.eliminationsNeededPerObjective : Global.eliminationsNeededPerObjective * (Count Of(
				Global.objectivePositions) - 1)) * 100, Custom String("Zombie Elimination Progress"), Top, 2, Custom Color(3, 98, 252, 255),
				Custom Color(3, 98, 252, 255), Visible To and Values, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Elimination Hud Text"
			Create HUD Text(All Players(All Teams), Null, Global.objectiveTypeSetting != 2 ? Custom String("Objectives Remaining: {0}",
				Count Of(Global.objectivePositions) - 1) : Custom String(""), Null, Top, 1, Color(Blue), Color(Blue), Color(Blue), Visible To,
				Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
		"Bosses"
		Else If(Global.objectiveValue == 3);
			"Boss health progress bar"
			Create Progress Bar HUD Text(Filtered Array(All Players(All Teams), Count Of(Global.bosses) > 0), Normalized Health(First Of(
				Global.bosses)) * 100, Custom String("Boss Health {0}", Hero Icon String(Hero Of(First Of(Global.bosses)))), Top, 2, Color(
				Red), Color(Red), Visible To Values and Color, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objectives remaining hud text"
			Create HUD Text(All Players(All Teams), Null, Global.objectiveTypeSetting != 3 ? Custom String("Objectives Remaining: {0}",
				Count Of(Global.objectivePositions) - 1) : Custom String("Giant Zombies Remaining: {0}", Count Of(Global.objectivePositions)
				- 1), Null, Top, 1, Color(Red), Color(Red), Color(Red), Visible To, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Boss icon"
			Create Icon(All Players(All Teams), Count Of(Global.bosses) > 0 ? First Of(Global.bosses) : First Of(Global.objectivePositions)
				+ Vector(0, 1, 0), Skull, Visible To and Position, Color(Red), True);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Boss Distance"
			Create In-World Text(Filtered Array(All Players(All Teams), Count Of(Global.bosses) == 0 || !Array Contains(First Of(Global.bosses)
				.potentialTargets, Current Array Element)), Custom String("Distance: {0}m", Count Of(Global.bosses) > 0 ? Distance Between(
				Position Of(Local Player), Position Of(First Of(Global.bosses))) : Distance Between(Position Of(Local Player), First Of(
				Global.objectivePositions))), Count Of(Global.bosses) > 0 ? Position Of(First Of(Global.bosses)) : First Of(
				Global.objectivePositions), 1, Do Not Clip, Visible To Position and String, Color(Red), Visible Never);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
		"Resource Collection"
		Else If(Global.objectiveValue == 4);
			"Objectives remaining text"
			Create HUD Text(All Players(Team 1), Null, Custom String("Objectives Remaining: {0}", Count Of(Global.objectivePositions) - 1),
				Null, Top, 1, Color(Green), Color(Green), Color(Green), Visible To, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Global resource progress bar"
			Create Progress Bar HUD Text(All Players(All Teams), Global.objectiveCaptureValue, Custom String("Resource Collection Progress"),
				Top, 2, Color(Green), Color(Green), Visible To and Values, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Collection site icon"
			Create Icon(Filtered Array(All Players(Team 1), Current Array Element.playerObjectiveResourceValue > 0 && !Array Contains(
				Global.playersOnObjective, Current Array Element)), First Of(Global.objectivePositions) + Vector(0, 1, 0), Arrow: Down,
				Visible To, Color(Green), True);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Collection site ring"
			Create Effect(All Players(Team 1), Ring, Color(Green), First Of(Global.objectivePositions) + Vector(0, -1, 0), Global.objectiveRad,
				Visible To);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Resource collection site boundary (Light Shaft)"
			Create Effect(Global.playersOnObjective, Light Shaft, Color(Green), First Of(Global.objectivePositions) + Vector(0, -2, 0),
				Global.objectiveRad, Visible To);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Generate resource icons and orbs"
			For Global Variable(objectiveEntityCount, 0, 3, 1);
				"Resource icon"
				Create Icon(Filtered Array(All Players(Team 1), Current Array Element.playerObjectiveResourceValue <= 0 && Count Of(
					Global.objectiveResourcePositions) > Evaluate Once(Global.objectiveEntityCount)),
					Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)] + Vector(0, 1, 0), Plus, Visible To and Position,
					Color(Green), True);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Resource orb 0"
				Create Effect(Filtered Array(All Players(Team 1), Current Array Element.playerObjectiveResourceValue <= 0 && Count Of(
					Global.objectiveResourcePositions) > Evaluate Once(Global.objectiveEntityCount)), Orb, Color(Green),
					Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)], 1, Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			End;
			"Depositing resources progress bar"
			Create Progress Bar In-World Text(Filtered Array(Local Player, Array Contains(Global.playersOnObjective, Current Array Element)),
				Local Player.playerObjectiveResourceValue / Global.amountPerResource * 100, Custom String("Depositing Resources..."),
				Array Contains(Global.playersOnObjective, Local Player) ? Update Every Frame(Eye Position(Local Player)
				+ Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(
				Facing Direction Of(Local Player)) + 15)) : Evaluate Once(Position Of(Local Player)), 1, Do Not Clip, Color(Green), Color(
				Green), Visible To Position and Values, Visible Never);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Collection site distance (or closest resource distance)"
			Create In-World Text(Filtered Array(Local Player, !Array Contains(Global.playersOnObjective, Current Array Element) && (
				Local Player.playerObjectiveResourceValue > 0 || Count Of(Global.objectiveResourcePositions) > 0)), Custom String(
				"Distance: {0}m", Distance Between(Local Player.playerObjectiveResourceValue > 0 ? First Of(Global.objectivePositions)
				: First Of(Sorted Array(Global.objectiveResourcePositions, Angle Between Vectors(Direction Towards(Eye Position(Local Player),
				Current Array Element), Facing Direction Of(Local Player)))), Position Of(Local Player))),
				Local Player.playerObjectiveResourceValue > 0 ? First Of(Global.objectivePositions) : First Of(Sorted Array(
				Global.objectiveResourcePositions, Angle Between Vectors(Direction Towards(Eye Position(Local Player), Current Array Element),
				Facing Direction Of(Local Player)))), 1, Do Not Clip, Visible To Position and String, Color(Green), Visible Never);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
		"Survivor Rescue"
		Else If(Global.objectiveValue == 5);
			"Extraction site light shaft 2"
			Create Effect(All Players(All Teams), Light Shaft, Color(Violet), First Of(Global.objectivePositions) + Vector(0, -2, 0), 5,
				Visible To);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Objectives remaining text"
			Create HUD Text(All Players(Team 1), Null, Custom String("Objectives Remaining: {0}", Count Of(Global.objectivePositions) - 1),
				Null, Top, 1, Color(Violet), Color(Violet), Color(Violet), Visible To, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objective icon"
			Create Icon(Filtered Array(All Players(All Teams), Distance Between(Position Of(Current Array Element), Position Of(First Of(
				Global.survivorToRescue))) < Global.objectiveRad && Distance Between(Position Of(Current Array Element), First Of(
				Global.objectivePositions)) > 5), First Of(Global.objectivePositions) + Vector(0, 1, 0), Arrow: Down, Visible To and Position,
				Color(Violet), True);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		"Killzone"
		Else If(Global.objectiveValue == 6);
			"Kill Zone Progress Bar"
			Create Progress Bar HUD Text(All Players(All Teams), Global.objectiveCaptureValue / Global.eliminationsNeededPerObjective * 100,
				Custom String("Kill Zone Elimination Progress"), Top, 2, Color(Red), Color(Red), Visible To and Values, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objectives Remaining Hud Text"
			Create HUD Text(All Players(All Teams), Null, Custom String("Objectives Remaining: {0}", Count Of(Global.objectivePositions) - 1),
				Null, Top, 1, Color(Red), Color(Red), Color(Red), Visible To, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objective distance"
			Create In-World Text(Filtered Array(All Players(All Teams), Distance Between(Position Of(Current Array Element),
				Global.objectiveChase1) > Global.objectiveRad), Custom String("Distance: {0}m", Distance Between(Position Of(Local Player),
				Global.objectiveChase1) - Global.objectiveRad), Global.objectiveChase1, 1, Do Not Clip, Visible To Position and String, Color(
				Red), Visible Never);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objective icon"
			Create Icon(Filtered Array(All Players(All Teams), Distance Between(Position Of(Current Array Element), Global.objectiveChase1)
				> Global.objectiveRad), Global.objectiveChase1 + Vector(0, 1, 0), Arrow: Down, Visible To and Position, Color(Red), True);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Kill Zone Sphere"
			Create Effect(Filtered Array(All Players(All Teams), Distance Between(Position Of(Current Array Element), Global.objectiveChase1)
				> Global.objectiveRad), Sphere, Color(Red), Global.objectiveChase1, Global.objectiveRad, Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Kill Zone Ring"
			Create Effect(Filtered Array(All Players(All Teams), Distance Between(Position Of(Current Array Element), Global.objectiveChase1)
				< Global.objectiveRad), Ring, Color(Red), Vector(X Component Of(Global.objectiveChase1), Y Component Of(Position Of(
				Local Player)), Z Component Of(Global.objectiveChase1)), Square Root(Global.objectiveRad ^ 2 - Absolute Value(Y Component Of(
				Position Of(Local Player)) - Y Component Of(Global.objectiveChase1)) ^ 2), Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Kill Zone light shaft"
			Create Effect(Filtered Array(All Players(All Teams), Distance Between(Position Of(Current Array Element), Global.objectiveChase1)
				< Global.objectiveRad), Light Shaft, Color(Red), Vector(X Component Of(Global.objectiveChase1), Y Component Of(Position Of(
				Local Player)) + -29, Z Component Of(Global.objectiveChase1)), Square Root(Global.objectiveRad ^ 2 - Absolute Value(
				Y Component Of(Position Of(Local Player)) - Y Component Of(Global.objectiveChase1)) ^ 2), Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		"Zombie Egg"
		Else If(Global.objectiveValue == 7);
			"Zombie Egg Progress Bar"
			Create Progress Bar HUD Text(Filtered Array(All Players(All Teams), First Of(Global.bosses) != Null), Normalized Health(First Of(
				Global.bosses)) * 100, Custom String("Zombie Egg Health"), Top, 2, Color(Lime Green), Color(Lime Green),
				Visible To Values and Color, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objectives Remaining Hud Text"
			Create HUD Text(All Players(All Teams), Null, Custom String("Objectives Remaining: {0}", Count Of(Global.objectivePositions) - 1),
				Null, Top, 1, Color(Lime Green), Color(Lime Green), Color(Lime Green), Visible To, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objective distance"
			Create In-World Text(All Players(All Teams), Custom String("Destroy: {0}m", Distance Between(Position Of(Local Player), First Of(
				Global.objectivePositions))), First Of(Global.objectivePositions), 1, Do Not Clip, Visible To and String, Color(Lime Green),
				Visible Never);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objective icon"
			Create Icon(All Players(All Teams), First Of(Global.objectivePositions) + Vector(0, 1, 0), Radioactive, Visible To, Color(
				Lime Green), True);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Egg visual"
			Create Effect(Filtered Array(All Players(All Teams), First Of(Global.bosses) != Null), Sphere, Color(Lime Green), First Of(
				Global.objectivePositions), 2.500 + Absolute Value(0.500 * Sine From Radians(0.500 * Total Time Elapsed)),
				Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Egg toxic gas visual (stationary)"
			Create Effect(Filtered Array(All Players(All Teams), First Of(Global.bosses) != Null), Cloud, Color(Lime Green), First Of(
				Global.objectivePositions) + Vector(0, -1, 0), 25 * (1 - Normalized Health(First Of(Global.bosses))),
				Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		"Satellite Uplink"
		Else If(Global.objectiveValue == 8);
			"Capture percentage hud text"
			Create HUD Text(All Players(All Teams), Custom String("{0}% | {1}% | {2}%", Round To Integer(First Of(
				Global.objectiveCaptureValue), Down), Round To Integer(Global.objectiveCaptureValue[1], Down), Round To Integer(
				Global.objectiveCaptureValue[2], Down)), Custom String("Objectives remaining: {0}", Count Of(Global.objectivePositions) - 1),
				Custom String(" "), Top, 1, Global.objectiveColor, Global.objectiveColor, Global.objectiveColor, Visible To and String,
				Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Fixing terminal light shaft"
			Create Effect(Global.playersOnObjective, Light Shaft, Global.objectiveColor, First Of(Sorted Array(
				Global.objectiveResourcePositions, Distance Between(Position Of(Local Player), Current Array Element))) + Vector(0, -2, 0),
				Global.objectiveRad, Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Current terminal repair percentage"
			Create In-World Text(Global.playersOnObjective, Custom String("{0}%", Round To Integer(
				Global.objectiveCaptureValue[Index Of Array Value(Global.objectiveResourcePositions, First Of(Sorted Array(
				Global.objectiveResourcePositions, Distance Between(Position Of(Local Player), Current Array Element))))], Down)),
				Update Every Frame(Eye Position(Local Player) + Direction From Angles(Horizontal Facing Angle Of(Local Player),
				Vertical Facing Angle Of(Local Player) + 15) * 200), 2, Do Not Clip, Visible To Position and String, Global.objectiveColor,
				Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Terminal effects"
			For Global Variable(objectiveEntityCount, 0, Count Of(Global.objectiveCaptureValue), 1);
				"Terminal icon"
				Create Icon(Filtered Array(All Players(Team 1), Distance Between(Position Of(Current Array Element),
					Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)])
					> Global.objectiveRad && Global.objectiveCaptureValue[Evaluate Once(Global.objectiveEntityCount)] < 100),
					Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)] + Vector(0, 1, 0), Bolt, Visible To and Position,
					Global.objectiveColor, True);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Terminal repair area ring"
				Create Effect(All Players(All Teams), Ring, Global.objectiveColor, Global.objectiveResourcePositions[Evaluate Once(
					Global.objectiveEntityCount)], Global.objectiveRad, Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Terminal \"screen\" light shaft"
				Create Effect(All Players(All Teams), Light Shaft, Global.objectiveColor, Global.objectiveResourcePositions[Evaluate Once(
					Global.objectiveEntityCount)] + Direction Towards(Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)
					], First Of(Global.objectivePositions)) * Global.objectiveRad * 0.800 + Vector(0, -1.500, 0), 0.250,
					Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Objective distance"
				Create In-World Text(Filtered Array(All Players(All Teams), Global.objectiveCaptureValue[Evaluate Once(Global.objectiveEntityCount)
					] < 100 && Distance Between(Position Of(Current Array Element), Global.objectiveResourcePositions[Evaluate Once(
					Global.objectiveEntityCount)]) > Global.objectiveRad), Custom String("Distance: {0}m", Distance Between(Position Of(
					Local Player), Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)])),
					Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)], 1, Do Not Clip, Visible To Position and String,
					Global.objectiveColor, Visible Never);
				Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			End;
		"Graveyard"
		Else If(Global.objectiveValue == 9);
			"Graves remaining HUD text"
			Create HUD Text(All Players(All Teams), Custom String("Graves Remaining: {0}", Count Of(Global.objectiveCaptureValue)),
				Custom String("Objectives remaining: {0}", Count Of(Global.objectivePositions) - 1), Custom String(" "), Top, 1,
				Global.objectiveColor, Global.objectiveColor, Global.objectiveColor, Visible To and String, Default Visibility);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objective distance"
			Create In-World Text(Filtered Array(All Players(Team 1), Distance Between(First Of(Global.objectivePositions), Position Of(
				Current Array Element)) > Global.objectiveRad), Custom String("Distance: {0}m", Distance Between(Position Of(Local Player),
				First Of(Global.objectivePositions)) - Global.objectiveRad), First Of(Global.objectivePositions), 1, Do Not Clip,
				Visible To and String, Global.objectiveColor, Visible Never);
			Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
			"Objective icon"
			Create Icon(Filtered Array(All Players(Team 1), Distance Between(First Of(Global.objectivePositions), Position Of(
				Current Array Element)) > Global.objectiveRad), First Of(Global.objectivePositions) + Vector(0, 1, 0), Arrow: Down, Visible To,
				Global.objectiveColor, True);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Bad Aura Ambiance"
			Create Effect(Filtered Array(All Players(Team 1), Distance Between(First Of(Global.objectivePositions), Position Of(
				Current Array Element)) < Global.objectiveRad), Bad Aura, Global.objectiveColor, Update Every Frame(Eye Position(Local Player)
				+ Facing Direction Of(Local Player) * 30), 50, Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Bad Aura Ambiance"
			Create Effect(Filtered Array(All Players(Team 1), Distance Between(First Of(Global.objectivePositions), Position Of(
				Current Array Element)) < Global.objectiveRad), Bad Aura, Global.objectiveColor, Update Every Frame(Eye Position(Local Player)
				+ Facing Direction Of(Local Player) * 31), 50, Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Bad Aura Ambiance"
			Create Effect(Filtered Array(All Players(Team 1), Distance Between(First Of(Global.objectivePositions), Position Of(
				Current Array Element)) < Global.objectiveRad), Bad Aura, Global.objectiveColor, Update Every Frame(Eye Position(Local Player)
				+ Facing Direction Of(Local Player) * 32), 50, Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			"Grave effects"
			For Global Variable(objectiveEntityCount, 0, Global.survivorToRescue, 1);
				"Grave ring"
				Create Effect(Filtered Array(All Players(All Teams), Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)
					]), Ring, Global.objectiveColor, Global.objectiveCaptureValue[Evaluate Once(Global.objectiveEntityCount)], 1,
					Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Grave cloud"
				Create Effect(All Players(All Teams), Cloud, Global.objectiveColor, Global.objectiveCaptureValue[Evaluate Once(
					Global.objectiveEntityCount)], 2, Visible To Position and Radius);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
				"Grave zombie icon"
				Create Icon(Filtered Array(All Players(All Teams), Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)]),
					Global.objectiveResourcePositions[Evaluate Once(Global.objectiveEntityCount)], Skull, Visible To and Position,
					Global.objectiveColor, True);
				Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
			End;
		End;
	}
}

rule("nukeMap")
{
	event
	{
		Subroutine;
		nukeMap;
	}

	actions
	{
		Set Match Time(60);
		Unpause Match Time;
		Stop Chasing Global Variable(chase1);
		Global.chase1 = Global.walkCenter + Direction From Angles(Random Integer(0, 359), Random Real(-45, -60)) * 500;
		Wait(0.016, Ignore Condition);
		Chase Global Variable Over Time(chase1, Global.walkCenter, 5, Destination and Duration);
		While(Distance Between(Global.chase1, Global.walkCenter) > 1);
			Play Effect(All Players(All Teams), Good Explosion, Color(Sky Blue), Global.chase1, 3);
			Wait(0.016, Ignore Condition);
		End;
		For Global Variable(count2, 0, 400, 1);
			Play Effect(All Players(All Teams), Bad Explosion, Custom Color(255, Random Real(100, 255), 0, 255),
				Global.walkCenter + Direction From Angles(Random Real(0, 360), 0) * Random Integer(0, (Global.count2 / 20) ^ 2 + 1), (
				Global.count2 / 18) ^ 2);
			Wait(0.016, Ignore Condition);
		End;
	}
}

disabled rule("============================================== OBJECTIVE TYPE: EXTRACTION POINT =============================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYERS IN EXTRACTION POINT CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveComplete == False;
		Global.gameStatus == True;
		Has Spawned(Event Player) == True;
		First Of(Global.objectiveTypes) == 1;
		Count Of(Global.objectivePositions) == 1;
		Y Component Of(First Of(Global.objectivePositions)) - Y Component Of(Eye Position(Event Player)) < 2;
		Distance Between(Position Of(Event Player), Vector(X Component Of(First Of(Global.objectivePositions)), Y Component Of(Position Of(
			Event Player)), Z Component Of(First Of(Global.objectivePositions)))) < Global.objectiveRad;
	}

	actions
	{
		If(!Array Contains(Global.playersOnObjective, Event Player));
			Modify Global Variable(playersOnObjective, Append To Array, Event Player);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		If(Global.gameStatus);
			Modify Global Variable(playersOnObjective, Remove From Array By Value, Event Player);
	}
}

rule("EXTRACTION ZONE INFECTION INCREASE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Is Alive(Event Player) == True;
		Count Of(Global.objectivePositions) == 1;
		Global.extractionZoneRad < 200;
		Distance Between(First Of(Global.objectivePositions), Position Of(Event Player)) > Global.extractionZoneRad;
		Array Contains(Global.playersOnObjective, Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Event Player.infectionLvl += 1;
		If(!Event Player.infected && Event Player.infectionLvl >= 1);
			Event Player.infected = True;
		End;
		"Kick players out of the spawn room if dome is closing in."
		While(Is In Spawn Room(Event Player));
			Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player) + Direction Towards(Position Of(Event Player), First Of(
				Global.objectivePositions)) * 10));
			Wait(0.125, Ignore Condition);
		End;
		Loop;
	}
}

rule("WIN/LOSS CONDITIONS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveComplete == False;
		Global.gameStatus == True;
		((Count Of(Global.objectivePositions) == 1 && Count Of(Global.playersOnObjective) == Count Of(Filtered Array(All Players(Team 1),
			Has Spawned(Current Array Element) && Current Array Element.deathTimer > 0 && !Current Array Element.afk))) || (Count Of(
			Global.playerTargetList) == 0)) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.gameStatus = False;
		Enable Built-In Game Mode Announcer;
		Disable Nameplates(All Players(All Teams), All Players(All Teams));
		Disable Game Mode HUD(All Players(All Teams));
		Disable Kill Feed(All Players(All Teams));
		Disable Hero HUD(All Players(All Teams));
		Start Forcing Player Outlines(All Players(All Teams), All Players(All Teams), False, Color(White), Default);
		Destroy All Effects;
		Destroy All Icons;
		Destroy All In-World Text;
		Destroy All Progress Bar HUD Text;
		Destroy All Progress Bar In-World Text;
		Destroy All HUD Text;
		Set Status(All Players(Team 1), Null, Rooted, 9999);
		Set Status(All Players(Team 1), Null, Phased Out, 9999);
		If(Count Of(Global.playerTargetList) == 0);
			Teleport(All Players(Team 1), Vector(0, 500, 0));
			Set Invisible(All Players(All Teams), All);
			Wait(1, Ignore Condition);
			Resurrect(All Players(Team 1));
			Start Camera(All Players(Team 1), Global.walkCenter + Direction From Angles(Horizontal Facing Angle Of(Local Player)
				* -2 + Total Time Elapsed * -7.500, -30) * 200, Global.walkCenter, 10);
			Start Rule(nukeMap, Do Nothing);
			Wait(8, Ignore Condition);
			Declare Team Victory(Team 2);
			Set Team Score(Team 2, 9);
			Declare Round Victory(Team 2);
		Else;
			Resurrect(Filtered Array(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(First Of(
				Global.objectivePositions), Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(First Of(
				Global.objectivePositions)), Z Component Of(Position Of(Current Array Element)))) < Global.objectiveRad));
			Wait(0.016, Ignore Condition);
			Global.evacDestination = First Of(Global.objectivePositions) + Vector(0, 250, 0) + Direction From Angles(Random Real(0, 360), 0)
				* 500;
			Global.evacRate = 2;
			Global.evacuatingSurvivorList = Global.playersOnObjective;
			Wait(1, Ignore Condition);
			Global.evacRate = 10;
			Wait(5, Ignore Condition);
			Global.evacRate = 2;
			Wait(2, Ignore Condition);
			Start Rule(nukeMap, Do Nothing);
			Global.evacRate = 50;
			Wait(8, Ignore Condition);
			Declare Team Victory(Team 1);
			Set Team Score(Team 1, 9);
			Declare Round Victory(Team 1);
		End;
		Enable Hero HUD(All Players(All Teams));
		Enable Game Mode HUD(All Players(All Teams));
	}
}

disabled rule("============================================== OBJECTIVE TYPE: CAPTURE POINT ==================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYERS ON OBJECTIVE CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 1;
		Count Of(Global.objectivePositions) > 1;
		Event Player.invisible != True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		"Objective Cylinder Height"
		Absolute Value(Y Component Of(First Of(Global.objectivePositions)) - Y Component Of(Position Of(Event Player)))
			< Global.objectiveRad * 0.650;
		"Objective Cylinder Radius"
		Distance Between(Vector(X Component Of(First Of(Global.objectivePositions)), Y Component Of(Position Of(Event Player)),
			Z Component Of(First Of(Global.objectivePositions))), Position Of(Event Player)) < Global.objectiveRad;
		(Array Contains(Global.playersOnObjective, Event Player) || Is In Line of Sight(Eye Position(Event Player), First Of(
			Global.objectivePositions) + Vector(0, Max(0, Y Component Of(Eye Position(Event Player)) - Y Component Of(First Of(
			Global.objectivePositions))), 0) + Direction Towards(First Of(Global.objectivePositions), Eye Position(Event Player)) * Min(1,
			Distance Between(Eye Position(Event Player), First Of(Global.objectivePositions))), Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		If(!Array Contains(Global.playersOnObjective, Event Player));
			Modify Global Variable(playersOnObjective, Append To Array, Event Player);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Modify Global Variable(playersOnObjective, Remove From Array By Value, Event Player);
	}
}

rule("MODIFY OBJECTIVE CAPTURE PERCENTAGE")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 1;
		Count Of(Global.objectivePositions) > 1;
		Count Of(Global.playersOnObjective) > 0;
		Global.objectiveComplete == False;
	}

	actions
	{
		"Proceed to next objective"
		If(Global.objectiveCaptureValue >= 100);
			Global.objectiveComplete = True;
			Global.playersOnObjective = Empty Array;
			Abort If(Global.objectiveTypes[0] != 1);
		End;
		Wait(1, Restart When True);
		If(Count Of(Global.playersOnObjective) > 0);
			Global.objectiveCaptureValue += 0.550;
			If(Count Of(Global.playersOnObjective) > 1);
				Global.objectiveCaptureValue += 0.300;
				If(Count Of(Global.playersOnObjective) > 2);
					Global.objectiveCaptureValue += 0.150;
				End;
			End;
		End;
		Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), First Of(Global.objectivePositions), (
			0.050 * Global.objectiveCaptureValue) ^ 2);
		Loop If Condition Is True;
	}
}

disabled rule("============================================== OBJECTIVE TYPE: ELIMINATIONS ===================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("MODIFY ZOMBIE ELIMINATION SCORE")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 2;
		Global.objectiveComplete == False;
	}

	actions
	{
		Global.objectiveCaptureValue += 1;
		If(Global.objectiveCaptureValue >= (Global.objectiveTypeSetting == 2 ? Global.eliminationsNeededPerObjective * (Count Of(
			Global.objectivePositions) - 1) : Global.eliminationsNeededPerObjective));
			Global.objectiveComplete = True;
		End;
	}
}

disabled rule("============================================== OBJECTIVE TYPE: BOSSES ==================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("SPAWN BOSS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 3;
		Global.objectiveComplete == False;
		Count Of(Filtered Array(Global.bosses, Entity Exists(Current Array Element))) == 0;
		Is True For Any(All Living Players(Team 2), Has Spawned(Current Array Element)
			&& !Current Array Element.teleporting && !Current Array Element.successfullyTeleported) == True;
		"Keeps amount of different bots within the max limit."
		Count Of(Filtered Array(Global.botHeros, Number Of Heroes(Current Array Element, Team 2) > 0)) < Global.uniqueSkinCap - (
			Number Of Players(Team 1) <= Number Of Slots(Team 1) ? Number Of Slots(Team 1) : Number Of Players(Team 1));
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.bosses[0] = First Of(Filtered Array(All Living Players(Team 2), Has Spawned(Current Array Element)
			&& !Current Array Element.teleporting && !Current Array Element.successfullyTeleported));
		Teleport(Global.bosses, Vector(500, 500, 500));
		Wait Until(Global.bosses[0].initializing, 3);
		Wait Until(!Global.bosses[0].initializing, 5);
		Teleport(Global.bosses, First Of(Global.objectivePositions));
		While(Is True For Any(Global.bosses, Is Dead(Current Array Element)));
			Resurrect(Global.bosses);
			Wait Until(Is Alive(First Of(Global.bosses)), 0.250);
		End;
		Loop If(!Entity Exists(First Of(Global.bosses)));
		Loop If Condition Is True;
	}
}

rule("BOT BECOMES BOSS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 3;
		Global.objectiveComplete == False;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		If(Event Player.attached);
			Event Player.attached = False;
			Detach Players(Event Player);
		End;
		Set Invisible(Event Player, None);
		If(Count Of(Global.availableBosses) == 0);
			Global.availableBosses = Filtered Array(Global.botHeros, Global.botSpawnRates[Current Array Index] > 0);
			If(Count Of(Global.availableBosses) > Count Of(Global.nonBossZombies));
				Modify Global Variable(availableBosses, Remove From Array By Value, Global.nonBossZombies);
			End;
		End;
		Start Forcing Player To Be Hero(Event Player, Random Value In Array(Global.availableBosses));
		Call Subroutine(botRespawnInitialization);
		"Remove Current Boss Hero From Available Boss List"
		Modify Global Variable(availableBosses, Remove From Array By Value, Hero Of(Event Player));
		"Boss throttle speed"
		Event Player.botThrottleSpeed = 0.650;
		"Health pool size as boss"
		Event Player.health = 15000;
		Event Player.bossHealth = Event Player.health;
		Event Player.size = Workshop Setting Real(Custom String("Zombies"), Custom String("Boss Size"), 2.500, 0, 20, 0);
		Start Scaling Player(Event Player, Event Player.size, False);
		"Scale zombie voice lines with size"
		Start Modifying Hero Voice Lines(Event Player, 0.500 + 1 / (Event Player.size + 1), False);
		Stop All Damage Over Time(Event Player);
		Set Player Health(Event Player, Max Health(Event Player));
		Set Status(Event Player, Null, Rooted, 9999);
		Disable Movement Collision With Environment(Event Player, False);
		Event Player.wallCollisionEnabled = False;
		Event Player.potentialTargets = Empty Array;
		Wait Until(Is On Ground(Event Player), 1);
		Global.bosses[1] = Distance Between(Position Of(Event Player), Eye Position(Event Player));
		Wait Until(Event Player.botTarget == Null, 1);
		Wait(0.250, Ignore Condition);
		Wait Until(Event Player.botTarget != Null || Health(Event Player) < Event Player.health, 9999);
		Clear Status(Event Player, Rooted);
		Global.bosses[1] = Distance Between(Position Of(Event Player), Eye Position(Event Player));
		Wait(1, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
	}
}

rule("BOSS STUCK")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 3;
		Event Player.wallCollisionEnabled == True;
		Event Player.canWallPhase == True;
		Event Player.botTarget != Null;
		Is Crouching(Event Player) == False;
		Array Contains(Global.bosses, Event Player) == True;
		Distance Between(Position Of(Event Player), Eye Position(Event Player)) < Global.bosses[1] - 0.250;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.wallCollisionEnabled = False;
		Disable Movement Collision With Environment(Event Player, False);
		Wait(3, Ignore Condition);
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
		Loop If Condition Is True;
	}
}

rule("BOSS HEALTH CONTROL (ALL BOSS OBJECTIVES)")
{
	event
	{
		Player Took Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Damage > 1000;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		Event Player.bossHealth = Health(Event Player) + Event Damage - 1000;
		Set Player Health(Event Player, Event Player.bossHealth);
	}
}

rule("BOSS DIES (ALL BOSS OBJECTIVES)")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		If(Event Was Environment);
			Stop All Damage Over Time(Event Player);
			If(Team Of(Attacker) == Opposite Team Of(Team Of(Event Player)));
				Event Player.bossHealth = Event Damage - 200;
			Else;
				Event Player.bossHealth = Event Damage;
			End;
			If(Event Player.bossHealth > 0);
				While(Is Dead(Event Player));
					If(Y Component Of(Position Of(Event Player)) - Y Component Of(Nearest Walkable Position(Position Of(Event Player))) < -50);
						"Teleport boss if they fall very far below the map"
						Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player)));
					Else If(Y Component Of(Position Of(Event Player)) - Y Component Of(Nearest Walkable Position(Position Of(Event Player))) < -30);
						Apply Impulse(Event Player, Vector(0, 1, 0), 40, To World, Cancel Contrary Motion);
					Else If(Y Component Of(Position Of(Event Player)) - Y Component Of(Nearest Walkable Position(Position Of(Event Player))) < -15);
						Apply Impulse(Event Player, Vector(0, 1, 0), 32, To World, Cancel Contrary Motion);
					Else;
						Apply Impulse(Event Player, Vector(0, 1, 0), 25, To World, Cancel Contrary Motion);
					End;
					Wait(0.016, Restart When True);
					Resurrect(Event Player);
					Wait Until(Is Alive(Event Player), 5);
					Set Player Health(Event Player, Event Player.bossHealth);
					Disable Movement Collision With Environment(Event Player, True);
					Event Player.wallCollisionEnabled = False;
				End;
				If(Event Player.botTarget == Null);
					Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Nearest Walkable Position(Position Of(
						Event Player))), Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
				End;
				Wait Until(Is On Ground(Event Player) || Y Component Of(Nearest Walkable Position(Position Of(Event Player))) < Y Component Of(
					Position Of(Event Player)), 5);
				Enable Movement Collision With Environment(Event Player);
				Event Player.wallCollisionEnabled = True;
			Else;
				Global.objectiveComplete = True;
				Global.bosses[Index Of Array Value(Global.bosses, Event Player)] = 0;
				Event Player.reviveTimer = 10;
			End;
		"Resurrects player if event damage was greater than 1000 and their health still is higher than 0hp."
		Else If(Event Damage - 1000 > 0);
			Event Player.bossHealth = Event Damage - 1000;
			Resurrect(Event Player);
			Wait Until(Is Alive(Event Player), 5);
			Set Player Health(Event Player, Event Player.bossHealth);
		Else;
			Global.objectiveComplete = True;
			Global.bosses[Index Of Array Value(Global.bosses, Event Player)] = 0;
			Event Player.reviveTimer = 10;
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("BOSS TAKES KNOCKBACK")
{
	event
	{
		Player Received Knockback;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 3;
		Event Player.wallCollisionEnabled == False;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
	}
}

disabled rule("============================================== OBJECTIVE TYPE: RESOURCE COLLECTION =======================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("GENERATE RESOURCE POSITIONS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 4;
		Global.gameStatus == True;
		Global.objectiveComplete == False;
		(Count Of(Global.objectiveResourcePositions) + Count Of(Filtered Array(All Living Players(Team 1),
			Current Array Element.playerObjectiveResourceValue >= Global.amountPerResource)) < 3 || Global.objectiveCaptureValue >= 100)
			== True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		If(Global.objectiveCaptureValue < 100);
			If(Count Of(Global.objectiveResourcePositions) + Count Of(Filtered Array(All Living Players(Team 1),
				Current Array Element.playerObjectiveResourceValue >= Global.amountPerResource)) > 0);
				Wait(1, Ignore Condition);
			End;
			Modify Global Variable(objectiveResourcePositions, Append To Array, Random Value In Array(Filtered Array(Global.mapGrid,
				Distance Between(Current Array Element, First Of(Global.objectivePositions)) < 75 && Distance Between(Current Array Element,
				First Of(Global.objectivePositions)) > (Global.specialGameMode ? First Of(Global.objectiveSpacing) : 50))));
			Global.objectiveResourcePositions[Index Of Array Value(Global.objectiveResourcePositions, Last Of(
				Global.objectiveResourcePositions))] += Vector(0, 0.500, 0);
			Wait(0.250, Ignore Condition);
		Else;
			If(Count Of(Global.availablePowerups) > 0);
				For Global Variable(resourcePowerUpDropCount, 0, 4, 1);
					Modify Global Variable(powerUpIDs, Append To Array, Random Value In Array(Global.availablePowerups));
					Modify Global Variable(powerUpPositions, Append To Array, First Of(Global.objectivePositions) + Direction From Angles(
						90 * Global.resourcePowerUpDropCount, 0));
				End;
			End;
			Global.objectiveComplete = True;
		End;
		Loop If Condition Is True;
	}
}

rule("PLAYER PICKS UP RESOURCES")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 4;
		Global.gameStatus == True;
		Global.objectiveComplete == False;
		Event Player.playerObjectiveResourceValue <= 0;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Count Of(Global.objectiveResourcePositions) > 0;
		Is True For Any(Global.objectiveResourcePositions, Distance Between(Current Array Element, Position Of(Event Player))
			< 2 || Distance Between(Current Array Element, Eye Position(Event Player)) < 2) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Modify Global Variable(objectiveResourcePositions, Remove From Array By Value, First Of(Sorted Array(
			Global.objectiveResourcePositions, Distance Between(Position Of(Event Player), Current Array Element))));
		Event Player.playerObjectiveResourceValue = Global.amountPerResource;
		Small Message(Event Player, Custom String("Go to the collection site!"));
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Position Of(Event Player), 25);
		Play Effect(Event Player, Good Explosion, Color(Green), Position Of(Event Player), 2);
	}
}

rule("PLAYER DELIVERS RESOURCES")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 4;
		Event Player.invisible != True;
		Event Player.playerObjectiveResourceValue > 0;
		Is Alive(Event Player) == True;
		Distance Between(First Of(Global.objectivePositions), Position Of(Event Player)) < Global.objectiveRad;
	}

	actions
	{
		If(!Array Contains(Global.playersOnObjective, Event Player));
			Modify Global Variable(playersOnObjective, Append To Array, Event Player);
		End;
		Wait(0.125, Ignore Condition);
		"(Amount per resource / dump time) x tick speed"
		Event Player.playerObjectiveResourceValue -= Global.amountPerResource / 3 * 0.125;
		"(Amount per resource / dump time) x tick speed"
		Global.objectiveCaptureValue += Global.amountPerResource / 3 * 0.125;
		Loop If Condition Is True;
		If(Event Player.playerObjectiveResourceValue <= 0);
			Play Effect(Event Player, Buff Impact Sound, Color(White), Position Of(Event Player), 75);
			Play Effect(Event Player, Ring Explosion, Color(Green), Position Of(Event Player) + Vector(0, 0.250, 0), 8);
			Small Message(Event Player, Custom String("Resources deposited!"));
		End;
		Modify Global Variable(playersOnObjective, Remove From Array By Value, Event Player);
	}
}

rule("PLAYER DROPS RESOURCES (DEATH)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 4;
		Event Player.playerObjectiveResourceValue >= Global.amountPerResource;
		Is Dead(Event Player) == True;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Modify Global Variable(objectiveResourcePositions, Append To Array, Position Of(Event Player));
		Event Player.playerObjectiveResourceValue = 0;
	}
}

disabled rule("============================================== OBJECTIVE TYPE: SURVIVOR RESCUE =================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("SPAWN SURVIVOR TO BE RESCUED OR COMPLETE OBJECTIVE")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.gameStatus == True;
		Global.objectiveComplete == False;
		(Global.survivorToRescue == Null || !Entity Exists(Global.survivorToRescue)) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		If(Global.survivorToRescue == Null);
			Global.testPos = Null;
			Global.testPos2 = 115;
			While(Global.testPos == Null);
				Global.testPos = Random Value In Array(Filtered Array(Global.mapGrid, Distance Between(Current Array Element, First Of(
					Global.objectivePositions)) > Global.testPos2 && Distance Between(Current Array Element, First Of(Global.objectivePositions))
					< 120));
				Global.testPos2 -= 5;
				Wait(0.016, Ignore Condition);
			End;
			Create Dummy Bot(Random Value In Array(Filtered Array(All Heroes, Number Of Heroes(Current Array Element, Team 1) <= 0)), Team 1,
				20, Global.testPos, Vector(0, 0, 0));
			Global.survivorToRescue = Last Created Entity;
		Else;
			Global.survivorToRescue = Null;
			Global.objectiveComplete = True;
		End;
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("INITIALIZE SURVIVOR TO BE RESCUED")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.survivorToRescue == Event Player;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.detectionRadius1 = 5;
		Global.survivorToRescue.path = Empty Array;
		Global.survivorToRescue.startPos = Position Of(Global.survivorToRescue);
		Global.survivorToRescue.botTempValue = False;
		Event Player.botFollowTarget = Null;
		Event Player.movementSpeed = 1;
		Event Player.enhancementValues[0] = 9;
		Event Player.enhancementValues[1] = 0;
		Event Player.enhancementValues[2] = False;
		Set Status(Global.survivorToRescue, Null, Unkillable, 9999);
		"Objective/Survivor distance"
		Create In-World Text(Filtered Array(All Players(All Teams), !Event Player.botTempValue && Distance Between(Position Of(
			Local Player), First Of(Global.objectivePositions)) > 5), Custom String("Distance: {0}m", Distance Between(Position Of(
			Local Player), Distance Between(Position Of(Event Player), Position Of(Local Player)) > Global.objectiveRad ? Position Of(
			Event Player) : First Of(Global.objectivePositions))), Distance Between(Position Of(Event Player), Position Of(Local Player))
			> Global.objectiveRad ? Position Of(Event Player) : First Of(Global.objectivePositions), 1, Do Not Clip,
			Visible To Position and String, Color(Violet), Visible Never);
		"Survivor rescue progress bar"
		Create Progress Bar HUD Text(All Players(All Teams), Event Player.botTempValue ? 100 : (Distance Between(Vector(X Component Of(
			First Of(Global.objectivePositions)), Y Component Of(Event Player.startPos), Z Component Of(First Of(
			Global.objectivePositions))), Event Player.startPos) - Distance Between(Position Of(Event Player), Vector(X Component Of(
			First Of(Global.objectivePositions)), Y Component Of(Position Of(Event Player)), Z Component Of(First Of(
			Global.objectivePositions))))) / Distance Between(Vector(X Component Of(First Of(Global.objectivePositions)), Y Component Of(
			Event Player.startPos), Z Component Of(First Of(Global.objectivePositions))), Event Player.startPos) * 100, Custom String(
			"Survivor Rescue Progress"), Top, 2, Color(Violet), Color(Violet), Visible To and Values, Default Visibility);
		"Survivor icon"
		Create Icon(All Players(All Teams), Event Player, Halo, Visible To and Position, Color(Violet), True);
		"Survivor activation ring"
		Create Effect(All Players(All Teams), Ring, Event Player.botFollowTarget != Null ? Color(Violet) : Color(Red), Event Player,
			Global.objectiveRad, Visible To Position Radius and Color);
		"Survivor range sphere"
		Create Effect(Filtered Array(Event Player.botFollowTarget, Distance Between(Position Of(Event Player), Position Of(
			Current Array Element)) > Global.objectiveRad - 5), Sphere, Color(Violet), Event Player, Global.objectiveRad,
			Visible To Position Radius and Color);
		"Zombie slowing ring"
		Create Effect(Filtered Array(All Players(All Teams), Normalized Health(Event Player) < 1), Bad Aura, Color(Purple), Event Player,
			1, Visible To Position Radius and Color);
		For Player Variable(Event Player, entityCount, 0, 10, 1);
			"Path Markers"
			Create Effect(Filtered Array(All Players(All Teams), Count Of(Event Player.path) > Evaluate Once(Event Player.entityCount * 3)),
				Ring, Color(Violet), Event Player.path[Evaluate Once(Event Player.entityCount) * 3], 0.200,
				Visible To Position Radius and Color);
		End;
		Start Facing(Event Player, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player),
			Eye Position(Event Player.botFollowTarget))), Event Player.botFollowTarget == Null ? 80 : Vertical Angle From Direction(
			Direction Towards(Eye Position(Event Player), Eye Position(Event Player.botFollowTarget)))), 100, To World,
			Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Is True For Any(Event Player.path,
			Distance Between(Position Of(Event Player), Current Array Element) < 2) ? Last Of(Filtered Array(Event Player.path,
			Distance Between(Position Of(Event Player), Current Array Element) < 2)) : Position Of(Event Player.botFollowTarget)),
			Event Player.botFollowTarget == Null || Distance Between(Position Of(Event Player), Position Of(Event Player.botFollowTarget))
			< 1.500 ? 0 : Event Player.botThrottleSpeed, To World, Replace existing throttle, Direction and Magnitude);
	}
}

rule("SURVIVOR TO BE RESCUED DIES")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.survivorToRescue == Event Player;
	}

	actions
	{
		Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player)));
		Resurrect(Event Player);
		Wait(0.250, Ignore Condition);
		Loop If(Is Dead(Event Player));
	}
}

rule("SURVIVOR FOLLOW TARGET")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.survivorToRescue.botTempValue == False;
		Has Spawned(Global.survivorToRescue) == True;
		Health(Global.survivorToRescue) > 1;
		Is True For Any(Filtered Array(Global.playerTargetList,
			Current Array Element != Global.survivorToRescue && !Current Array Element.invisible), Distance Between(Position Of(
			Global.survivorToRescue), Position Of(Current Array Element)) < Global.objectiveRad) == True;
		Distance Between(Position Of(Global.survivorToRescue), First Of(Global.objectivePositions)) >= 5;
	}

	actions
	{
		Global.survivorToRescue.botThrottleSpeed = Normalized Health(Global.survivorToRescue) * 0.400;
		Global.survivorToRescue.potentialTargets = Filtered Array(Global.playerTargetList,
			Current Array Element != Global.survivorToRescue && !Current Array Element.invisible && Distance Between(Position Of(
			Global.survivorToRescue), Position Of(Current Array Element)) < Global.objectiveRad);
		If(Global.survivorToRescue.botFollowTarget == Null || !Array Contains(Global.survivorToRescue.potentialTargets,
			Global.survivorToRescue.botFollowTarget));
			Global.survivorToRescue.botFollowTarget = First Of(Sorted Array(Filtered Array(Global.playerTargetList, Distance Between(
				Position Of(Global.survivorToRescue), Position Of(Current Array Element)) < Global.objectiveRad), Distance Between(Position Of(
				Current Array Element), First Of(Global.objectivePositions))));
		End;
		If(!Array Contains(Global.playerTargetList, Global.survivorToRescue));
			"Add surivor to player target list"
			Modify Global Variable(playerTargetList, Append To Array, Global.survivorToRescue);
			Global.objectiveRad = 50;
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		"Remove survivor from player target list"
		Modify Global Variable(playerTargetList, Remove From Array By Value, Global.survivorToRescue);
		"Reset objective radius"
		Global.objectiveRad = Global.objectiveChase1;
		Global.survivorToRescue.botFollowTarget = Null;
		Global.survivorToRescue.potentialTargets = Empty Array;
		If(Health(Global.survivorToRescue) <= 1);
			Set Status(Global.survivorToRescue, Null, Knocked Down, 9999);
			Wait Until(Normalized Health(Global.survivorToRescue) > 0.300, 20);
			Clear Status(Global.survivorToRescue, Knocked Down);
			Loop If Condition Is True;
		End;
	}
}

rule("CREATE PATH")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.survivorToRescue.botFollowTarget != Null;
		Global.survivorToRescue.botThrottleSpeed > 0;
		Altitude Of(Global.survivorToRescue.botFollowTarget) <= 1.500;
		(Count Of(Global.survivorToRescue.path) == 0 || Distance Between(Position Of(Global.survivorToRescue.botFollowTarget), Last Of(
			Global.survivorToRescue.path)) > 1) == True;
	}

	actions
	{
		Modify Player Variable(Global.survivorToRescue, path, Append To Array, Position Of(Global.survivorToRescue.botFollowTarget));
		Wait(0.250, Restart When True);
		Loop If Condition Is True;
	}
}

rule("DELETE PATH")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Is True For Any(Global.survivorToRescue.path, Distance Between(Position Of(Global.survivorToRescue), Vector(X Component Of(
			Current Array Element), Y Component Of(Position Of(Global.survivorToRescue)), Z Component Of(Current Array Element)))
			< 0.250 && Absolute Value(Y Component Of(Position Of(Global.survivorToRescue)) - Y Component Of(Current Array Element)) < 2)
			== True;
	}

	actions
	{
		Global.survivorToRescue.telePos = Index Of Array Value(Global.survivorToRescue.path, First Of(Sorted Array(
			Global.survivorToRescue.path, Distance Between(Position Of(Global.survivorToRescue), Current Array Element))));
		Modify Player Variable(Global.survivorToRescue, path, Remove From Array By Value, Filtered Array(Global.survivorToRescue.path,
			Current Array Index <= Global.survivorToRescue.telePos));
		Wait(0.250, Restart When True);
		Loop If Condition Is True;
	}
}

rule("SURVIVOR FOLLOW TARGET NOT MOVING")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.survivorToRescue.botFollowTarget != Null;
		Count Of(Global.survivorToRescue.potentialTargets) > 1;
		Throttle Of(Global.survivorToRescue.botFollowTarget) == Vector(0, 0, 0);
	}

	actions
	{
		Wait(10, Abort When False);
		Global.survivorToRescue.botFollowTarget = Null;
	}
}

rule("PLAYER SAYS GROUP UP TO SURVIVOR")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.survivorToRescue.botFollowTarget != Null;
		Is True For Any(Global.survivorToRescue.potentialTargets, Is Communicating(Current Array Element, Group Up) && Distance Between(
			Position Of(Current Array Element), Position Of(Global.survivorToRescue)) < 12) == True;
	}

	actions
	{
		Wait(1, Abort When False);
		Global.survivorToRescue.botFollowTarget = First Of(Sorted Array(Filtered Array(Global.survivorToRescue.potentialTargets,
			Is Communicating(Current Array Element, Group Up) && Distance Between(Position Of(Current Array Element), Position Of(
			Global.survivorToRescue)) < 12), Distance Between(Position Of(Current Array Element), Position Of(Global.survivorToRescue))));
		Global.survivorToRescue.path = Empty Array;
		Communicate(Global.survivorToRescue, On My Way);
		Wait(3, Ignore Condition);
	}
}

rule("SURVIVOR JUMP")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Is On Ground(Global.survivorToRescue) == True;
		Throttle Of(Global.survivorToRescue) != Vector(0, 0, 0);
		Horizontal Speed Of(Global.survivorToRescue) < Global.survivorToRescue.botThrottleSpeed * 3.500;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Global.survivorToRescue, Button(Jump));
		Loop;
	}
}

rule("SURVIVOR REACHES EXTRACTION SITE")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 5;
		Global.objectiveComplete == False;
		Has Spawned(Global.survivorToRescue) == True;
		Distance Between(Position Of(Global.survivorToRescue), First Of(Global.objectivePositions)) < 5;
	}

	actions
	{
		Communicate(Global.survivorToRescue, Thanks);
		Start Throttle In Direction(Global.survivorToRescue, Direction Towards(Position Of(Global.survivorToRescue), First Of(
			Global.objectivePositions)), Distance Between(Position Of(Global.survivorToRescue), First Of(Global.objectivePositions))
			> 1 ? 0.750 : 0, To World, Replace existing throttle, Direction and Magnitude);
		Start Facing(Global.survivorToRescue, Vector(0, 1, 0), 100, To World, Direction and Turn Rate);
		Wait(1, Ignore Condition);
		Global.survivorToRescue.botTempValue = True;
		Global.survivorToRescue.path = Empty Array;
		Global.survivorToRescue.chase1 = Position Of(Global.survivorToRescue);
		Wait(0.016, Ignore Condition);
		Start Forcing Player Position(Global.survivorToRescue, Global.survivorToRescue.chase1, True);
		Wait(0.500, Ignore Condition);
		Chase Player Variable At Rate(Global.survivorToRescue, chase1, Position Of(Global.survivorToRescue) + Vector(0, 100, 0), 3, None);
		Wait(2, Ignore Condition);
		Chase Player Variable At Rate(Global.survivorToRescue, chase1, Position Of(Global.survivorToRescue) + Vector(0, 100, 0), 10, None);
		Wait(3, Ignore Condition);
		Destroy Dummy Bot(Team 1, Slot Of(Global.survivorToRescue));
	}
}

disabled rule("============================================== OBJECTIVE TYPE: KILL ZONE ===================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("MODIFY KILL ZONE SCORE")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 6;
		Is True For Any(Append To Array(Global.playerTargetList, Victim), Distance Between(Position Of(Current Array Element),
			Global.objectiveChase1) < Global.objectiveRad) == True;
	}

	actions
	{
		If(Distance Between(Position Of(Event Player), Global.objectiveChase1) < Global.objectiveRad || Distance Between(Position Of(
			Victim), Global.objectiveChase1) < Global.objectiveRad);
			Victim.reviveTimer = 3 - 4.5 * (Global.objectiveCaptureValue / Global.eliminationsNeededPerObjective);
			Global.objectiveCaptureValue += Round To Integer(Victim.health / 280, Up);
			If(Global.objectiveCaptureValue >= Global.eliminationsNeededPerObjective);
				Global.objectiveComplete = True;
				"Give all bots a long respawn time"
				All Players(Team 2).reviveTimer = 12;
				Global.spawnTimes = Mapped Array(Global.spawnTimes, 12);
			End;
		End;
		"Adjust Kill Zone Positions"
		Global.objectiveChase1 += 0.500 * Direction Towards(Global.objectiveChase1, Position Of(Victim));
	}
}

disabled rule("============================================== OBJECTIVE TYPE: ZOMBIE EGG ===================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("SPAWN ZOMBIE EGG")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 7;
		Global.objectiveComplete == False;
		Entity Exists(First Of(Global.bosses)) == False;
		Is True For Any(All Living Players(Team 2), Has Spawned(Current Array Element) && !Current Array Element.teleporting && !Current Array Element.successfullyTeleported) == True;
		Count Of(Filtered Array(Global.botHeros, Number Of Heroes(Current Array Element, Team 2) > 0)) < Global.uniqueSkinCap - Max(
			Number Of Slots(Team 1), Number Of Players(Team 1));
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.bosses[0] = Random Value In Array(Filtered Array(All Living Players(Team 2),
			Has Spawned(Current Array Element) && !Current Array Element.teleporting && !Current Array Element.successfullyTeleported));
		Loop If Condition Is True;
	}
}

rule("BOT BECOMES ZOMBIE EGG")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 7;
		Global.objectiveComplete == False;
		First Of(Global.bosses) == Event Player;
	}

	actions
	{
		If(Event Player.attached);
			Event Player.attached = False;
			Detach Players(Event Player);
		End;
		Teleport(Event Player, Vector(500, 500, 500));
		While(Is Dead(Event Player));
			Resurrect(Event Player);
			Wait Until(Is Alive(Event Player), 1);
		End;
		Start Forcing Player To Be Hero(First Of(Global.bosses), Hero(Wrecking Ball));
		Call Subroutine(botRespawnInitialization);
		Set Melee Enabled(Event Player, False);
		Event Player.specialThrottling = True;
		Set Invisible(Event Player, All);
		Start Forcing Player Position(Event Player, First Of(Global.objectivePositions) + Vector(0, -2.500, 0), False);
		Start Modifying Hero Voice Lines(Event Player, 0.500, False);
		"Reduce damage taken by bots close to zombie egg"
		Start Damage Modification(Filtered Array(All Players(Team 2), !Array Contains(Global.bosses, Current Array Element)
			&& Distance Between(Position Of(Current Array Element), First Of(Global.objectivePositions)) < 25 * (1 - Normalized Health(
			Event Player))), All Players(Team 1), 50, Receivers and Damagers);
		Event Player.botThrottleSpeed = 0;
		Event Player.health = 15000;
		Event Player.bossHealth = Event Player.health;
		Event Player.size = 2.500;
		Start Scaling Player(Event Player, Event Player.size, False);
		Set Player Health(Event Player, Max Health(Event Player));
		Wait Until(Event Player.wallCollisionEnabled == True, 5);
		Event Player.wallCollisionEnabled = False;
		Disable Movement Collision With Environment(Event Player, True);
		While(!Global.objectiveComplete);
			Global.bosses[1] = Distance Between(Position Of(Event Player), Eye Position(Event Player));
			If(!Is Using Ability 1(Event Player) && Is Alive(Event Player));
				Press Button(Event Player, Button(Ability 1));
				Wait(0.250, Ignore Condition);
			End;
			Wait Until(Global.objectiveComplete || (!Is Using Ability 1(Event Player) && Is Alive(Event Player)), 99999);
		End;
	}
}

rule("BOTS TELEPORT TO THE EGG")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 7;
		Global.objectiveComplete != True;
		Event Player.initializing != True;
		Event Player.teleporting != True;
		Event Player.successfullyTeleported != True;
		Is Alive(Event Player) == True;
		Entity Exists(First Of(Global.bosses)) == True;
		Array Contains(Global.bosses, Event Player) != True;
		Is True For Any(Global.playerTargetList, Distance Between(First Of(Global.objectivePositions), Position Of(Current Array Element))
			< 40) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.successfullyTeleported = True;
		Event Player.customTelePos = Vector(500, 500, 500);
		Event Player.telePos = First Of(Global.objectivePositions);
		Event Player.averagePlayersPos = Event Player.telePos;
		Event Player.reviveTimer = -1;
		Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), First Of(Global.objectivePositions), 3);
		Teleport(Event Player, Event Player.telePos);
	}
}

disabled rule("============================================== OBJECTIVE TYPE: SATELLITE UPLINK ==============================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("SET UP TERMINAL POSITIONS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 8;
		Global.gameStatus == True;
		Global.objectiveComplete == False;
		(Count Of(Global.objectiveCaptureValue) != Count Of(Global.objectiveResourcePositions) || Is True For Any(
			Global.objectiveResourcePositions, X Component Of(Current Array Element) == Null)) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Global.testPos = Filtered Array(Global.mapGrid, Distance Between(Current Array Element, First Of(Global.objectivePositions))
			> 10 && Distance Between(Current Array Element, First Of(Global.objectivePositions)) < 50);
		If(Count Of(Global.objectiveResourcePositions) == 0);
			Modify Global Variable(objectiveResourcePositions, Append To Array, Random Value In Array(Global.testPos));
		Else;
			For Global Variable(objectiveCount1, 0, Count Of(Global.objectiveResourcePositions), 1);
				"Terminals must be at least x meters apart"
				Modify Global Variable(testPos, Remove From Array By Value, Filtered Array(Global.testPos, Distance Between(Current Array Element,
					Global.objectiveResourcePositions[Global.objectiveCount1]) < Global.testPos2));
			End;
			If(Count Of(Global.testPos) > 0);
				"Successfully find new terminal location"
				Modify Global Variable(objectiveResourcePositions, Append To Array, Random Value In Array(Global.testPos));
			Else;
				"Could not find new terminal location. Remove previous"
				Modify Global Variable(objectiveResourcePositions, Remove From Array By Index, Count Of(Global.objectiveResourcePositions) - 1);
				Global.testPos2 -= 5;
			End;
		End;
		Loop If Condition Is True;
	}
}

rule("PLAYERS AT TERMINALS CONTROLS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 8;
		Global.objectiveComplete == False;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Event Player.invisible != True;
		Is True For Any(Filtered Array(Global.objectiveResourcePositions, Global.objectiveCaptureValue[Current Array Index] < 100),
			Distance Between(Current Array Element, Position Of(Event Player)) < Global.objectiveRad && X Component Of(
			Current Array Element) != Null) == True;
	}

	actions
	{
		If(!Array Contains(Global.playersOnObjective, Event Player));
			Modify Global Variable(playersOnObjective, Append To Array, Event Player);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		Modify Global Variable(playersOnObjective, Remove From Array By Value, Event Player);
	}
}

rule("PLAYERS REPAIR TERMINALS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.objectiveTypes[0] == 8;
		Global.objectiveComplete == False;
		Count Of(Global.playersOnObjective) > 0;
	}

	actions
	{
		"Check each terminal"
		For Global Variable(objectiveCount1, 0, Count Of(Global.objectiveResourcePositions), 1);
			If(Global.objectiveCaptureValue[Global.objectiveCount1] < 100);
				If(Is True For Any(Global.playersOnObjective, Distance Between(Global.objectiveResourcePositions[Global.objectiveCount1],
					Position Of(Current Array Element)) < Global.objectiveRad));
					If(Count Of(Filtered Array(Global.playersOnObjective, Distance Between(Global.objectiveResourcePositions[Global.objectiveCount1],
						Position Of(Current Array Element)) < Global.objectiveRad)) > 1);
						"2 or more players on the terminal"
						Global.objectiveCaptureValue[Global.objectiveCount1] += 0.350;
					End;
					"Base Repair Speed"
					Global.objectiveCaptureValue[Global.objectiveCount1] += 0.900;
					"If terminal is repaired"
					If(Global.objectiveCaptureValue[Global.objectiveCount1] >= 100);
						Global.objectiveCaptureValue[Global.objectiveCount1] = 100;
						Big Message(All Players(All Teams), Custom String("A terminal is back online!"));
						Play Effect(All Players(All Teams), Ring Explosion, Global.objectiveColor,
							Global.objectiveResourcePositions[Global.objectiveCount1], Global.objectiveRad * 2);
						Play Effect(All Players(All Teams), Ring Explosion Sound, Global.objectiveColor,
							Global.objectiveResourcePositions[Global.objectiveCount1], 100);
					End;
				End;
			End;
		End;
		"All terminals repaired"
		If(Is True For All(Global.objectiveCaptureValue, Current Array Element >= 100));
			Wait(1, Ignore Condition);
			Big Message(All Players(All Teams), Custom String("All terminals are back online!"));
			Play Effect(All Players(All Teams), Ring Explosion Sound, Global.objectiveColor, First Of(Global.objectivePositions), 200);
			Call Subroutine(fireSatellite);
			Global.objectiveComplete = True;
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("fireSatellite")
{
	event
	{
		Subroutine;
		fireSatellite;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("Connecting to satellite..."));
		Wait(2, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("Connection established!"));
		Global.objectiveChase1 = First Of(Global.objectivePositions);
		"Terminal connection beams"
		For Global Variable(objectiveCount1, 0, Count Of(Global.objectiveResourcePositions), 1);
			Create Beam Effect(All Players(All Teams), Bad Beam, Global.objectiveChase1 + Vector(0, 700, 0),
				Global.objectiveResourcePositions[Evaluate Once(Global.objectiveCount1)] + Vector(0, 0, 0), Global.objectiveColor,
				Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		End;
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("Preparing to fire..."));
		Wait(0.500, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("Stand clear of the laser"));
		"Warning icon"
		Create Icon(All Players(All Teams), Global.objectiveChase1 + Vector(0, 1, 0), Warning, Visible To and Position, Color(Sky Blue),
			True);
		Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		"Laser distance"
		Create In-World Text(All Players(All Teams), Custom String("Danger: {0}m", Distance Between(Global.objectiveChase1, Position Of(
			Local Player))), Global.objectiveChase1, 1, Do Not Clip, Visible To Position and String, Color(Sky Blue), Default Visibility);
		Modify Global Variable(objectiveEntities, Append To Array, Last Text ID);
		"Laser center beam"
		Create Beam Effect(All Players(All Teams), Bad Beam, Global.objectiveChase1 + Vector(0, 700, 0) + Direction From Angles(
			Total Time Elapsed * 360, 0) * 1, Global.objectiveChase1 + Vector(0, -700, 0) + Direction From Angles(Total Time Elapsed * 360,
			0) * 1, Color(Sky Blue), Visible To Position and Radius);
		Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		"Laser center beam"
		Create Beam Effect(All Players(All Teams), Bad Beam, Global.objectiveChase1 + Vector(0, 700, 0) + Direction From Angles(
			Total Time Elapsed * 360, 0) * -1, Global.objectiveChase1 + Vector(0, -700, 0) + Direction From Angles(
			Total Time Elapsed * 360, 0) * -1, Color(Sky Blue), Visible To Position and Radius);
		Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		"Sattellite firing light shafts"
		For Global Variable(objectiveCount1, -1, 5, 1);
			Create Effect(All Players(All Teams), Light Shaft, Color(Aqua), Global.objectiveChase1 + Vector(0, -15 + 20 * Evaluate Once(
				Global.objectiveCount1), 0), 1, Visible To Position and Radius);
			Modify Global Variable(objectiveEntities, Append To Array, Last Created Entity);
		End;
		Wait(5, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("Firing sequence commenced"));
		"Chase closest living zombie"
		Chase Global Variable At Rate(objectiveChase1, Position Of(Global.survivorToRescue), Is True For Any(All Living Players(Team 2),
			!Current Array Element.teleporting) ? 7.500 : 0, Destination and Rate);
		"Fire satellite"
		For Global Variable(objectiveCount1, 40, 0, -1);
			"Finish off all of the remaining zombies"
			While(Count Of(All Living Players(Team 2)) > 0);
				Stop Chasing Global Variable(objectiveChase1);
				Global.survivorToRescue = First Of(Sorted Array(Filtered Array(All Living Players(Team 2), !Current Array Element.teleporting),
					Distance Between(Position Of(Current Array Element), Global.objectiveChase1)));
				If(Global.survivorToRescue != Null);
					"Chase closest living zombie"
					Chase Global Variable At Rate(objectiveChase1, Position Of(Global.survivorToRescue), Is True For Any(All Living Players(Team 2),
						!Current Array Element.teleporting) ? 7.500 : 0, Destination and Rate);
				End;
				Wait(0.500, Ignore Condition);
				Global.testPos2 = Ray Cast Hit Position(Global.objectiveChase1 + Vector(0, 2, 0), Global.objectiveChase1 + Vector(0, -100, 0),
					All Players(All Teams), Filtered Array(All Players(All Teams), Is On Ground(Current Array Element)), False) + Vector(0, 0.100,
					0);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Global.testPos2, 5);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Sky Blue), Global.testPos2, 200);
				"Damage Zombies"
				Damage(Filtered Array(All Players(Team 2), Distance Between(Position Of(Current Array Element), Global.testPos2) < 5), Null, 500);
				"Damage Players"
				Damage(Filtered Array(All Players(Team 1), Distance Between(Position Of(Current Array Element), Global.testPos2) < 3), Null, 180);
				If(Global.objectiveCount1 > 1);
					"Give all bots quick respawn time"
					All Players(Team 2).reviveTimer = 1;
					Break;
				Else;
					"Give all bots a long respawn time"
					All Players(Team 2).reviveTimer = 10;
					Global.spawnTimes = Mapped Array(Global.spawnTimes, 10);
				End;
			End;
		End;
		Stop Chasing Global Variable(objectiveChase1);
	}
}

disabled rule("============================================== OBJECTIVE TYPE: GRAVEYARD ==============================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("ZOMBIES SPAWN AT GRAVES")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 9;
		Global.objectiveComplete != True;
		Event Player.initializing != True;
		Event Player.teleporting != True;
		Event Player.successfullyTeleported != True;
		Is Alive(Event Player) == True;
		Is True For Any(Global.playerTargetList, Distance Between(First Of(Global.objectivePositions), Position Of(Current Array Element))
			< Global.objectiveRad) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.successfullyTeleported = True;
		Event Player.canTeleport = False;
		"Check if zombie is already assigned to a grave"
		If(Array Contains(Global.objectiveResourcePositions, Event Player));
			Event Player.telePos = Global.objectiveCaptureValue[Index Of Array Value(Global.objectiveResourcePositions, Event Player)];
		"Check if any active graves are not in use"
		Else If(Count Of(Global.objectiveResourcePositions) < Min(Global.survivorToRescue, Count Of(Global.objectiveCaptureValue)));
			Modify Global Variable(objectiveResourcePositions, Append To Array, Event Player);
			Event Player.telePos = Global.objectiveCaptureValue[Index Of Array Value(Global.objectiveResourcePositions, Event Player)];
			Event Player.reviveTimer = -1;
		Else;
			Event Player.telePos = Random Value In Array(Array Slice(Global.objectiveCaptureValue, 0, Min(Global.survivorToRescue, Count Of(
				Global.objectiveCaptureValue))));
		End;
		Event Player.customTelePos = Vector(500, 500, 500);
		Event Player.averagePlayersPos = Event Player.telePos;
		"Move telePos under ground"
		Event Player.telePos += Vector(0, -2.500, 0);
		Play Effect(All Players(All Teams), Ring Explosion, Global.objectiveColor, Event Player.averagePlayersPos, 2);
		Play Effect(All Players(All Teams), Bad Pickup Effect, Global.objectiveColor, Event Player.averagePlayersPos, 2);
		Start Forcing Player Position(Event Player, Event Player.telePos, True);
		Chase Player Variable Over Time(Event Player, telePos, Event Player.averagePlayersPos, 1, None);
		Wait Until(Is Dead(Event Player), 1);
		Stop Forcing Player Position(Event Player);
		Event Player.canTeleport = True;
	}
}

rule("DESTROY GRAVES")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveTypes[0] == 9;
		Array Contains(Global.objectiveResourcePositions, Victim) == True;
		"Player kills zombie or zombie dies really close to grave"
		(!Event Was Environment || Team Of(Attacker) == Team 1 || !Victim.canTeleport) == True;
	}

	actions
	{
		Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Event Player.averagePlayersPos, 2);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Red), Event Player.averagePlayersPos, 50);
		Modify Global Variable(objectiveCaptureValue, Remove From Array By Value, Victim.averagePlayersPos);
		Modify Global Variable(objectiveResourcePositions, Remove From Array By Value, Victim);
		"Remove non existent entities from array"
		Global.objectiveResourcePositions = Filtered Array(Global.objectiveResourcePositions, Entity Exists(Current Array Element));
		If(Count Of(Global.objectiveCaptureValue) == 0);
			Global.objectiveComplete = True;
		End;
	}
}

disabled rule("============================================== PLAYERS GAME IN PROGRESS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYER INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != True;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.movementSpeed = 1;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Event Player.attached = False;
		Event Player.blinded = False;
		Event Player.afk = False;
		Disable Messages(Event Player);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Wait(0.250, Abort When False);
		Event Player.invisible = False;
		Event Player.reviving = False;
		Disable Built-In Game Mode Respawning(Event Player);
		Wait(0.016, Ignore Condition);
		Event Player.infected = False;
		Enable Death Spectate Target HUD(Event Player);
		Event Player.reviveStartTime = 5;
		Event Player.reviveTimer = Event Player.reviveStartTime;
		Event Player.deathTimer = Global.mustReviveTime;
		Event Player.initialMaxHealth = Max Health(Event Player);
		Event Player.infectionLvl = 0;
		Call Subroutine(enableDisableAbilities);
		Event Player.size = 1;
		"Player joins midgame"
		If(First Of(Event Player.playerMenuStatus) == 0);
			"Player joins game fo the first time"
			If(!Array Contains(Global.users, Custom String("{0}", Event Player)));
				Call Subroutine(updateUsers);
				Teleport(Event Player, Nearest Walkable Position(Position Of(First Of(Sorted Array(Remove From Array(Global.playerTargetList,
					Event Player), Distance Between(Position Of(Current Array Element), First Of(Global.objectivePositions)))))));
				Set Status(Event Player, Null, Invincible, 10);
				Small Message(Event Player, Custom String("Help your teammates with completing objectives"));
				Event Player.playerActiveStatus = True;
			"Player rejoins game after having left"
			Else;
				"Index of user in user array"
				Event Player.userIndex = Index Of Array Value(Global.users, Custom String("{0}", Event Player));
				Event Player.deathTimer = Global.globalPlayerStats[Event Player.userIndex][1];
				Event Player.reviveTimer = Global.globalPlayerStats[Event Player.userIndex][2];
				Event Player.reviveStartTime = Global.globalPlayerStats[Event Player.userIndex][3];
				"Player was alive when they left"
				If(First Of(Global.globalPlayerStats[Event Player.userIndex]) == 0);
					Teleport(Event Player, Nearest Walkable Position(Position Of(First Of(Sorted Array(Remove From Array(Global.playerTargetList,
						Event Player), Distance Between(Position Of(Current Array Element), First Of(Global.objectivePositions)))))));
					Set Status(Event Player, Null, Phased Out, 10);
					Small Message(Event Player, Custom String("Help your teammates with completing objectives"));
					Event Player.playerActiveStatus = True;
				"Player was downed when they left"
				Else If(First Of(Global.globalPlayerStats[Event Player.userIndex]) == 1);
					Teleport(Event Player, Global.globalPlayerStats[Event Player.userIndex][4]);
					While(Is Alive(Event Player));
						Kill(Event Player, Null);
						Wait(0.500, Ignore Condition);
					End;
					Event Player.playerActiveStatus = True;
					Big Message(Event Player, Custom String("You are downed"));
					Wait(0.500, Ignore Condition);
					Small Message(Event Player, Custom String("Wait for a teammate to revive you"));
				"Player was dead when they left"
				Else If(First Of(Global.globalPlayerStats[Event Player.userIndex]) == 2);
					Event Player.playerActiveStatus = False;
					Teleport(Event Player, Global.globalPlayerStats[Event Player.userIndex][4]);
					Big Message(Event Player, Custom String("You are dead"));
					Wait(0.500, Ignore Condition);
					Small Message(Event Player, Custom String("Please wait for the next round to begin"));
					Set Invisible(Event Player, All);
				End;
			End;
		"Player joined on start screen"
		Else;
			Wait Until(Count Of(Global.objectivePositions) >= 1, 5);
			If(Global.specialGameMode);
				Wait(0.016, Ignore Condition);
				Teleport(Event Player, Random Value In Array(Filtered Array(Global.mapGrid, Distance Between(Current Array Element,
					Global.walkCenter) < 15)));
				Wait(0.016, Ignore Condition);
			End;
			Set Facing(Event Player, Direction Towards(Eye Position(Event Player), First Of(Global.objectivePositions)), To World);
			Event Player.playerActiveStatus = True;
			Cancel Primary Action(Event Player);
			Clear Status(Event Player, Invincible);
			Call Subroutine(updateUsers);
		End;
		Stop Camera(Event Player);
		Clear Status(Event Player, Rooted);
		Set Invisible(Event Player, None);
	}
}

rule("EFFECTS/TEXTS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Event Player.playerActiveStatus == True;
		Has Spawned(Event Player) == True;
		Global.specialGameModeSetup != True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		"Infected aura"
		Create Effect(Filtered Array(All Players(All Teams), Event Player.infected), Bad Aura, Color(Lime Green), Event Player,
			Local Player == Event Player ? 0.100 : 0.500, Visible To Position and Radius);
		"Need revive text"
		Create In-World Text(Filtered Array(All Players(All Teams), Is Dead(Event Player) && Event Player.deathTimer > 0),
			Event Player.reviving ? Custom String("Reviving: {0}s", Round To Integer(Event Player.reviveTimer, Up)) : Custom String(
			"Revive: {0}s", Round To Integer(Event Player.deathTimer, Up)), Position Of(Event Player) + Vector(0, 1.500, 0), 1.500,
			Do Not Clip, Visible To Position String and Color, Event Player.reviving ? Color(Yellow) : Color(Red), Default Visibility);
		"Reviving ring"
		Create Effect(Filtered Array(All Players(All Teams), Event Player.reviving), Ring, Color(Yellow), Position Of(Event Player),
			Global.reviveRadius, Visible To Position and Radius);
		"Health Hud text"
		Create HUD Text(Filtered Array(All Players(All Teams), Event Player.deathTimer > 0 && !Event Player.afk), Custom String(
			"{0}{1}: {2}", Event Player, Hero Icon String(Hero Of(Event Player)), Is Alive(Event Player) ? Custom String("{0}%",
			Round To Integer(Normalized Health(Event Player) * 100, Up)) : Custom String("DOWN")), Is Dead(Event Player)
			&& !Event Player.reviving ? Custom String("Revive: {0}s", Round To Integer(Event Player.deathTimer, Up)) : Custom String(""),
			Event Player.infectionLvl >= 1 ? Custom String("Infection Level: {0}", Round To Integer(Event Player.infectionLvl, Down)) : (
			Event Player.infectionLvl < 0 ? Custom String("Vaccine Level: {0}", Absolute Value(Round To Integer(Event Player.infectionLvl,
			Down))) : (Event Player.reviving ? Custom String("Reviving: {0}s", Round To Integer(Event Player.reviveTimer, Up))
			: Custom String(""))), Left, Normalized Health(Event Player) > 0.970 ? 0 : 1 / (Normalized Health(Event Player) + 1),
			Normalized Health(Event Player) > 0.970 ? Color(Blue) : (Normalized Health(Event Player) > 0.660 ? Color(Green) : (
			Normalized Health(Event Player) > 0.330 ? Color(Yellow) : (Normalized Health(Event Player) > 0 ? Color(Orange) : Color(Red)))),
			Color(Red), Event Player.infectionLvl >= 1 ? Color(Lime Green) : (Event Player.infectionLvl < 0 ? Color(Blue) : Color(Yellow)),
			Visible To Sort Order String and Color, Default Visibility);
	}
}

rule("UPDATE BOT OUTLINE COLORS AND VISIBILITY")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.updateOutlines == True;
	}

	actions
	{
		Event Player.updateOutlines = False;
		Event Player.potentialTargets = All Living Players(Team 2);
		If(Event Player.blinded);
			Start Forcing Player Outlines(Event Player.potentialTargets, Event Player, False, Color(White), Default);
		Else;
			For Player Variable(Event Player, outlineCount, 0, Count Of(Event Player.potentialTargets), 1);
				Event Player.botTarget = Event Player.potentialTargets[Event Player.outlineCount];
				If(Event Player.botTarget.defaultOutlineColor);
					Start Forcing Player Outlines(Event Player.botTarget, Event Player, True, Event Player.botTarget.defaultOutlineColor, Default);
				Else;
					Stop Forcing Player Outlines(Event Player.botTarget, Event Player);
				End;
			End;
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER GETS DOWNED")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerActiveStatus == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.reviveTimer = Event Player.reviveStartTime;
		Stop All Damage Over Time(Event Player);
		Event Player.infectionLvl = 0;
		Event Player.infected = False;
		Event Player.blinded = False;
		Filtered Array(All Players(Team 2), Current Array Element.botTarget == Event Player).botTarget = Null;
		Modify Player Variable(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.potentialTargets,
			Event Player)), potentialTargets, Remove From Array By Value, Event Player);
		If(Event Was Environment);
			Teleport(Event Player, Nearest Walkable Position(Nearest Walkable Position(Position Of(Event Player)) + Direction From Angles(
				Horizontal Angle From Direction(Direction Towards(Position Of(Event Player), Nearest Walkable Position(Position Of(
				Event Player)))), 0) * 2));
		End;
	}
}

rule("REVIVE PLAYER OR ADVANCE DEATH TIMER")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
		Global.gameStatus == True;
		Event Player.playerActiveStatus == True;
		Event Player.deathTimer > 0;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		"0) Downed/Dead status, 1) Death timer, 2) Revive timer, 3) Revive start time, 4) Downed position"
		Global.globalPlayerStats[Event Player.userIndex] = Array(1, Event Player.deathTimer, Event Player.reviveTimer,
			Event Player.reviveStartTime, Position Of(Event Player));
		Wait Until(!Event Player.reviving && Is True For Any(Filtered Array(Remove From Array(Global.playerTargetList, Event Player),
			!Current Array Element.invisible), Distance Between(Position Of(Current Array Element), Position Of(Event Player))
			< Global.reviveRadius), 0.500);
		If(Is True For Any(Filtered Array(Remove From Array(Global.playerTargetList, Event Player), !Current Array Element.invisible),
			Distance Between(Position Of(Event Player), Position Of(Current Array Element)) < Global.reviveRadius));
			Event Player.reviving = True;
			Play Effect(All Players(All Teams), Ring Explosion, Color(Yellow), Position Of(Event Player), Global.reviveRadius * 2);
			Event Player.reviveTimer += -0.500;
			If(Event Player.deathTimer < Global.mustReviveTime);
				Event Player.deathTimer += 0.500;
			End;
		Else;
			Event Player.reviving = False;
			"If dome will pass player before their death timer runs out, set the death timer to how long it will take for the dome to reach them"
			If(Count Of(Global.objectivePositions) == 1 && Global.extractionZoneRad - Distance Between(Position Of(Event Player), First Of(
				Global.objectivePositions)) < Event Player.deathTimer);
				Event Player.deathTimer = (Global.extractionZoneRad - Distance Between(Position Of(Event Player), First Of(
					Global.objectivePositions))) / 2.500;
			Else;
				Event Player.deathTimer += -0.500;
			End;
			"Text lines requesting revive"
			If(Event Player.deathTimer == 40 || Event Player.deathTimer == 20);
				Start Rule(needReviveTextLines, Restart Rule);
			End;
			"Player is dead outside of extraction zone"
			If(Count Of(Global.objectivePositions) == 1 && Distance Between(First Of(Global.objectivePositions), Position Of(Event Player))
				> Global.extractionZoneRad);
				Event Player.deathTimer = 0;
			End;
			"Player's body falls off of map"
			If(Y Component Of(Position Of(Event Player)) - Y Component Of(Nearest Walkable Position(Position Of(Event Player))) < -0.100);
				Teleport(Event Player, Nearest Walkable Position(Nearest Walkable Position(Position Of(Event Player)) + Direction From Angles(
					Horizontal Angle From Direction(Direction Towards(Position Of(Event Player), Nearest Walkable Position(Position Of(
					Event Player)))), 0) * 2));
			End;
		End;
		If(Event Player.reviveTimer <= 0);
			Event Player.reviveStartTime += 1;
			Event Player.reviveTimer = Event Player.reviveStartTime;
			Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
			Resurrect(Event Player);
			Event Player.reviving = False;
			Set Status(Event Player, Null, Phased Out, 5);
			Wait Until(Is Alive(Event Player), 2);
		Else If(Event Player.deathTimer <= 0);
			"0) Downed/Dead status, 1) Death timer, 2) Revive timer, 3) Revive start time, 4) Downed position"
			Global.globalPlayerStats[Event Player.userIndex] = Array(2, Event Player.deathTimer, Event Player.reviveTimer,
				Event Player.reviveStartTime, Vector(0, -100, 0));
			Big Message(Remove From Array(All Players(All Teams), Event Player), Custom String("{0} {1} died!", Event Player, Hero Icon String(
				Hero Of(Event Player))));
			Small Message(Event Player, Custom String("You have died. You are eliminated from this round."));
			Teleport(Event Player, Vector(0, -100, 0));
			Set Invisible(Event Player, All);
		End;
		Loop If Condition Is True;
		Event Player.reviving = False;
		If(Is Alive(Event Player));
			Event Player.deathTimer = Global.mustReviveTime;
			"0) Downed/Dead status, 1) Death timer, 2) Revive timer, 3) Revive start time, 4) Downed position"
			Global.globalPlayerStats[Event Player.userIndex] = Array(0, Event Player.deathTimer, Event Player.reviveTimer,
				Event Player.reviveStartTime, Position Of(Event Player));
		End;
	}
}

rule("PLAYER PICKS UP HEALTH PACK")
{
	event
	{
		Player Received Healing;
		Team 1;
		All;
	}

	conditions
	{
		Event Was Health Pack == True;
	}

	actions
	{
		Start Heal Over Time(Event Player, Null, 5, 20);
		If(Match Time > Global.matchEndTime);
			"Update known health pack positions"
			If(Is True For All(Global.healthpackPositions, Distance Between(Current Array Element, Position Of(Event Player)) > 5));
				Modify Global Variable(healthpackPositions, Append To Array, Position Of(Event Player));
			End;
			Stop All Damage Over Time(Event Player);
			Clear Status(Event Player, Burning);
			If(Event Player.infectionLvl > 0);
				If(Event Player.infected);
					Small Message(Event Player, Custom String("You are cured!"));
					Event Player.infected = False;
				End;
				Event Player.infectionLvl = 0;
			End;
		Else If(Event Player.infected);
			Small Message(Event Player, Custom String("Match time has reached 0. Health packs no longer cure infection."));
		End;
	}
}

rule("PLAYER CLEARS DAMAGE OVER TIME")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Is Dummy Bot(Event Player) == False;
		(Has Status(Event Player, Phased Out) || Has Status(Event Player, Invincible)) == True;
	}

	actions
	{
		Stop All Damage Over Time(Event Player);
		Clear Status(Event Player, Burning);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER INFECTION DAMAGE MANAGEMENT")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.infected == True;
	}

	actions
	{
		If(Event Player.infectionLvl < 1);
			Event Player.infected = False;
		End;
		Start Damage Over Time(Event Player, Null, 1, Round To Integer(Event Player.infectionLvl, Down) ^ 4 / 16);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER AFK")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup != True;
		Workshop Setting Toggle(Custom String("General"), Custom String("Allow players to go AFK"), True, 3) == True;
		Event Player.playerActiveStatus == True;
		Event Player.attached != True;
		Throttle Of(Event Player) == Vector(0, 0, 0);
		Is Dummy Bot(Event Player) == False;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Firing Primary(Event Player) == False;
		Is Firing Secondary(Event Player) == False;
		Array Contains(Global.playersOnObjective, Event Player) != True;
	}

	actions
	{
		If(!Event Player.afk);
			Wait(30, Abort When False);
			Small Message(Remove From Array(All Players(All Teams), Event Player), Custom String("{0} {1} is afk", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Small Message(Event Player, Custom String("You are afk", Event Player, Hero Icon String(Hero Of(Event Player))));
			Event Player.afk = True;
			Set Invisible(Event Player, All);
			Modify Global Variable(playerTargetList, Remove From Array By Value, Event Player);
			Set Status(Event Player, Null, Phased Out, 9999);
		Else;
			Wait Until(Is Firing Primary(Event Player) || Is Firing Secondary(Event Player), 1);
		End;
		Loop If Condition Is True;
		If(Event Player.afk);
			Event Player.afk = False;
			Set Invisible(Event Player, None);
			Small Message(Remove From Array(All Players(All Teams), Event Player), Custom String("{0} {1} is no longer afk", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Small Message(Event Player, Custom String("You are no longer afk", Event Player, Hero Icon String(Hero Of(Event Player))));
			Clear Status(Event Player, Phased Out);
		End;
	}
}

rule("PLAYER VISIBILITY MANAGMENT")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Event Player.invisible == False;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Using Ultimate(Event Player)) == True;
		Array Contains(Global.invisibilityHeros, Hero Of(Event Player)) == True;
	}

	actions
	{
		"Cases where players will be invisible to bots while using normal game abilities"
		If((Hero Of(Event Player) == Hero(Sombra) || Hero Of(Event Player) == Hero(Moira)) && Is Using Ability 1(Event Player));
			While(Is Using Ability 1(Event Player));
				Event Player.invisible = True;
				Wait Until(!Is Using Ability 1(Event Player) || !Event Player.invisible, 9999);
			End;
		Else If(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ultimate(Event Player));
			While(Is Using Ultimate(Event Player));
				Event Player.invisible = True;
				Wait Until(!Is Using Ultimate(Event Player) || !Event Player.invisible, 9999);
			End;
		Else If(Hero Of(Event Player) == Hero(Tracer) && Is Using Ability 2(Event Player));
			While(Is Using Ability 2(Event Player));
				Event Player.invisible = True;
				Wait Until(!Is Using Ability 2(Event Player) || !Event Player.invisible, 9999);
			End;
		End;
		Event Player.invisible = False;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER AUTOMATIC RELOAD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Ammo(Event Player, 0) == 0;
		Max Ammo(Event Player, 0) != 0;
	}

	actions
	{
		Wait(3, Abort When False);
		Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
		Small Message(Event Player, Custom String("Weapon reloaded"));
	}
}

rule("OBJECTIVE CHANGES AND PLAYER ENTITIES UPDATE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Has Spawned(Event Player) == True;
		(Event Player.objectiveValue != Global.objectiveValue || Count Of(Global.objectivePositions) == 1) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Call Subroutine(playerObjectiveEntityManagement);
	}
}

rule("PLAYER TARGET (ADD)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.afk != True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Array Contains(Global.playerTargetList, Event Player) == False;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Wait(0.032, Abort When False);
		Modify Global Variable(playerTargetList, Append To Array, Event Player);
		Loop If Condition Is True;
	}
}

rule("PLAYER TARGET (REMOVE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Is Dead(Event Player) || !Has Spawned(Event Player)) == True;
		Array Contains(Global.playerTargetList, Event Player) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Wait(0.032, Abort When False);
		Modify Global Variable(playerTargetList, Remove From Array By Value, Event Player);
		Loop If Condition Is True;
	}
}

rule("playerObjectiveEntityMangement")
{
	event
	{
		Subroutine;
		playerObjectiveEntityManagement;
	}

	actions
	{
		If(Event Player.objectiveValue != Global.objectiveValue || Count Of(Global.objectivePositions) == 1);
			Event Player.objectiveValue = First Of(Global.objectiveTypes);
			"Destroy all current objective effects and texts"
			For Player Variable(Event Player, entityCount, 0, Count Of(Event Player.generalPlayerBotEntities), 1);
				Destroy Icon(Event Player.generalPlayerBotEntities[Event Player.entityCount]);
				Wait(0.016, Ignore Condition);
			End;
			Event Player.generalPlayerBotEntities = Empty Array;
			If(Event Player.objectiveValue == 4);
				"Player carrying resources icon"
				Create Icon(Filtered Array(All Players(Team 1), Is Alive(Event Player)
					&& Current Array Element != Event Player && Event Player.playerObjectiveResourceValue >= Global.amountPerResource),
					Event Player, Recycle, Visible To and Position, Color(Green), True);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			End;
		End;
	}
}

rule("needReviveTextLines")
{
	event
	{
		Subroutine;
		needReviveTextLines;
	}

	actions
	{
		Event Player.randVal = Random Integer(1, 100);
		If(Event Player.randVal <= 99);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"{2}\"", Event Player, Hero Icon String(Hero Of(Event Player)),
				Random Value In Array(Array(Custom String("I am seriously injured!"), Custom String("I need to be revived!"), Custom String(
				"I need medical assistance!"), Custom String("Someone get me a medic!"), Custom String("I need some help over here!"),
				Custom String("Someone help me up!")))));
		Else If(Event Player.randVal <= 100);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys I tripped and twisted my ankle.\"", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys it really hurts.\"", Event Player, Hero Icon String(Hero Of(
				Event Player))));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys...\"", Event Player, Hero Icon String(Hero Of(
				Event Player))));
			Wait(0.500, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"OW OW OW OW OW OWWWWW!!!!\"", Event Player, Hero Icon String(
				Hero Of(Event Player))));
		End;
	}
}

rule("updateUsers")
{
	event
	{
		Subroutine;
		updateUsers;
	}

	actions
	{
		If(!Array Contains(Global.users, Custom String("{0}", Event Player)));
			"Add event player to users list"
			Modify Global Variable(users, Append To Array, Custom String("{0}", Event Player));
			"Index of user in user array"
			Event Player.userIndex = Index Of Array Value(Global.users, Custom String("{0}", Event Player));
			"0) Downed/Dead status, 1) Death timer, 2) Revive timer, 3) Revive start time, 4) Downed position"
			Global.globalPlayerStats[Event Player.userIndex] = Array(0, Event Player.deathTimer, Event Player.reviveTimer,
				Event Player.reviveStartTime, Position Of(Event Player));
		End;
	}
}

disabled rule("============================================== BOTS GAME IN PROGRESS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("BOT INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != True;
	}

	actions
	{
		Start Heal Over Time(Event Player, Null, 9999, 9999);
		Event Player.reviveTimer = 0;
		If(Count Of(Global.customTelePositions) > 0);
			Event Player.customTelePos = First Of(Global.customTelePositions);
			Modify Global Variable(customTelePositions, Remove From Array By Index, 0);
		Else;
			Event Player.customTelePos = Null;
		End;
		Event Player.canTeleport = False;
		"Damage over time duration"
		Chase Player Variable At Rate(Event Player, damageOverTimeDuration, -1, 0.950, None);
		"Bot target warning icon (flashing)"
		Create Icon(Filtered Array(Event Player.botTarget, !Event Player.botTarget.blinded && !Is In View Angle(Current Array Element,
			Position Of(Event Player), 55)), Event Player, Warning, Visible To Position and Color, Round To Integer(Total Time Elapsed * (
			Distance Between(Position Of(Event Player), Position Of(Local Player)) > 10 ? 4 : 8), Up) % 2 == 0 ? Color(Red) : Color(
			Yellow), True);
		Wait Until(Has Spawned(Event Player), 2);
		Set Max Health(Event Player, 1);
		Event Player.initialMaxHealth = Max Health(Event Player);
		"Bot Health Pool"
		Add Health Pool To Player(Event Player, Health, Max(0, Event Player.health - Event Player.initialMaxHealth), True, True);
		"Bot Health Pool"
		Add Health Pool To Player(Event Player, Health, Max(0, Event Player.health - 10000), True, True);
		Start Facing(Event Player, Throttle Of(Event Player), 100, To Player, Direction and Turn Rate);
		Set Respawn Max Time(Event Player, 30);
		If(!Array Contains(Global.bosses, Event Player));
			Call Subroutine(botRespawnInitialization);
		End;
		Event Player.canTeleport = True;
		"TESTING ONLY"
		disabled Create Icon(Filtered Array(All Players(All Teams), Array Contains(Global.botSpawnPoints, Event Player.telePos)),
			Event Player.telePos, Spiral, Visible To and Position, Color(Green), True);
		"TESTING ONLY"
		disabled Create In-World Text(All Players(All Teams), Custom String("Current Health:{0}, Recorded Max Health:{1}", Health(Event Player),
			Event Player.health), Event Player, 2, Do Not Clip, Visible To Position and String, Color(Green), Default Visibility);

			Wait Until(Event Player.botTarget != Null, 5);
		"Initial Outline Control"
		If(Event Player.defaultOutlineColor == Null);
			Stop Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 1), !Current Array Element.blinded));
		Else;
			"Mutation outline for non-blinded players"
			Start Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 1), !Current Array Element.blinded), True,
				Event Player.defaultOutlineColor, Default);
		End;
		"Disable outline for blinded players"
		Start Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 1), Current Array Element.blinded), False, Color(
			White), Default);
	}
}

rule("KILL BOTS THAT ARE STUCK OR ARE NOT MOVING")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.teleporting != True;
		Event Player.specialThrottling != True;
		Event Player.attached != True;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		(Throttle Of(Event Player) == Vector(0, 0, 0) || Horizontal Speed Of(Event Player)
			< 1 * Event Player.botThrottleSpeed * Event Player.movementSpeed) == True;
		Is True For All(Global.playerTargetList, Distance Between(Position Of(Event Player), Position Of(Current Array Element))
			> 2.100 * Event Player.size) == True;
	}

	actions
	{
		If(Event Player.botTarget != Null);
			Wait(Random Real(7.500, 12.500), Abort When False);
		Else;
			Wait(5, Abort When False);
		End;
		Teleport(Event Player, Vector(0, -500, 0));
		Loop If Condition Is True;
	}
}

rule("BOT DIES")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Dead(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Event Player.botTarget = Null;
		Event Player.potentialTargets = Empty Array;
		Stop All Damage Over Time(Event Player);
		Stop Throttle In Direction(Event Player);
		Stop Facing(Event Player);
		If(!Event Was Environment || Team Of(Attacker) == Team 1);
			Disable Nameplates(Event Player, All Players(All Teams));
			"Allow for custom revive times"
			Wait Until(Event Player.reviveTimer != 0, 0.125);
			If(Event Player.reviveTimer == 0);
				Event Player.reviveTimer = (Match Time + Global.matchEndTime) / 60;
			End;
			If(Count Of(Global.spawnTimes) < Global.numberOfBots);
				Modify Global Variable(spawnTimes, Append To Array, Event Player.reviveTimer);
			End;
			If(Event Player.customTelePos);
				Modify Global Variable(customTelePositions, Append To Array, Event Player.customTelePos);
			End;
			Wait(1, Ignore Condition);
			Wait Until(Event Player.damageOverTimeDuration <= 0, 10);
			Call Subroutine(updateBotSpawnPoints);
			Destroy Dummy Bot(Team 2, Slot Of(Event Player));
			Abort;
		Else If(Event Was Environment && Distance Between(Position Of(Event Player), Vector(X Component Of(Event Player.telePos),
				Y Component Of(Position Of(Event Player)), Z Component Of(Event Player.telePos))) < 10);
			Event Player.successfullyTeleported = False;
		End;
		Event Player.teleporting = True;
		Teleport(Event Player, Vector(500, 50, 500));
		Wait(0.250, Ignore Condition);
		Resurrect(Event Player);
	}
}

rule("TELEPORT BOTS (GENERAL)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		Number Of Living Players(Team 1) > 0;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Call Subroutine(teleportBots);
	}
}

rule("TELEPORT BOTS WHEN NOT USED FOR TOO LONG")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.teleporting != True;
		Global.gameStatus == True;
		Event Player.attached != True;
		Event Player.targeting != True;
		Event Player.botTarget == Null;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		Is True For All(Filtered Array(Global.playerTargetList, Current Array Element.invisible), !Is In Line of Sight(Eye Position(
			Current Array Element), Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		If(Event Player.successfullyTeleported);
			Wait(10, Abort When False);
		Else;
			Wait(0.500, Abort When False);
			Wait(Max(1, 7 - Distance Between(Position Of(Event Player), Event Player.averagePlayersPos) / 8), Abort When False);
			Loop If(Event Player.successfullyTeleported);
		End;
		Call Subroutine(teleportBots);
		Loop;
	}
}

rule("BOT STUN MANAGEMENT")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Asleep) || Has Status(Event Player, Frozen) || Has Status(
			Event Player, Stunned)) == True;
	}

	actions
	{
		Event Player.crowdControlled = True;
		Wait(0.125, Ignore Condition);
		Loop If Condition Is True;
		Event Player.crowdControlled = False;
	}
}

rule("UPDATE SUCCESSFUL TELEPORT STATUS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.teleporting != True;
		Event Player.successfullyTeleported != True;
		Global.specialGameModeSetup != True;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(!Event Player.successfullyTeleported);
			Event Player.successfullyTeleported = True;
		End;
		If(Distance Between(Event Player.telePos, Event Player.averagePlayersPos) < Global.botMaxTeleportRange[1]);
			Event Player.waypoint = Position Of(Event Player);
			Call Subroutine(updateBotSpawnPoints);
		End;
	}
}

rule("BOT TARGET VISIBLE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup != True;
		Event Player.teleporting != True;
		Event Player.initializing != True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		(Event Player.botTarget == Null || Is True For Any(Remove From Array(Global.playerTargetList, Event Player.botTarget),
			!Current Array Element.invisible && Distance Between(Position Of(Current Array Element), Position Of(Event Player)) < 7.500))
			== True;
		Is True For Any(Global.playerTargetList, !Current Array Element.invisible && Distance Between(Position Of(Event Player),
			Position Of(Current Array Element)) < 150 && Is In Line of Sight(Eye Position(Current Array Element), Position Of(Event Player)
			+ Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Start Rule(selectTarget, Restart Rule);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("selectTarget")
{
	event
	{
		Subroutine;
		selectTarget;
	}

	actions
	{
		Event Player.targeting = True;
		"Set potential targets empty"
		Event Player.potentialTargets = Empty Array;
		"Prioitize dummy bots"
		Modify Player Variable(Event Player, potentialTargets, Append To Array, Filtered Array(Global.playerTargetList, Is Dummy Bot(
			Current Array Element)));
		"Add players who are below bot to target list"
		Modify Player Variable(Event Player, potentialTargets, Append To Array, Sorted Array(Filtered Array(Remove From Array(
			Global.playerTargetList, Event Player.potentialTargets), Y Component Of(Position Of(Current Array Element)) - Y Component Of(
			Position Of(Event Player)) < 2.500), Distance Between(Position Of(Event Player), Position Of(Current Array Element))));
		"Add remaining players"
		Modify Player Variable(Event Player, potentialTargets, Append To Array, Sorted Array(Remove From Array(Global.playerTargetList,
			Event Player.potentialTargets), Distance Between(Position Of(Event Player), Position Of(Current Array Element))));
		"Remove invisible players"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, !Current Array Element.invisible);
		For Player Variable(Event Player, pPowerUpCount_bTeleCount, 0, Count Of(Event Player.potentialTargets), 1);
			Event Player.testTarget = Event Player.potentialTargets[Event Player.pPowerUpCount_bTeleCount];
			If(Is In Line of Sight(Eye Position(Event Player.testTarget), Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0),
				Barriers Do Not Block LOS));
				Break;
			End;
			disabled Wait(0.016, Ignore Condition);
		End;
		If(Is Alive(Event Player));
			Event Player.botTarget = Event Player.testTarget;
			Event Player.lastTarget = Event Player.botTarget;
			Start Rule(restoreDefaultFacingMovement, Restart Rule);
		End;
		Event Player.targeting = False;
	}
}

rule("restoreDefaultFacingMovement")
{
	event
	{
		Subroutine;
		restoreDefaultFacingMovement;
	}

	actions
	{
		If(Event Player.botTarget != Null);
			If(!Event Player.specialFacing);
				Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.botTarget)),
					Event Player.attached ? 1500 : (Event Player.crowdControlled ? 0 : 100), To World, Direction and Turn Rate);
			End;
			If(!Event Player.specialThrottling);
				Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget)),
					Distance Between(Position Of(Event Player), Vector(X Component Of(Position Of(Event Player.botTarget)), Y Component Of(
					Position Of(Event Player)), Z Component Of(Position Of(Event Player.botTarget)))) > 2 * Min(1, Event Player.size)
					? Event Player.botThrottleSpeed : 0, To World, Replace existing throttle, Direction and Magnitude);
			End;
		Else;
			Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
				Replace existing throttle, None);
			Start Facing(Event Player, Throttle Of(Event Player), 100, To Player, Direction and Turn Rate);
		End;
	}
}

rule("DESELECT BOT TARGET")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.teleporting != True;
		Event Player.botTarget != Null;
		(Event Player.botTarget.invisible || !Array Contains(Global.playerTargetList, Event Player.botTarget) || !Is In Line of Sight(
			Eye Position(Event Player.botTarget), Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0),
			Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		Event Player.botTarget = Null;
		If(!Event Player.specialThrottling);
			Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.lastTarget)
				+ Normalize(World Vector Of(Throttle Of(Event Player.lastTarget), Event Player.lastTarget, Rotation)) * -2),
				Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
		End;
		If(!Event Player.specialFacing);
			Start Facing(Event Player, Throttle Of(Event Player), Event Player.crowdControlled ? 0 : 100, To Player, Direction and Turn Rate);
		End;
		Wait(0.125, Restart When True);
		Loop If Condition Is True;
	}
}

rule("BOT WANDERS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.botTarget == Null;
		Event Player.specialThrottling != True;
		Event Player.specialFacing != True;
		Event Player.crowdControlled != True;
		Has Status(Event Player, Rooted) == False;
		"Allows if bot bumps into something"
		Horizontal Speed Of(Event Player) < Event Player.botThrottleSpeed * Event Player.movementSpeed * 3.500;
		Global.specialGameModeSetup != True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Start Throttle In Direction(Event Player, Direction From Angles(Horizontal Angle From Direction(World Vector Of(Throttle Of(
			Event Player), Event Player, Rotation)) + Random Real(90, 270), 0), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, None);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("BOTS JUMP")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup != True;
		Event Player.specialThrottling == False;
		Event Player.attached != True;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Is Jumping(Event Player) != True;
		Is On Ground(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		Is Crouching(Event Player) == False;
		(Event Player.botTarget == Null || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 2) == True;
		"Allows if bot bumps into something"
		Horizontal Speed Of(Event Player) < Event Player.botThrottleSpeed * Event Player.movementSpeed * 3.500;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Jump));
		Loop If Condition Is True;
	}
}

rule("BOTS MOVE THROUGH SPAWN DOORS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.wallCollisionEnabled == True;
		Event Player.canWallPhase == True;
		Event Player.attached != True;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		Throttle Of(Event Player) != Vector(0, 0, 0);
		(Is On Ground(Event Player) || (Array Contains(Global.bosses, Event Player) && Altitude Of(Event Player) < 10)) == True;
		"Allows if bot bumps into something"
		Speed Of In Direction(Event Player, World Vector Of(Throttle Of(Event Player), Event Player, Rotation))
			< Event Player.botThrottleSpeed * Event Player.movementSpeed * 3;
		"Makes sure bot is moving forward"
		Speed Of In Direction(Event Player, World Vector Of(Throttle Of(Event Player), Event Player, Rotation)) >= 0;
		Is In Line of Sight(Position Of(Event Player) + Vector(0, 0.750, 0) * Event Player.size, Position Of(Event Player) + Vector(0,
			0.750, 0) * Event Player.size + Normalize(World Vector Of(Throttle Of(Event Player), Event Player, Rotation))
			* 3 * Event Player.size, Barriers Do Not Block LOS) == True;
	}

	actions
	{
		Wait(0.125, Abort When False);
		Disable Movement Collision With Environment(Event Player, False);
		Event Player.wallCollisionEnabled = False;
		If(Array Contains(Global.bosses, Event Player));
			Wait(2, Restart When True);
		Else;
			Wait(1, Ignore Condition);
		End;
		Loop If Condition Is True;
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
		If(!Array Contains(Global.bosses, Event Player));
			Wait(5, Ignore Condition);
		End;
	}
}

rule("BOTS MELEE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Meleeing(Event Player) != True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 3 * Event Player.size;
		Horizontal Speed Of(Event Player.botTarget) < 15 * Event Player.botTarget.movementSpeed;
	}

	actions
	{
		Wait(0.125, Abort When False);
		Press Button(Event Player, Button(Melee));
		Loop If Condition Is True;
	}
}

rule("BOTS INFLICT DAMAGE OVER TIME (INFECTION LEVEL MANAGEMENT)")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Ability == Button(Melee);
		Team Of(Victim) == Team 1;
	}

	actions
	{
		Start Damage Over Time(Victim, Event Player, Event Player.biteDuration, Event Player.biteDamage);
		If(Event Player.damageOverTimeDuration < Event Player.biteDuration);
			Event Player.damageOverTimeDuration = Event Player.biteDuration;
		End;
		If(Workshop Setting Toggle(Custom String("Infection"), Custom String("Melee Infection Enabled"), True, 0) && !Has Status(
			Event Player, Hacked) && !Is Dummy Bot(Victim) && Health(Victim) <= Victim.initialMaxHealth);
			If(Victim.infected);
				Victim.infectionLvl += 1 / Workshop Setting Integer(Custom String("Infection"), Custom String("Hits to increase infection level"),
					2, 1, 20, 2);
			Else;
				Victim.infectionLvl += 1 / Workshop Setting Integer(Custom String("Infection"), Custom String("Hits to get infected"), 4, 1, 20,
					1);
			End;
			If(!Victim.infected && Victim.infectionLvl >= 1);
				Victim.infected = True;
			End;
	}
}

rule("BOTS RECOIL FROM DAMAGE")
{
	event
	{
		Player Took Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Damage > 20;
		Event Player.crowdControlled != True;
		Event Player.attached != True;
		Team Of(Attacker) == Team 1;
		Is Alive(Victim) == True;
		disabled Event Damage * 1.100 / Victim.health > 0.350;
		Event Damage > 0.300 * Event Player.health;
	}

	actions
	{
		If(Is In Air(Victim) && Event Was Critical Hit);
			Set Status(Victim, Attacker, Knocked Down, 3);
		Else;
			Set Status(Victim, Attacker, Stunned, 0.500);
		End;
		Apply Impulse(Victim, Direction From Angles(Random Real(-20, 20) + Horizontal Angle From Direction(Event Direction), 0),
			Event Damage * 15 / Victim.health * Event Player.knockbackRecieved, To World, Incorporate Contrary Motion);
	}
}

rule("enterExitTeleport")
{
	event
	{
		Subroutine;
		enterExitTeleport;
	}

	actions
	{
		If(Event Player.teleporting);
			Set Invisible(Event Player, All);
			Stop Throttle In Direction(Event Player);
			Set Gravity(Event Player, 0);
		Else;
			Set Status(Event Player, Null, Rooted, 0.250);
			Set Invisible(Event Player, None);
			Set Gravity(Event Player, 100);
			If(Event Player.botTarget == Null);
				If(Array Contains(Global.botSpawnPoints, Event Player.telePos));
					Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Global.waypoints[Index Of Array Value(
						Global.botSpawnPoints, Event Player.telePos)]), Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
				Else;
					Start Throttle In Direction(Event Player, Direction From Angles(Random Integer(-90, 90) + Horizontal Angle From Direction(
						Direction Towards(Position Of(Event Player), Position Of(First Of(Sorted Array(Filtered Array(All Living Players(Team 1),
						Has Spawned(Current Array Element)), Distance Between(Position Of(Event Player), Position Of(Current Array Element))))))), 0),
						Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
				End;
			Else If(Event Player.botTarget != Null);
				Start Rule(restoreDefaultFacingMovement, Do Nothing);
			End;
		End;
	}
}

rule("teleportBots")
{
	event
	{
		Subroutine;
		teleportBots;
	}

	actions
	{
		Event Player.teleporting = True;
		Call Subroutine(updateBotSpawnPoints);
		Call Subroutine(enterExitTeleport);
		Event Player.successfullyTeleported = False;
		Wait Until(!Event Player.initializing && Event Player.canTeleport, 99999);
		If(Event Player.customTelePos == Null);
			While(Event Player.teleporting);
				Call Subroutine(botTeleportCenter);
				Wait(0.016, Ignore Condition);
				Event Player.telePos = 0;
				"Teleport with max distance constraint no view angle constraint"
				While(Event Player.telePos == 0 || Is True For Any(Global.playerTargetList, Distance Between(Event Player.telePos, Position Of(
					Current Array Element)) < 15) || Is True For All(Global.playerTargetList, Distance Between(Event Player.telePos, Position Of(
					Current Array Element)) > Global.botMaxTeleportRange[1]));
					Event Player.filteredBotSpawnPointGrid = Filtered Array(Global.botSpawnPoints, Distance Between(Current Array Element,
						Event Player.averagePlayersPos) < Global.botMaxTeleportRange[1]);
					"Filter out spawn points on cooldown"
					Event Player.filteredBotSpawnPointGrid = Filtered Array(Event Player.filteredBotSpawnPointGrid,
						Global.botSpawnPointTimers[Index Of Array Value(Global.botSpawnPoints, Current Array Element)] < 15);
					"Bots utilize saved spawn points"
					If(Count Of(Global.botSpawnPoints) > 0 && Count Of(Event Player.filteredBotSpawnPointGrid) > 0);
						Event Player.telePos = Random Value In Array(Event Player.filteredBotSpawnPointGrid);
						Global.botSpawnPointTimers[Index Of Array Value(Global.botSpawnPoints, Event Player.telePos)] += 5;
						Break;
					Else;
						Event Player.telePos = Nearest Walkable Position(Event Player.averagePlayersPos + Direction From Angles(Random Real(0, 360),
							Random Real(-20, 10)) * Random Real(0, Global.botMaxTeleportRange[1]));
					End;
					Wait(0.250, Ignore Condition);
				End;
				If(Is True For All(Global.playerTargetList, Distance Between(Event Player.telePos, Position Of(Current Array Element)) > 10)
					&& Is True For All(Filtered Array(Global.playerTargetList, Is In View Angle(Current Array Element, Event Player.telePos, 55)),
					!Is In Line of Sight(Eye Position(Current Array Element), Event Player.telePos + Vector(0, Global.losHeightCheck, 0),
					Barriers Do Not Block LOS)));
					Teleport(Event Player, Event Player.telePos);
					Event Player.teleporting = False;
				"Teleport was unsuccessful due to line of sight and view angle"
				Else If(Array Contains(Global.botSpawnPoints, Event Player.telePos));
					Modify Global Variable(waypoints, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints, Event Player.telePos));
					Modify Global Variable(botSpawnPointTimers, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints,
						Event Player.telePos));
					Modify Global Variable(botSpawnPoints, Remove From Array By Value, Event Player.telePos);
				End;
			End;
		Else;
			Teleport(Event Player, Event Player.customTelePos);
			Event Player.customTelePos = Null;
			Event Player.teleporting = False;
		End;
		Wait(0.016, Ignore Condition);
		Call Subroutine(enterExitTeleport);
	}
}

rule("botTeleportCenter")
{
	event
	{
		Subroutine;
		botTeleportCenter;
	}

	actions
	{
		"Capture Point/Extration Point"
		If(Global.objectiveTypes[0] == 1);
			If(Count Of(Global.playersOnObjective) == 0);
				Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
					Current Array Element), First Of(Global.objectivePositions)))));
			Else If(Count Of(Global.playersOnObjective) > 0 && Count Of(Filtered Array(Global.playerTargetList, Distance Between(First Of(
					Global.objectivePositions), Position Of(Current Array Element)) < First Of(Global.botMaxTeleportRange))) < Round To Integer(
					Count Of(Global.playerTargetList) * 0.750, Up));
				Event Player.averagePlayersPos = First Of(Global.objectivePositions);
			Else;
				Call Subroutine(locateAveragePlayerLocation);
			End;
		"Boss"
		Else If(Global.objectiveTypes[0] == 3);
			Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
				Current Array Element), Position Of(First Of(Global.bosses))))));
		"Resource Collection"
		Else If(Global.objectiveTypes[0] == 4);
			Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
				Current Array Element), First Of(Global.objectivePositions)))));
		"Survivor Rescue"
		Else If(Global.objectiveTypes[0] == 5);
			If(Global.survivorToRescue.botFollowTarget == Null);
				Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
					Current Array Element), Position Of(Global.survivorToRescue)))));
			Else;
				Event Player.averagePlayersPos = (Position Of(Global.survivorToRescue) + Position Of(Global.survivorToRescue.botFollowTarget)) / 2;
			End;
		"Killzone"
		Else If(Global.objectiveTypes[0] == 6);
			"If 75% of living players are in the killzone"
			If(Count Of(Filtered Array(Global.playerTargetList, Distance Between(Position Of(Current Array Element), Global.objectiveChase1)
				< Global.objectiveRad)) > 0.750 * Count Of(Global.playerTargetList));
				"Average player positon"
				Call Subroutine(locateAveragePlayerLocation);
			Else;
				"Player closeset to the center of the killzone"
				Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
					Current Array Element), Global.objectiveChase1))));
			End;
		"Zombie egg"
		Else If(Global.objectiveTypes[0] == 7);
			Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
				Current Array Element), First Of(Global.objectivePositions)))));
		"Satellite Uplink"
		Else If(Global.objectiveTypes[0] == 8);
			"Checks if any players are currently repairing terminals"
			If(Count Of(Global.playersOnObjective) > 0);
				"Terminal with highest repair percentage that is not fully repaired"
				Event Player.averagePlayersPos = Last Of(Sorted Array(Filtered Array(Global.objectiveResourcePositions, Count Of(
					Players Within Radius(Current Array Element, Global.objectiveRad, Team 1, Off))
					&& Global.objectiveCaptureValue[Index Of Array Value(Global.objectiveResourcePositions, Current Array Element)] < 100),
					Global.objectiveCaptureValue[Index Of Array Value(Global.objectiveResourcePositions, Current Array Element)]));
			Else;
				"Closest player to sattelite firing position"
				Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
					Current Array Element), First Of(Global.objectivePositions)))));
			End;
		"Graveyard"
		Else If(Global.objectiveTypes[0] == 9);
			Event Player.averagePlayersPos = Position Of(First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
				Current Array Element), First Of(Global.objectivePositions)))));
		"Default"
		Else;
			Call Subroutine(locateAveragePlayerLocation);
		End;
	}
}

rule("locateAveragePlayerLocation")
{
	event
	{
		Subroutine;
		locateAveragePlayerLocation;
	}

	actions
	{
		Event Player.averagePlayersPos = Vector(0, 0, 0);
		If(Count Of(Global.playersOnObjective) == 0 && Is True For Any(Global.playerTargetList, Throttle Of(Current Array Element)
			!= Vector(0, 0, 0)));
			For Player Variable(Event Player, pPowerUpCount_bTeleCount, 0, Count Of(Filtered Array(Global.playerTargetList, Throttle Of(
				Current Array Element) != Vector(0, 0, 0))), 1);
				Event Player.averagePlayersPos += Position Of(Filtered Array(Global.playerTargetList, Throttle Of(Current Array Element) != Vector(
					0, 0, 0))[Event Player.pPowerUpCount_bTeleCount]);
			End;
		Else;
			For Player Variable(Event Player, pPowerUpCount_bTeleCount, 0, Count Of(Global.playerTargetList), 1);
				Event Player.averagePlayersPos += Position Of(Global.playerTargetList[Event Player.pPowerUpCount_bTeleCount]);
			End;
		End;
		Event Player.averagePlayersPos /= Event Player.pPowerUpCount_bTeleCount;
	}
}

rule("successfulTeleportStatus")
{
	event
	{
		Subroutine;
		successfulTeleportStatus;
	}

	actions
	{
		"Max teleport distance adjustment"
		If(!Event Player.successfullyTeleported);
			Event Player.successfullyTeleported = True;
		End;
	}
}

rule("updateBotSpawnPoints")
{
	event
	{
		Subroutine;
		updateBotSpawnPoints;
	}

	actions
	{
		If(Event Player.successfullyTeleported && Event Player.customTelePos == Null && !Array Contains(Global.botSpawnPoints,
			Event Player.telePos));
			Modify Global Variable(botSpawnPoints, Append To Array, Event Player.telePos);
			Modify Global Variable(waypoints, Append To Array, Event Player.waypoint);
			Modify Global Variable(botSpawnPointTimers, Append To Array, 0);
		Else If(!Event Player.successfullyTeleported && Array Contains(Global.botSpawnPoints, Event Player.telePos));
			Modify Global Variable(waypoints, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints, Event Player.telePos));
			Modify Global Variable(botSpawnPointTimers, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints,
				Event Player.telePos));
			Modify Global Variable(botSpawnPoints, Remove From Array By Value, Event Player.telePos);
		End;
	}
}

rule("botRespawnInitialization")
{
	event
	{
		Subroutine;
		botRespawnInitialization;
	}

	actions
	{
		Event Player.initializing = True;
		If(Array Contains(Global.bosses, Event Player));
			Disable Nameplates(Event Player, All Players(All Teams));
			Event Player.health = 0;
			Event Player.initialMaxHealth = Max Health(Event Player);
		Else;
			Enable Nameplates(Event Player, All Players(All Teams));
			Event Player.size = Workshop Setting Real(Custom String("Zombies"), Custom String("Zombie Size"), 1, 0, 20, 0);
			Event Player.health = Global.botHealthValues[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
			"Scale zombie voice lines with size"
			Start Modifying Hero Voice Lines(Event Player, 0.500 + 1 / (Event Player.size + 1) + 0.250 * Sine From Degrees(
				Total Time Elapsed * Evaluate Once(Random Real(360, 720))), True);
		End;
		Stop Holding Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Primary Fire));
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
		Enable Movement Collision With Players(Event Player);
		Event Player.playerCollisionEnabled = True;
		Event Player.canWallPhase = True;
		Event Player.attached = False;
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Event Player.canWallPhase = True;
		Event Player.crowdControlled = False;
		Event Player.botTempValue = Null;
		Event Player.botSpecialTarget = Null;
		Event Player.targeting = False;
		Event Player.bossHealth = -1;
		Call Subroutine(botStatManagement);
		Call Subroutine(mutations);
		Start Scaling Player(Event Player, Event Player.size, False);
		Call Subroutine(botEntityManagement);
		Wait Until(Health(Event Player) >= Event Player.health, 5);
		Stop All Heal Over Time(Event Player);
		Set Player Health(Event Player, Event Player.health);
		Event Player.initializing = False;
	}
}

rule("botEntityManagement")
{
	event
	{
		Subroutine;
		botEntityManagement;
	}

	actions
	{
		If(Event Player.botHero != Hero Of(Event Player) || Array Contains(Global.bosses, Event Player));
			Event Player.botHero = Hero Of(Event Player);
			"Destroy all current hero effects and texts"
			For Player Variable(Event Player, entityCount, 0, Count Of(Event Player.generalPlayerBotEntities), 1);
				Destroy Effect(Event Player.generalPlayerBotEntities[Event Player.entityCount]);
				Wait(0.016, Ignore Condition);
			End;
			Event Player.generalPlayerBotEntities = Empty Array;
			If(Hero Of(Event Player) == Hero(Roadhog));
				If(Array Contains(Global.bosses, Event Player));
					"Gas Projectile 1"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.chase1 != Null), Bad Aura, Color(Lime Green),
						Event Player.chase1, 0.400 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Gas Projectile 2"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.chase1 != Null), Good Aura, Color(Lime Green),
						Event Player.chase1, 0.200 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Gas Clouds"
					For Player Variable(Event Player, entityCount, 0, 3, 1);
						"Cloud Effect"
						Create Effect(Filtered Array(All Players(All Teams), Event Player.abilityArray1[Evaluate Once(Event Player.entityCount)] != Null),
							Cloud, Color(Lime Green), Event Player.abilityArray1[Evaluate Once(Event Player.entityCount)],
							Event Player.abilityArray2[Evaluate Once(Event Player.entityCount)] + 2, Visible To Position and Radius);
						Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					End;
				Else;
					"Roadhog toxic cloud"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ability 2(Event Player)), Cloud, Color(Lime Green), Event Player,
						10 * Event Player.size + 2.500, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Mercy));
				"Mercy tentacle"
				Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue != 0), Bad Beam, Is In Air(Event Player)
					? Eye Position(Event Player) + Vector(0, 0.500, 0) * Event Player.size : Eye Position(Event Player), Event Player.chase1,
					Color(Lime Green), Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Tentacle sound effect"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue != 0), Energy Sound, Color(White),
					Event Player.chase1, 400, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Tentacle end visual effect"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue != 0), Good Aura, Color(Lime Green),
					Event Player.chase1, 0.100, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Boss only"
				If(Array Contains(Global.bosses, Event Player));
					"Ultimate lift aura"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ultimate(Event Player) && Is In View Angle(Current Array Element,
						Position Of(Event Player), 60)), Good Aura, Color(Yellow), Position Of(Event Player), 12 * Event Player.size,
						Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Wrecking Ball));
				"Ground strike location"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue), Ring, Color(Team 2),
					Event Player.botTempValue ? Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Vector(0, -100, 0),
					All Players(All Teams), All Players(All Teams), False) : Evaluate Once(Vector(0, -100, 0)), 1 * Event Player.size,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			Else If(Hero Of(Event Player) == Hero(Junkrat));
				"Boss Only"
				If(Array Contains(Global.bosses, Event Player));
					"Pre-explosion sound"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue), Energy Sound, Color(White), Eye Position(
						Local Player) + Direction Towards(Eye Position(Local Player), Position Of(Event Player)), 200, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Pre-explosion visual"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue), Bad Aura, Color(Orange), Event Player,
						1.500 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Reaper));
				"Boss Only"
				If(Array Contains(Global.bosses, Event Player));
					"Using Wraith Form"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ability 1(Event Player) && Is In View Angle(Current Array Element,
						Position Of(Event Player), 60)), Bad Aura, Color(Gray), Position Of(Event Player), 12 * Event Player.size,
						Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Using Wraith Form"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ability 1(Event Player)), Cloud, Color(White), Event Player,
						12 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Pharah));
				"Charging attack effect"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.chase1 > 0), Good Aura, Color(Blue), Event Player,
					Event Player.chase1 * Event Player.size, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			Else If(Hero Of(Event Player) == Hero(Ramattra));
				"Nemesis will activate aura"
				Create Effect(Filtered Array(Global.playerTargetList, !Event Player.botTempValue && Is Alive(Event Player)
					&& Event Player.botTarget && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 12 *
					Event Player.size), Bad Aura, Color(Purple), Event Player, 1 * Event Player.size, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Angered area of effect"
				Create Effect(Filtered Array(Global.playerTargetList, Event Player.botTempValue), Ring, Color(Red), Event Player, 12 * Event Player.size, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			Else If(Hero Of(Event Player) == Hero(Sombra));
				"Near fog visual"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True), Bad Aura, Color(Gray),
					Eye Position(Local Player) + Facing Direction Of(Local Player) * (6.750 + Evaluate Once(Random Real(-0.500, 0.500))), 200,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Mid Range fog visual"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True), Bad Aura, Color(Purple),
					Eye Position(Local Player) + Facing Direction Of(Local Player) * (20 + Evaluate Once(Random Real(-0.500, 0.500))), 200,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Mid Range fog visual"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True), Bad Aura, Color(Purple),
					Eye Position(Local Player) + Facing Direction Of(Local Player) * (30 + Evaluate Once(Random Real(-0.500, 0.500))), 200,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Illusion aura"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True && Is Using Ability 1(
					Event Player)), Good Aura, Color(Purple), Eye Position(Event Player), 0.250 * Event Player.size,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			End;
		End;
	}
}

rule("botStatManagement")
{
	event
	{
		Subroutine;
		botStatManagement;
	}

	actions
	{
		Event Player.biteDamage = Global.biteDamages[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		"Re-calibrate bite damage"
		Event Player.biteDamage *= 100 / Global.damageDealt[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		Event Player.biteDuration = Global.biteDurations[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		"Range from 0 to 1 in terms of throttle"
		Event Player.botThrottleSpeed = Global.throttleSpeeds[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		Event Player.damageDealt = Global.damageDealt[Index Of Array Value(Global.botHeros, Hero Of(Event Player))] / 100;
		Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		Set Damage Received(Event Player, 100);
		Event Player.movementSpeed = 1;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Set Jump Vertical Speed(Event Player, 100);
		Set Projectile Speed(Event Player, 100);
		Set Projectile Gravity(Event Player, 100);
		Set Healing Dealt(Event Player, 100);
		Event Player.knockbackRecieved = 1;
		Set Knockback Received(Event Player, 100);
		If(Hero Of(Event Player) == Hero(Reinhardt));
			Event Player.knockbackRecieved = 0.700;
			Set Knockback Received(Event Player, 100 * Event Player.knockbackRecieved);
		Else If(Hero Of(Event Player) == Hero(Genji));
			Set Projectile Speed(Event Player, 20);
		Else If(Hero Of(Event Player) == Hero(Reaper));
			Set Healing Dealt(Event Player, 0);
		Else If(Hero Of(Event Player) == Hero(Mercy));
			Set Projectile Speed(Event Player, 20);
		Else If(Hero Of(Event Player) == Hero(Junkrat));
			If(Array Contains(Global.bosses, Event Player));
				Event Player.movementSpeed = 1.500;
				Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			End;
		End;
	}
}

rule("enableMutations")
{
	event
	{
		Subroutine;
		enableMutations;
	}

	actions
	{
		Global.availableMutations[0] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Speed"), True, 0) ? 1 : -1;
		Global.availableMutations[1] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Size Growth"), True, 1) ? 2 : -1;
		Global.availableMutations[2] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Size Reduction"), True, 2)
			? 3 : -1;
		Global.availableMutations[3] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Radioactive"), True, 3) ? 4 : -1;
		Global.availableMutations[4] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Heavy"), True, 4) ? 5 : -1;
		Modify Global Variable(availableMutations, Remove From Array By Value, -1);
	}
}

rule("mutations")
{
	event
	{
		Subroutine;
		mutations;
	}

	actions
	{
		"Zombies have a chance to mutate. Bosses cannot mutate"
		If(Count Of(Global.availablePowerups) > 0 && !Array Contains(Global.bosses, Event Player) && Random Real(0, 100)
			< Workshop Setting Real(Custom String("Mutations"), Custom String("Chance to mutate percentage"), 25, 0, 100, -1));
			Event Player.mutationValue = Random Value In Array(Global.availableMutations);
			"Speed"
			If(Event Player.mutationValue == 1);
				Event Player.movementSpeed *= Workshop Setting Real(Custom String("Mutations"), Custom String("Speed Scalar"), 1.500, 0, 10, 0);
				Set Move Speed(Event Player, Event Player.movementSpeed * 100);
				Event Player.defaultOutlineColor = Color(Purple);
				Start Forcing Dummy Bot Name(Event Player, Custom String("SPEED"));
			"Size Growth"
			Else If(Event Player.mutationValue == 2);
				Event Player.size *= Workshop Setting Real(Custom String("Mutations"), Custom String("Size Growth Scalar"), 1.500, 1, 20, 1);
				Event Player.health *= Event Player.size;
				Event Player.defaultOutlineColor = Color(Violet);
				Start Forcing Dummy Bot Name(Event Player, Custom String("XL"));
			"Size Reduction"
			Else If(Event Player.mutationValue == 3);
				Event Player.size *= Workshop Setting Real(Custom String("Mutations"), Custom String("Size Reduction Scalar"), 0.600, 0.100, 1, 2);
				Event Player.health *= Event Player.size;
				Event Player.defaultOutlineColor = Color(Rose);
				Start Forcing Dummy Bot Name(Event Player, Custom String("XS"));
			"Radioactive"
			Else If(Event Player.mutationValue == 4);
				Event Player.biteDuration *= Workshop Setting Real(Custom String("Mutations"), Custom String("Radioactivity Damage Scalar"), 2, 1,
					5, 3);
				Event Player.defaultOutlineColor = Color(Lime Green);
				Start Forcing Dummy Bot Name(Event Player, Custom String("Radioactive"));
			"Heavy"
			Else If(Event Player.mutationValue == 5);
				Event Player.knockbackRecieved *= Workshop Setting Real(Custom String("Mutations"), Custom String(
					"Heavy Knockback Reduction Scalar Scalar"), 0.500, 0.100, 1, 4);
				Set Knockback Received(Event Player, 100 * Event Player.knockbackRecieved);
				"Scale move speed"
				Event Player.movementSpeed *= Event Player.knockbackRecieved;
				Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
				"Scale health"
				Event Player.health /= Event Player.knockbackRecieved;
				Event Player.defaultOutlineColor = Color(Black);
				Start Forcing Dummy Bot Name(Event Player, Custom String("Heavy"));
			End;
		Else;
			Event Player.mutationValue = 0;
			Event Player.defaultOutlineColor = Null;
			Stop Forcing Dummy Bot Name(Event Player);
		End;
	}
}

disabled rule("============================================== ZOMBIE TYPES ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("BASIC (REAPER) SHADOW STEP (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reaper;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Array Contains(Global.bosses, Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		Press Button(Event Player, Button(Ability 2));
		Wait(1, Ignore Condition);
		While(!Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Primary Fire));
			Wait Until(Is Using Ability 2(Event Player), 0.500);
			If(Is Using Ability 2(Event Player));
				Wait Until(!Is Using Ability 2(Event Player), 2);
				Break;
			End;
			Press Button(Event Player, Button(Ability 2));
		End;
		Press Button(Event Player, Button(Ability 1));
		Wait(0.250, Ignore Condition);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Vector(-1, 0, 0), 180, To Player, Direction and Turn Rate);
		While(Is Using Ability 1(Event Player));
			Event Player.botSpecialPotentialTargets = Filtered Array(All Living Players(All Teams),
				Current Array Element != Event Player && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
				< 12 * Event Player.size && Is In Line of Sight(Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
				Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS));
			For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
				Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
				If(Y Component Of(Position Of(Event Player.botSpecialTarget)) < Y Component Of(Position Of(Event Player)) + 4 * Event Player.size);
					"Make target float up"
					Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
						Event Player.botSpecialTarget), Position Of(Event Player))), -50), 1, To World, Incorporate Contrary Motion);
				Else;
					"Push target straight up"
					Apply Impulse(Event Player.botSpecialTarget, Vector(0, 1, 0), 0.500, To World, Incorporate Contrary Motion);
				End;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Set Ability Cooldown(Event Player, Button(Ability 2), 5);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("BOMBER (JUNKRAT) SELF DESTRUCT")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		"Scaled"
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) <= 2.750 * Event Player.size;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.botTempValue = True;
		"Pre-explosion sound"
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Orange), Event Player, 200);
		"Scaled"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Event Player, 0.500 * Event Player.size);
		"Bosses only"
		If(Array Contains(Global.bosses, Event Player));
			Set Status(Event Player, Null, Rooted, 2.500);
			Set Status(Event Player, Null, Burning, 2.500);
			Set Status(Event Player, Null, Stunned, 2.500);
			Event Player.botSpecialTarget = First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(Event Player),
				Position Of(Current Array Element))));
			Small Message(Players Within Radius(Position Of(Event Player), 10 * Event Player.size, Team 1, Off), Custom String(
				"{0} {1}: \"{2}\"", Event Player.botSpecialTarget, Hero Icon String(Hero Of(Event Player.botSpecialTarget)),
				Random Value In Array(Array(Custom String("It's gonna blow! Get down!"), Custom String("Take cover!"), Custom String(
				"Everyone get down!"), Custom String("Get to cover!"), Custom String("Look out!")))));
			Wait(1.500, Ignore Condition);
			Event Player.botTempValue = False;
			Abort If(Is Dead(Event Player));
		Else;
			Set Status(Event Player, Null, Burning, 0.600);
			Set Status(Event Player, Null, Rooted, 0.600);
			Wait(0.500, Ignore Condition);
			Event Player.botTempValue = False;
			Abort If(Is Dead(Event Player));
			Kill(Event Player, Null);
		End;
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, 1, 1);
			Event Player.botSpecialPotentialTargets = Filtered Array(All Living Players(All Teams), Distance Between(Position Of(Event Player),
				Position Of(Current Array Element)) < Event Player.size * 6 && Is In Line of Sight(Eye Position(Current Array Element),
				Eye Position(Event Player), Enemy Barriers Block LOS));
			"Scaled"
			Damage(Filtered Array(Event Player.botSpecialPotentialTargets, Distance Between(Position Of(Event Player), Position Of(
				Current Array Element)) < 3 * Event Player.size), Event Player, Event Player.biteDamage * 5);
			"Scaled"
			Damage(Event Player.botSpecialPotentialTargets, Event Player, Event Player.biteDamage * 2.500);
			"Scaled"
			Set Status(Event Player.botSpecialPotentialTargets, Event Player, Burning, 3);
			"Not scaled damage"
			Start Damage Over Time(Event Player.botSpecialPotentialTargets, Event Player, 3, Event Player.biteDamage * 2);
			If(Event Player.damageOverTimeDuration < 3);
				Event Player.damageOverTimeDuration = 3;
			End;
			Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Position Of(Event Player), 6 * Event Player.size);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Yellow), Position Of(Event Player), 3 * Event Player.size);
			"Scaled"
			Play Effect(All Players(All Teams), Explosion Sound, Color(Yellow), Position Of(Event Player), 150 * Event Player.size);
			"Scaled"
			Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Yellow), Position Of(Event Player), 150 * Event Player.size);
			Wait(0.250, Ignore Condition);
			Abort If(Is Dead(Event Player));
		End;
		If(Array Contains(Global.bosses, Event Player));
			Set Ability Cooldown(Event Player, Button(Ability 2), 20);
			Wait(3, Ignore Condition);
		End;
		Loop If Condition Is True;
	}
}

rule("BOMBER SHOOTS GRENADES (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Junkrat;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.botTempValue != True;
		Event Player.crowdControlled != True;
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		If(!Event Player.specialThrottling);
			Event Player.specialThrottling = True;
			Stop Throttle In Direction(Event Player);
			Start Holding Button(Event Player, Button(Primary Fire));
		End;
		Set Primary Fire Enabled(Event Player, True);
		Set Projectile Speed(Event Player, Random Real(20, 100));
		Set Projectile Gravity(Event Player, 0);
		Wait(0.016, Ignore Condition);
		Wait Until(!Is Firing Primary(Event Player), 1);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Set Projectile Speed(Event Player, 100);
		Set Projectile Gravity(Event Player, 100);
	}
}

rule("RUSHER (TORB) SPEED MECHANICS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Torbjörn;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Throttle Of(Event Player) != Vector(0, 0, 0);
		Array Contains(Global.bosses, Event Player) == False;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 45;
	}

	actions
	{
		Apply Impulse(Event Player, Vector(0, 1, 3), 10, To Player, Incorporate Contrary Motion);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("RUSHER MOLTEN CORE (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Torbjörn;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Set Ultimate Charge(Event Player, 100);
		While(!Is Using Ability 2(Event Player));
			Wait Until(!Is Meleeing(Event Player) && !Event Player.crowdControlled, 9999);
			Press Button(Event Player, Button(Ability 2));
			Wait(0.250, Ignore Condition);
			Abort If(Is Dead(Event Player));
		End;
		Add Health Pool To Player(Event Player, Armor, 1000, False, True);
		Event Player.botTempValue = Last Created Health Pool;
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Wait(1, Ignore Condition);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction From Angles(Evaluate Once(Random Real(0, 360)), Evaluate Once(Random Real(-80, -87))),
			Event Player.crowdControlled ? 0 : 144, To Player, Direction and Turn Rate);
		While(!Is Using Ultimate(Event Player) && Is Alive(Event Player));
			Wait Until(!Is Meleeing(Event Player) && !Event Player.crowdControlled, 9999);
			Press Button(Event Player, Button(Ultimate));
			Wait(0.250, Ignore Condition);
		End;
		Wait(1, Ignore Condition);
		While(Is Using Ultimate(Event Player));
			Press Button(Event Player, Button(Primary Fire));
			Wait(0.250, Ignore Condition);
		End;
		Cancel Primary Action(Event Player);
		Clear Status(Event Player, Rooted);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait Until(!Is Using Ability 2(Event Player), 1);
		Remove Health Pool From Player(Event Player.botTempValue);
		Set Ability Cooldown(Event Player, Button(Ability 2), 10);
		Loop If Condition Is True;
	}
}

rule("RUSHER MOLTEN CORE BURNS PLAYERS (BOSS ONLY)")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Torbjörn;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Start Damage Over Time(Victim, Attacker, 1, Event Player.biteDamage * 0.500);
		Set Status(Victim, Attacker, Burning, 0.500);
		If(Victim.damageOverTimeDuration < 0.500);
			Victim.damageOverTimeDuration = 0.500;
		End;
	}
}

rule("BEHEMOTH (ROAD) TOXIC CLOUD")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Is Alive(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
		(Array Contains(Global.bosses, Event Player) || Normalized Health(Event Player) < 0.500) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Ability 2));
		Wait(0.250, Ignore Condition);
		While(Is Using Ability 2(Event Player));
			If(Array Contains(Global.bosses, Event Player));
				"Charge Ultimate For Boss Gas Attack"
				Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + 4);
				Set Status(Event Player, Event Player, Rooted, 0.260);
				Set Ability Cooldown(Event Player, Button(Ability 1), 3);
			Else;
				"Gas Attack"
				Start Damage Over Time(Filtered Array(Global.playerTargetList, Is In Line of Sight(Eye Position(Event Player), Eye Position(
					Current Array Element), Enemy Barriers Block LOS) && Distance Between(Position Of(Event Player), Position Of(
					Current Array Element)) < 10 * Event Player.size && Y Component Of(Eye Position(Current Array Element)) - Y Component Of(
					Position Of(Event Player)) > 0 && Y Component Of(Position Of(Current Array Element)) - Y Component Of(Position Of(
					Event Player)) < 2 * Event Player.size), Event Player, 2.500, Event Player.biteDamage * 0.231);
				If(Event Player.damageOverTimeDuration < 2.500);
					Event Player.damageOverTimeDuration = 2.500;
				End;
				Set Ability Cooldown(Event Player, Button(Ability 1), 8);
			End;
			Wait(0.250, Ignore Condition);
		End;
		If(Array Contains(Global.bosses, Event Player) && Ultimate Charge Percent(Event Player) >= 100);
			Set Ultimate Charge(Event Player, 0);
			Event Player.specialThrottling = True;
			Stop Throttle In Direction(Event Player);
			Event Player.specialFacing = True;
			Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
				Event Player.attached ? 1500 : (Event Player.crowdControlled || Event Player.botTarget == Null ? 0 : 100), To World,
				Direction and Turn Rate);
			Wait(1, Ignore Condition);
			Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
				Event Player.lastTarget))) < 5 && Is On Ground(Event Player.lastTarget), 5);
			Stop Facing(Event Player);
			Set Status(Event Player, Null, Stunned, 1);
			Wait Until(!Event Player.crowdControlled, 2);
			Event Player.chase1 = Eye Position(Event Player);
			Event Player.botTempValue = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
				Event Player) * 20 * Event Player.size, Null, All Players(All Teams), False);
			"Launch Gas Projectile"
			Chase Player Variable At Rate(Event Player, chase1, Event Player.botTempValue, 20 * Event Player.size / 3, None);
			Event Player.specialFacing = False;
			Event Player.specialThrottling = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			"Gas Cloud Positions"
			Event Player.abilityArray1 = Empty Array;
			"Gas Cloud Areas of Effect"
			Event Player.abilityArray2 = Empty Array;
			While(Distance Between(Event Player.chase1, Event Player.botTempValue) > 0.100 && Count Of(Event Player.abilityArray1) < 3);
				Modify Player Variable(Event Player, abilityArray1, Append To Array, Event Player.chase1);
				Modify Player Variable(Event Player, abilityArray2, Append To Array, 0);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), Event Player.chase1, 0.400 * Event Player.size);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), Event Player.chase1, 75);
				Wait Until(Distance Between(Event Player.chase1, Event Player.botTempValue) <= 0.100 || Count Of(Event Player.abilityArray1) >= 3,
					0.900);
			End;
			"If projectile hits wall"
			If(Count Of(Event Player.abilityArray1) < 3);
				Modify Player Variable(Event Player, abilityArray1, Append To Array, Event Player.chase1);
				Modify Player Variable(Event Player, abilityArray2, Append To Array, 0);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), Event Player.chase1, 0.400 * Event Player.size);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), Event Player.chase1, 75);
			End;
			Stop Chasing Player Variable(Event Player, chase1);
			Event Player.chase1 = Null;
			Wait Until(Is Dead(Event Player), 7);
			Wait(5, Ignore Condition);
			Event Player.abilityArray1 = Empty Array;
			Event Player.abilityArray2 = Empty Array;
		End;
		Loop If Condition Is True;
	}
}

rule("BEHEMOTH GAS STREAM (BOSSES ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Count Of(Event Player.abilityArray1) > 0;
	}

	actions
	{
		Event Player.botSpecialPotentialTargets = Empty Array;
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.abilityArray1), 1);
			If(Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] < 6 * Event Player.size);
				Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] += 0.200 * Event Player.size;
			End;
			Modify Player Variable(Event Player, botSpecialPotentialTargets, Append To Array, Filtered Array(Global.playerTargetList,
				!Array Contains(Event Player.botSpecialPotentialTargets, Current Array Element) && Distance Between(
				Event Player.abilityArray1[Event Player.pForceFieldCount2_bCount1], Vector(X Component Of(Eye Position(Current Array Element)),
				Y Component Of(Event Player.abilityArray1[Event Player.pForceFieldCount2_bCount1]), Z Component Of(Eye Position(
				Current Array Element)))) < Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] && Absolute Value(
				Y Component Of(Event Player.abilityArray1[Event Player.pForceFieldCount2_bCount1]) - Y Component Of(Eye Position(
				Current Array Element))) < Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] / 5));
		End;
		Start Damage Over Time(Event Player.botSpecialPotentialTargets, Event Player, 2.500, Event Player.biteDamage * 0.100);
		If(Event Player.damageOverTimeDuration < 2.500 && Count Of(Event Player.botSpecialPotentialTargets) > 0);
			Event Player.damageOverTimeDuration = 2.500;
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("BRUTE (REIN) SUPER SEISMIC SLAM")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Ultimate Charge Percent(Event Player) >= 100;
		Distance Between(World Vector Of(Vector(0, 0, 3 * Event Player.size), Event Player, Rotation And Translation), Position Of(
			Event Player.botTarget)) < 1.500 * Event Player.size;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Ultimate));
		While(!Is Using Ultimate(Event Player));
			Wait(0.016, Restart When True);
			Abort If(Is Dead(Event Player));
			Abort If(Event Player.crowdControlled);
		End;
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), World Vector Of(Vector(0, 0, 3 * Event Player.size),
			Event Player, Rotation And Translation), 20 * Event Player.size);
		Apply Impulse(Filtered Array(Remove From Array(All Living Players(All Teams), Event Player), Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) < 20 * Event Player.size && Distance Between(World Vector Of(Vector(0, 0,
			3 * Event Player.size), Event Player, Rotation And Translation), Position Of(Current Array Element))
			> 1.500 * Event Player.size && Is In Line of Sight(Eye Position(Event Player), Eye Position(Current Array Element),
			Enemy Barriers Block LOS) && Current Array Element != Event Player && Absolute Value(Y Component Of(Position Of(Event Player))
			- Y Component Of(Position Of(Current Array Element))) < 2 * Event Player.size), Vector(0, 1, 0), 15 * Event Player.size,
			To World, Cancel Contrary Motion);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), World Vector Of(Vector(0, 0, 3 * Event Player.size),
			Event Player, Rotation And Translation), 3 * Event Player.size);
		Set Status(Filtered Array(Append To Array(Null, All Living Players(Team 2)), Distance Between(Position Of(Current Array Element),
			World Vector Of(Vector(0, 0, 3 * Event Player.size), Event Player, Rotation And Translation))
			< 1.500 * Event Player.size && !Has Status(Current Array Element, Knocked Down)), Event Player, Knocked Down, 2.500);
		Big Message(Filtered Array(All Living Players(Team 1), Distance Between(World Vector Of(Vector(0, 0, 3 * Event Player.size),
			Event Player, Rotation And Translation), Position Of(Current Array Element)) < 1.500 * Event Player.size), Custom String(
			"Crushed!"));
	}
}

rule("BRUTE HAMMER CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Distance Between(Eye Position(Event Player), Eye Position(Event Player.botTarget)) < 5 * Event Player.size;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, True);
		Start Holding Button(Event Player, Button(Primary Fire));
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("BRUTE KNOCKDOWN")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
		Hero Of(Attacker) == Hero(Reinhardt);
	}

	actions
	{
		Set Ultimate Charge(Attacker, Ultimate Charge Percent(Attacker) + 25);
		Apply Impulse(Event Player, Direction Towards(Position Of(Attacker), Position Of(Event Player)) + Vector(0, 0.250, 0),
			15 * Attacker.size, To World, Incorporate Contrary Motion);
		Set Status(Event Player, Null, Knocked Down, 0.500);
		Set Gravity(Event Player, 0);
		Wait(0.350, Ignore Condition);
		Set Gravity(Event Player, 100);
		Wait(2, Ignore Condition);
	}
}

rule("BRUTE FIRE STRIKE (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Array Contains(Global.bosses, Event Player) == True;
		Distance Between(Eye Position(Event Player), Eye Position(Event Player.botTarget)) > 5 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Set Ability Charge(Event Player, Button(Ability 2), 2);
		Press Button(Event Player, Button(Ability 2));
		Wait Until(!Is Using Ability 2(Event Player), 3);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("SLICER (GENJI) SUPER JUMP")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Genji;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 4 * Event Player.size;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 30 * Event Player.size;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.canWallPhase = False;
		Start Holding Button(Event Player, Button(Crouch));
		Wait(0.500, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Event Player.canWallPhase = True;
		If(Event Player.botTarget != Null && !Event Player.crowdControlled);
			Apply Impulse(Event Player, Normalize(Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget)) + Vector(0,
				0.250, 0)), Event Player.size * (15 + 25 * Absolute Value(Cosine From Degrees(Vertical Angle From Direction(Direction Towards(
				Position Of(Event Player), Position Of(Event Player.botTarget)))))), To World, Incorporate Contrary Motion);
		End;
		Wait(0.250, Ignore Condition);
		Wait Until(Is On Ground(Event Player), 1);
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Loop;
	}
}

rule("RIDER (WIDOWMAKER) ATTACH TO PLAYERS")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Ability == Button(Melee);
		Victim == Event Player.botTarget;
		Event Player.attached != True;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Event Player.attached = True;
		Event Player.botSpecialTarget = Victim;
		Attach Players(Event Player, Event Player.botSpecialTarget, Vector(0, 0, Event Player.botSpecialTarget.size));
	}
}

rule("RIDER DETACH WHEN DEAD OR TARGET IS DEAD")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.attached == True;
		Event Player.botSpecialTarget != Null;
		(Event Player.crowdControlled || Event Player.botSpecialTarget.invisible || Is Dead(Event Player) || Is Dead(
			Event Player.botSpecialTarget) || Has Status(Event Player.botSpecialTarget, Phased Out) || Has Status(
			Event Player.botSpecialTarget, Invincible) || !Entity Exists(Event Player.botSpecialTarget)) == True;
	}

	actions
	{
		Event Player.botSpecialTarget = Null;
		Event Player.attached = False;
		Detach Players(Event Player);
	}
}

rule("RIDER ATTACH TO TEAMMATES")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.teleporting != True;
		Event Player.attached != True;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		"If any valid teammates are within range"
		Is True For Any(Remove From Array(All Living Players(Team 2), Event Player), !Current Array Element.teleporting && Current Array Element.botThrottleSpeed > Event Player.botThrottleSpeed && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
			< 4 * Event Player.size) == True;
		(Event Player.botTarget == Null || Distance Between(Eye Position(Event Player), Event Player.botTarget) > 20 || (Ability Cooldown(
			Event Player, Button(Ability 1)) > 0 && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			> 7.500)) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.botSpecialTarget = First Of(Sorted Array(Filtered Array(Remove From Array(All Living Players(Team 2), Event Player),
			!Current Array Element.teleporting && Current Array Element.botThrottleSpeed > Event Player.botThrottleSpeed), Distance Between(Position Of(
			Event Player), Position Of(Current Array Element))));
		Attach Players(Event Player, Event Player.botSpecialTarget, Event Player.botSpecialTarget.size * Vector(Random Real(-0.500, 0.500),
			0.250, -0.750));
		Event Player.attached = True;
	}
}

rule("RIDER DETATCH FROM TEAMMATES WHILE ALIVE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.attached == True;
		Event Player.botTarget != Null;
		Team Of(Event Player.botSpecialTarget) == Team 2;
		(Event Player.teleporting || Event Player.botSpecialTarget.teleporting || Distance Between(Eye Position(Event Player), Position Of(
			Event Player.botTarget)) < 3 || (Is On Ground(Event Player.botTarget) && Ability Cooldown(Event Player, Button(Ability 1))
			== 0 && Distance Between(Eye Position(Event Player), Position Of(Event Player.botTarget)) < 10)) == True;
	}

	actions
	{
		Event Player.botSpecialTarget = Null;
		Event Player.attached = False;
		Detach Players(Event Player);
	}
}

rule("RIDER USE GRAPPLING HOOK")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.attached != True;
		Is On Ground(Event Player.botTarget) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
		Distance Between(Eye Position(Event Player), Position Of(Event Player.botTarget)) < 20;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 5;
	}

	actions
	{
		Event Player.specialFacing = True;
		Event Player.botTempValue = Ray Cast Hit Position(Eye Position(Event Player), Position Of(Event Player.botTarget), Null,
			Event Player, False);
		Stop Facing(Event Player);
		Wait Until(!Event Player.crowdControlled, 2);
		Set Facing(Event Player, Direction Towards(Eye Position(Event Player), Event Player.botTempValue), To World);
		Press Button(Event Player, Button(Ability 1));
		Wait Until(Is Using Ability 1(Event Player), 1);
		Wait(0.250, Ignore Condition);
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait Until(!Is Using Ability 1(Event Player) || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			< 4 || Distance Between(Position Of(Event Player), Event Player.botTempValue) < 3.500, 3);
		If(Is Using Ability 1(Event Player));
			Start Holding Button(Event Player, Button(Jump));
			Wait(0.250, Ignore Condition);
			Stop Holding Button(Event Player, Button(Jump));
		End;
		Set Ability Cooldown(Event Player, Button(Ability 1), 8);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("CHARGER (ORISA) CHARGE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Is On Ground(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Using Ability 1(Event Player) == False;
		Throttle Of(Event Player) != Vector(0, 0, 0);
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 35;
		(Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 5 || Vertical Angle From Direction(
			Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget))) > -35) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.canWallPhase = False;
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.attached ? 1500 : (Event Player.crowdControlled ? 0 : 100), To World, Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Vector(0, 0, -1), 0.350, To Player, Replace existing throttle, None);
		"Charger walk backwards duration"
		For Player Variable(Event Player, pNoCooldownsCount_bCount2, 0, 1, 0.064);
			If(Event Player.botTarget == Null && Event Player.botTempValue == Null);
				Event Player.botTempValue = Position Of(Event Player.lastTarget) + Normalize(World Vector Of(Throttle Of(Event Player.lastTarget),
					Event Player.lastTarget, Rotation)) * -2;
				Stop Facing(Event Player);
			Else If(Event Player.botTarget != Null && Event Player.botTempValue != 0);
				Event Player.botTempValue = Null;
			End;
			If(Event Player.crowdControlled || Is Dead(Event Player));
				Event Player.specialFacing = False;
				Event Player.specialThrottling = False;
				Start Rule(restoreDefaultFacingMovement, Do Nothing);
				Abort;
			End;
			Wait(0.064, Ignore Condition);
		End;
		Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player),
			Event Player.botTempValue == Null ? Position Of(Event Player.botTarget) : Event Player.botTempValue),
			Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Throttle Of(Event Player), 100, To Player, Direction and Turn Rate);
		Event Player.movementSpeed *= 3;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Press Button(Event Player, Button(Ability 1));
		Event Player.botTempValue = 1;
		Wait(0.250, Ignore Condition);
		Event Player.botSpecialPotentialTargets = Empty Array;
		Wait Until(!Is Using Ability 1(Event Player) || (Count Of(Event Player.botSpecialPotentialTargets) == 0 && Speed Of In Direction(
			Event Player, World Vector Of(Throttle Of(Event Player), Event Player, Rotation))
			< Event Player.botThrottleSpeed * 3.500 * Event Player.movementSpeed), 10);
		Event Player.botTempValue = Null;
		"Charge stops early due to hitting object"
		If(Is Using Ability 1(Event Player) && Speed Of In Direction(Event Player, World Vector Of(Throttle Of(Event Player), Event Player,
			Rotation)) < Event Player.botThrottleSpeed * 3.500 * Event Player.movementSpeed);
			"Wall crash light"
			Play Effect(All Players(All Teams), Bad Explosion, Color(White), World Vector Of(Vector(0, 1.500 * Event Player.size,
				Event Player.size), Event Player, Rotation And Translation), Event Player.size);
			"Wall crash sound"
			Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), World Vector Of(Vector(0, 1.500 * Event Player.size,
				Event Player.size), Event Player, Rotation And Translation), 25 * Event Player.size);
			Stop Throttle In Direction(Event Player);
			Stop Facing(Event Player);
			Set Move Speed(Event Player, 100);
			"Boss only"
			If(Array Contains(Global.bosses, Event Player));
				Play Effect(All Players(All Teams), Bad Explosion, Color(White), Position Of(Event Player), 7.500 * Event Player.size);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange), Position Of(Event Player), 200);
				Event Player.botSpecialPotentialTargets = Filtered Array(Remove From Array(Append To Array(Global.playerTargetList,
					All Living Players(Team 2)), Event Player), !Has Status(Current Array Element, Phased Out) && Distance Between(Position Of(
					Event Player), Position Of(Current Array Element)) < 7.500 * Event Player.size && Is In Line of Sight(Position Of(Event Player)
					+ Vector(0, Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
					Barriers Do Not Block LOS));
				Set Status(Filtered Array(Event Player.botSpecialPotentialTargets, Distance Between(Position Of(Event Player), Position Of(
					Current Array Element)) < 5 * Event Player.size && Is In Line of Sight(Position Of(Event Player) + Vector(0,
					Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
					Enemy Barriers Block LOS)), Event Player, Knocked Down, 0.500);
				For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
					Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
					Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
						Event Player), Position Of(Event Player.botSpecialTarget))), -10), (Distance Between(Position Of(Event Player), Position Of(
						Event Player.botSpecialTarget)) < 5 * Event Player.size ? 20 : 5) * Event Player.size, To World, Incorporate Contrary Motion);
				End;
			End;
			Wait(1, Ignore Condition);
		End;
		Event Player.movementSpeed /= 3;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Event Player.canWallPhase = True;
		Wait Until(!Is Using Ability 1(Event Player), 10);
		Set Ability Cooldown(Event Player, Button(Ability 1), Array Contains(Global.bosses, Event Player) ? 2 : 5);
	}
}

rule("CHARGER CHARGE IMPULSE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.botTempValue == 1;
		Is True For Any(Remove From Array(Append To Array(Global.playerTargetList, All Living Players(Team 2)), Event Player), !Has Status(
			Current Array Element, Phased Out) && Distance Between(Position Of(Event Player) + Vector(0, 1.500 * Event Player.size, 0),
			Position Of(Current Array Element) + Vector(0, 1.500 * Current Array Element.size, 0))
			< 2 * Event Player.size && Absolute Value(Angle Between Vectors(World Vector Of(Throttle Of(Event Player), Event Player,
			Rotation), Direction Towards(Position Of(Event Player), Position Of(Current Array Element)))) < 110) == True;
	}

	actions
	{
		Event Player.botSpecialPotentialTargets = Filtered Array(Remove From Array(Append To Array(Global.playerTargetList,
			All Living Players(Team 2)), Event Player), !Has Status(Current Array Element, Phased Out) && Distance Between(Position Of(
			Event Player) + Vector(0, 1.500 * Event Player.size, 0), Position Of(Current Array Element) + Vector(0,
			1.500 * Current Array Element.size, 0)) < 2 * Event Player.size && Absolute Value(Angle Between Vectors(World Vector Of(
			Throttle Of(Event Player), Event Player, Rotation), Direction Towards(Position Of(Event Player), Position Of(
			Current Array Element)))) < 110);
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
			Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
			"Knock players back"
			Apply Impulse(Event Player.botSpecialTarget, Normalize(Direction From Angles(Horizontal Angle From Direction(Direction Towards(
				Position Of(Event Player), Position Of(Event Player.botSpecialTarget))), 0)) + Vector(0, 2, 0) + Normalize(World Vector Of(
				Throttle Of(Event Player), Event Player, Rotation)) * 2, 12 * Event Player.size, To World, Incorporate Contrary Motion);
			"Damage players"
			Damage(Event Player.botSpecialTarget, Event Player, Event Player.biteDamage * 1.500);
		End;
		Wait(0.064, Ignore Condition);
		Loop If Condition Is True;
		Event Player.botSpecialPotentialTargets = Empty Array;
	}
}

rule("CHARGER SPEAR FLIGHT SLAM (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Orisa;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Array Contains(Global.bosses, Event Player) == True;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 35;
		(Distance Between(Vector(X Component Of(Position Of(Event Player)), Y Component Of(Position Of(Event Player.botTarget)),
			Z Component Of(Position Of(Event Player))), Position Of(Event Player.botTarget)) < 6 * Event Player.size) == True;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		While(!Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Ability 2));
			Wait Until(Is Using Ability 2(Event Player), 0.500);
		End;
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player),
			Eye Position(Event Player.lastTarget))), -1 * Absolute Value(Vertical Angle From Direction(Direction Towards(Eye Position(
			Event Player), Eye Position(Event Player.lastTarget))))), Event Player.crowdControlled ? 0 : 100, To World,
			Direction and Turn Rate);
		While(Is Using Ability 2(Event Player));
			Apply Impulse(Event Player, Facing Direction Of(Event Player), 7.500, To World, Cancel Contrary Motion);
			Wait(0.032, Ignore Condition);
		End;
		Set Ultimate Charge(Event Player, 100);
		Press Button(Event Player, Button(Ultimate));
		Wait Until(Is Using Ultimate(Event Player), 1);
		Wait Until(Is On Ground(Event Player) || !Is Using Ultimate(Event Player), 10);
		While(Is Using Ultimate(Event Player));
			Press Button(Event Player, Button(Primary Fire));
			Wait(0.250, Ignore Condition);
		End;
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Set Ability Cooldown(Event Player, Button(Ability 2), 7);
		Wait Until(Throttle Of(Event Player) != Vector(0, 0, 0), 2);
		If(Throttle Of(Event Player) == Vector(0, 0, 0));
			Start Throttle In Direction(Event Player, Vector(0, 0, 1), Event Player.botThrottleSpeed, To Player, Replace existing throttle,
				None);
		End;
	}
}

rule("SLIMER (MERCY) TENTACLE GRAB")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mercy;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.botTempValue == Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Is Using Ultimate(Event Player) != True;
		Distance Between(Eye Position(Event Player), Eye Position(Event Player.botTarget)) < 20 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
	}

	actions
	{
		Wait(Is Using Ultimate(Event Player) ? 0.016 : 0.500, Abort When False);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.botSpecialTarget = Null;
		Event Player.chase1 = Is In Air(Event Player) ? Eye Position(Event Player) + Vector(0, 0.500, 0)
			* Event Player.size : Eye Position(Event Player);
		Event Player.botTempValue = Eye Position(Event Player) + Facing Direction Of(Event Player) * 20 * Event Player.size;
		"Tentacle extends"
		Chase Player Variable At Rate(Event Player, chase1, Event Player.botTempValue, 50, Destination and Rate);
		Wait(0.016, Ignore Condition);
		While(Is Alive(Event Player) && !Event Player.crowdControlled && Distance Between(Eye Position(Event Player),
			Ray Cast Hit Position(Eye Position(Event Player), Event Player.botTempValue, All Living Players(Team 1), All Players(
			All Teams), True)) > Distance Between(Eye Position(Event Player), Event Player.chase1));
			If(Is True For Any(Global.playerTargetList, !Has Status(Current Array Element, Phased Out) && Distance Between(Event Player.chase1,
				Eye Position(Current Array Element)) < 1 && Is In Line of Sight(Event Player.chase1, Eye Position(Current Array Element),
				Enemy Barriers Block LOS)));
				Event Player.botSpecialTarget = First Of(Filtered Array(Global.playerTargetList, !Has Status(Current Array Element, Phased Out)
					&& Distance Between(Event Player.chase1, Eye Position(Current Array Element)) < 1 && Is In Line of Sight(Event Player.chase1,
					Eye Position(Event Player), Enemy Barriers Block LOS)));
				Event Player.botTempValue = Eye Position(Event Player.botSpecialTarget);
				Break;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), Event Player.chase1, 0.250);
		"Tentacle retract"
		Chase Player Variable At Rate(Event Player, chase1, Is In Air(Event Player) ? Eye Position(Event Player) + Vector(0, 0.500, 0)
			* Event Player.size : Eye Position(Event Player), 50, Destination and Rate);
		If(Is Alive(Event Player) && !Event Player.crowdControlled && Event Player.botSpecialTarget != Null);
			"Knocks target down if facing away from Mercy"
			If(Absolute Value(Angle Difference(Horizontal Facing Angle Of(Event Player.botSpecialTarget), Horizontal Angle From Direction(
				Direction Towards(Position Of(Event Player), Position Of(Event Player.botSpecialTarget))))) < 75);
				Set Status(Event Player.botSpecialTarget, Null, Knocked Down, 0.350);
			End;
			Set Gravity(Event Player.botSpecialTarget, 0);
			Apply Impulse(Event Player.botSpecialTarget, Direction Towards(Eye Position(Event Player.botSpecialTarget), Eye Position(
				Event Player)), Event Player.size * (Max Health(Event Player.botSpecialTarget) < 400 ? 15 : 10), To World,
				Cancel Contrary Motion);
			Wait(0.350, Ignore Condition);
			Set Gravity(Event Player.botSpecialTarget, 100);
		End;
		While(Distance Between(Event Player.chase1, Is In Air(Event Player) ? Eye Position(Event Player) + Vector(0, 0.500, 0)
			* Event Player.size : Eye Position(Event Player)) > 0.250);
			Wait(0.250, Ignore Condition);
		End;
		Event Player.botTempValue = Null;
		Stop Chasing Player Variable(Event Player, chase1);
		"Lower cooldown for ulting boss if they do not hit a target"
		If(Array Contains(Global.bosses, Event Player) && Is Using Ultimate(Event Player));
			Wait(0.250, Ignore Condition);
		Else;
			Event Player.specialThrottling = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			Wait(4.500, Ignore Condition);
		End;
		Loop If Condition Is True;
	}
}

rule("SLIMER FLIGHT (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Mercy;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.botTempValue == Null;
		Event Player.specialThrottling != True;
		Event Player.crowdControlled != True;
		Is On Ground(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Set Primary Fire Enabled(Event Player, True);
		Set Ultimate Charge(Event Player, 100);
		Wait Until(!Has Status(Event Player, Hacked), 1);
		Event Player.specialThrottling = True;
		While(!Is Jumping(Event Player));
			Event Player.wallCollisionEnabled = True;
			Enable Movement Collision With Environment(Event Player);
			Press Button(Event Player, Button(Jump));
			Wait Until(Is Jumping(Event Player), 1);
		End;
		Apply Impulse(Event Player, Vector(0, 1, 0), Random Real(6, 10) * Event Player.size, To World, Cancel Contrary Motion);
		Wait(0.016, Ignore Condition);
		Wait Until(Y Component Of(Velocity Of(Event Player)) < 0, 3);
		Press Button(Event Player, Button(Ultimate));
		Wait Until(Is Using Ultimate(Event Player), 1);
		Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player, 5 * Event Player.size);
		While(Is Using Ultimate(Event Player));
			Event Player.specialThrottling = True;
			Event Player.specialFacing = True;
			Stop Throttle In Direction(Event Player);
			While(Event Player.botTarget != Null && Is Using Ultimate(Event Player) && !Event Player.crowdControlled);
				Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.botTarget) + Evaluate Once(
					Direction From Angles(Random Real(0, 360), Random Real(-90, 90))) * 1), Event Player.crowdControlled ? 0 : 200, To World,
					Direction and Turn Rate);
				Press Button(Event Player, Button(Primary Fire));
				"Altitude too low"
				If(Altitude Of(Event Player) < 3);
					Event Player.wallCollisionEnabled = True;
					Enable Movement Collision With Environment(Event Player);
					Press Button(Event Player, Button(Jump));
				End;
				"Entities that will be floated"
				Event Player.botSpecialPotentialTargets = Filtered Array(All Living Players(All Teams),
					Current Array Element != Event Player && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
					< 12 * Event Player.size && Is In Line of Sight(Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
					Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS));
				For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
					Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
					If(Y Component Of(Position Of(Event Player.botSpecialTarget)) < Y Component Of(Position Of(Event Player)));
						"Make target float up"
						Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
							Event Player.botSpecialTarget), Position Of(Event Player))), -75), 0.750, To World, Incorporate Contrary Motion);
					Else;
						"Push target away"
						Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
							Event Player), Position Of(Event Player.botSpecialTarget))), -20), 0.750, To World, Incorporate Contrary Motion);
					End;
				End;
				Wait(0.032, Ignore Condition);
			End;
			Event Player.specialThrottling = False;
			Event Player.specialFacing = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			Wait(0.250, Ignore Condition);
		End;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait(10, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("STRIKER (WRECKING BALL) PILE DRIVER")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Has Status(Event Player, Rooted) == False;
		Ability Cooldown(Event Player, Button(Crouch)) <= 0;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 35;
		(Altitude Of(Event Player) > 3 || (Is On Ground(Event Player) && Is In Line of Sight(Eye Position(Event Player), Eye Position(
			Event Player) + Vector(0, 3, 0), Barriers Do Not Block LOS))) == True;
	}

	actions
	{
		Wait(0.125, Abort When False);
		Wait Until(!Has Status(Event Player, Hacked), 1);
		Event Player.botTempValue = True;
		Event Player.canWallPhase = False;
		Event Player.wallCollisionEnabled = True;
		Enable Movement Collision With Environment(Event Player);
		If(Is On Ground(Event Player));
			While(!Is Jumping(Event Player));
				Press Button(Event Player, Button(Jump));
				Wait Until(Is Jumping(Event Player), 1);
			End;
			Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Position Of(Event Player), 4 * Event Player.size);
			Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget) + Vector(0,
				10 * Event Player.size, 0)), 25, To World, Cancel Contrary Motion);
			Wait(0.250, Ignore Condition);
			Wait Until(Y Component Of(Velocity Of(Event Player)) <= 0, 3);
		End;
		Press Button(Event Player, Button(Crouch));
		Wait Until(!Is Using Ability 1(Event Player) || Event Player.crowdControlled, 5);
		Set Ability Cooldown(Event Player, Button(Crouch), 3);
		Event Player.botTempValue = Null;
		Event Player.canWallPhase = True;
	}
}

rule("STRIKER CANCEL BALL FORM")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		Event Player.specialThrottling == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Ability 1));
		Loop If Condition Is True;
	}
}

rule("STRIKER NORMAL PILE DRIVER")
{
	event
	{
		Player Dealt Knockback;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Ability == Button(Crouch);
		Array Contains(Global.bosses, Event Player) != True;
	}

	actions
	{
		Apply Impulse(Victim, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(Attacker), Position Of(
			Victim))), 0), 7.500 * Event Player.size, To World, Incorporate Contrary Motion);
	}
}

rule("STRIKER SUPER PILE DRIVER")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.botTempValue != 0;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Is Using Ability 1(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Position Of(Event Player), 7.500 * Event Player.size);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange), Position Of(Event Player), 100);
		Event Player.botSpecialPotentialTargets = Filtered Array(Remove From Array(Append To Array(Global.playerTargetList,
			All Living Players(Team 2)), Event Player), !Has Status(Current Array Element, Phased Out) && Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) < 7.500 * Event Player.size && Is In Line of Sight(Position Of(Event Player)
			+ Vector(0, Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
			Barriers Do Not Block LOS));
		Set Status(Filtered Array(Event Player.botSpecialPotentialTargets, Distance Between(Position Of(Event Player), Position Of(
			Current Array Element)) < 5 * Event Player.size && Is In Line of Sight(Position Of(Event Player) + Vector(0,
			Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
			Enemy Barriers Block LOS)), Event Player, Knocked Down, 0.350);
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
			Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
			Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
				Event Player), Position Of(Event Player.botSpecialTarget))), -25), (Distance Between(Position Of(Event Player), Position Of(
				Event Player.botSpecialTarget)) < 5 * Event Player.size ? 15 : 7.500) * Event Player.size, To World, Cancel Contrary Motion);
		End;
	}
}

rule("STALKER (MOIRA) FADE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.wallCollisionEnabled == True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 45;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.specialFacing = True;
		Event Player.playerCollisionEnabled = False;
		Disable Movement Collision With Players(Event Player);
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.crowdControlled || Is Using Ultimate(Event Player) ? 0 : (Is Using Ability 1(Event Player) ? 75 : 1500), To World,
			Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, Direction and Magnitude);
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Array Contains(Global.bosses, Event Player) ? 5 : 3, 1);
			Event Player.canWallPhase = False;
			Event Player.wallCollisionEnabled = True;
			Enable Movement Collision With Environment(Event Player);
			"Final fade"
			If(Event Player.pForceFieldCount2_bCount1 >= 2 && !Array Contains(Global.bosses, Event Player));
				Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
					Event Player.crowdControlled ? 0 : 100, To World, Direction and Turn Rate);
				Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.lastTarget)),
					Distance Between(Position Of(Event Player), Position Of(Event Player.lastTarget)) < 3 && Is Using Ability 1(Event Player)
					? 0 : Event Player.botThrottleSpeed, To World, Replace existing throttle, Direction and Magnitude);
			End;
			Event Player.movementSpeed *= 2;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			Press Button(Event Player, Button(Ability 1));
			Wait(0.125, Ignore Condition);
			Wait Until(!Is Using Ability 1(Event Player), 2);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Event Player.movementSpeed /= 2;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			If(Is Dead(Event Player) || Event Player.crowdControlled || Has Status(Event Player, Hacked));
				Break;
			End;
			If(Array Contains(Global.bosses, Event Player));
				Wait(0.125, Ignore Condition);
				Set Ultimate Charge(Event Player, 100);
				Press Button(Event Player, Button(Ultimate));
				Set Status(Event Player, Null, Rooted, 1);
				Wait Until(!Is Using Ultimate(Event Player), 1.100);
				Cancel Primary Action(Event Player);
			Else;
				Event Player.canWallPhase = True;
				Wait(0.750, Ignore Condition);
			End;
		End;
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Event Player.canWallPhase = True;
		Enable Movement Collision With Players(Event Player);
		Event Player.playerCollisionEnabled = True;
		Set Ability Cooldown(Event Player, Button(Ability 1), Array Contains(Global.bosses, Event Player) ? 10 : 5);
	}
}

rule("STALKER KNOCKBACK BLAST (BOSS ONLY)")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Moira;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Apply Impulse(Victim, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(Attacker), Position Of(
			Victim))), -25), 10 * Attacker.size, To World, Cancel Contrary Motion);
		If(!Has Status(Victim, Knocked Down));
			Set Status(Victim, Null, Knocked Down, 0.500);
	}
}

rule("HOPPER (D.VA) JUMPS AROUND")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.wallCollisionEnabled == True;
		Is In Alternate Form(Event Player) == False;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 15;
	}

	actions
	{
		Set Gravity(Event Player, 150);
		Event Player.movementSpeed *= 1.600;
		Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.crowdControlled ? 0 : (Horizontal Speed Of(Event Player)
			< 3.500 * Event Player.botThrottleSpeed * Event Player.movementSpeed ? 500 : 60), To World, Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, Direction and Magnitude);
		"Hop amount"
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, 8, 1);
			Set Jump Vertical Speed(Event Player, 110 + Event Player.pForceFieldCount2_bCount1 * 35);
			While(Is Alive(Event Player) && !Is In Air(Event Player));
				Wait Until(!Event Player.crowdControlled, 99999);
				Press Button(Event Player, Button(Jump));
				Wait(0.016, Ignore Condition);
			End;
			Wait(0.500, Ignore Condition);
			Wait Until(Is On Ground(Event Player) || Is Dead(Event Player) || Is In Alternate Form(Event Player) || Has Status(Event Player,
				Hacked) || Event Player.crowdControlled, 99999);
			If(Is Dead(Event Player) || Is In Alternate Form(Event Player) || Has Status(Event Player, Hacked)
				|| Event Player.crowdControlled);
				Break;
			End;
		End;
		Set Gravity(Event Player, 100);
		Set Jump Vertical Speed(Event Player, 100);
		Event Player.movementSpeed /= 1.600;
		Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait(5, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("HOPPER DIES TO ENVIRONMENT")
{
	event
	{
		Player Died;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Was Environment == True;
		Event Player.botTempValue < 3;
	}

	actions
	{
		"Indicate that remech is needed"
		Event Player.botTempValue = 0;
	}
}

rule("HOPPER SPAWNS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.initializing != True;
		Event Player.botTempValue < 2;
	}

	actions
	{
		"Indicate that D.Va may need to remech"
		Event Player.botTempValue = 1;
		"Boss only"
		If(Array Contains(Global.bosses, Event Player));
			Set Player Health(Event Player, Event Player.bossHealth);
		End;
		If(Is In Alternate Form(Event Player));
			Wait Until(Is On Ground(Event Player), 99999);
			Set Damage Received(Event Player, 0);
			"Always remech"
			While(Is In Alternate Form(Event Player));
				Set Ultimate Charge(Event Player, 100);
				Press Button(Event Player, Button(Ultimate));
				Wait(0.250, Ignore Condition);
			End;
			Wait Until(!Is Using Ultimate(Event Player), 3.100);
		End;
		Set Damage Received(Event Player, 100);
		"D.Va is in mech"
		Event Player.botTempValue = 2;
		"Boss only"
		If(Array Contains(Global.bosses, Event Player));
			Set Player Health(Event Player, Event Player.bossHealth);
		End;
		Loop If Condition Is True;
	}
}

rule("HOPPER DEMECH INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.initializing != True;
		Event Player.botTempValue == 2;
		Is Alive(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		"D.Va is in alternate form and does not need to remech"
		Event Player.botTempValue = 3;
		Event Player.movementSpeed *= 2.500;
		Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
		Disable Movement Collision With Players(Event Player);
		Event Player.playerCollisionEnabled = False;
		Event Player.health /= 4;
		Event Player.size /= 1.250;
		Start Scaling Player(Event Player, Event Player.size, False);
		Apply Impulse(Event Player, Vector(0, 1, 0), 15, To Player, Cancel Contrary Motion);
		Wait Until(Is In Alternate Form(Event Player), 5);
		Wait(0.250, Ignore Condition);
		If(Array Contains(Global.bosses, Event Player));
			Event Player.bossHealth = Event Player.health;
			"Adjust recorded boss height"
			Global.bosses[1] = Distance Between(Position Of(Event Player), Eye Position(Event Player));
		End;
	}
}

rule("HOPPER DEMECH CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		Event Player.botTempValue == 3;
		Event Player.botTarget != Null;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.botTarget)),
			Event Player.crowdControlled ? 0 : (Horizontal Speed Of(Event Player)
			< 3.500 * Event Player.botThrottleSpeed * Event Player.movementSpeed ? 500 : 100), To World, Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, Direction and Magnitude);
		Wait Until(Event Player.botTarget == Null, 99999);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Loop If Condition Is True;
	}
}

rule("BLASTER (PHARAH) CHARGES ROCKET THEN FIRES")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Pharah;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
	}

	actions
	{
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.crowdControlled || (Is On Ground(Event Player) && Event Player.botTarget == Null) ? 0 : 100, To World,
			Direction and Turn Rate);
		Event Player.chase1 = 0;
		Set Damage Received(Event Player, 50);
		"charge up attack"
		Chase Player Variable Over Time(Event Player, chase1, 2, Array Contains(Global.bosses, Event Player) ? 2 : 2, None);
		Wait Until(Is Dead(Event Player) || Event Player.chase1 >= 2, 99999);
		Stop Chasing Player Variable(Event Player, chase1);
		If(Is Dead(Event Player));
			Set Damage Received(Event Player, 100);
			Event Player.chase1 = 0;
			Event Player.specialThrottling = False;
			Event Player.specialFacing = False;
			Abort;
		Else;
			"charge up attack"
			Chase Player Variable Over Time(Event Player, chase1, 0, 0.250, None);
		End;
		Set Damage Received(Event Player, 100);
		Wait Until(Is Dead(Event Player) || Event Player.chase1 <= 0, 99999);
		If(Is Dead(Event Player));
			Event Player.specialThrottling = False;
			Event Player.specialFacing = False;
			Abort;
		End;
		If(Is In Line of Sight(Position Of(Event Player), Eye Position(Event Player) + World Vector Of(Vector(0, 11, 5), Event Player,
			Rotation), Barriers Do Not Block LOS) && Is In Line of Sight(Eye Position(Event Player.lastTarget), Eye Position(Event Player)
			+ World Vector Of(Vector(0, 11, 5), Event Player, Rotation), Barriers Do Not Block LOS));
			Wait Until(!Event Player.crowdControlled, 9999);
			Start Throttle In Direction(Event Player, Vector(0, 0, 1), 1, To Player, Replace existing throttle, None);
			Press Button(Event Player, Button(Ability 1));
			Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
			Wait(0.016, Ignore Condition);
			Wait Until(Vertical Speed Of(Event Player) <= 0, 99999);
			Stop Throttle In Direction(Event Player);
			"Cooldown after flying"
			Set Ability Cooldown(Event Player, Button(Ability 1), 2);
		Else;
			"Cooldown after staying on ground"
			Set Ability Cooldown(Event Player, Button(Ability 1), 1);
		End;
		If(Array Contains(Global.bosses, Event Player));
			While(!Is Using Ultimate(Event Player) && Is Alive(Event Player));
				Set Ultimate Charge(Event Player, 100);
				Set Projectile Speed(Event Player, 35);
				Press Button(Event Player, Button(Ultimate));
				Wait(0.250, Ignore Condition);
			End;
			Wait Until(!Is Using Ultimate(Event Player), 5);
			Set Ability Cooldown(Event Player, Button(Ability 1), 4);
		Else;
			Set Primary Fire Enabled(Event Player, True);
			Press Button(Event Player, Button(Primary Fire));
		End;
		Wait(0.500, Ignore Condition);
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget)),
			Event Player.botThrottleSpeed, To World, Replace existing throttle, Direction and Magnitude);
	}
}

rule("BLASTER ROCKET HITS TARGET")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Pharah;
	}

	conditions
	{
		(Event Ability == Button(Primary Fire) || Event Ability == Button(Ultimate)) == True;
	}

	actions
	{
		If(Event Ability == Button(Ultimate));
			Start Damage Over Time(Victim, Event Player, 2, Event Player.biteDamage * 0.500);
			Set Status(Victim, Event Player, Burning, 2);
			If(Event Player.damageOverTimeDuration < 2);
				Event Player.damageOverTimeDuration = 2;
			End;
		Else If(Event Ability == Button(Primary Fire));
			Start Damage Over Time(Victim, Event Player, 1, Event Player.biteDamage);
			Set Status(Victim, Event Player, Burning, 1);
			If(Event Player.damageOverTimeDuration < 1);
				Event Player.damageOverTimeDuration = 1;
			End;
		End;
	}
}

rule("NANOMANCER (RAMATTRA) FIRES NANITE SWARM")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ramattra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.botTempValue != True;
		Is Using Ability 1(Event Player) != True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 25;
	}

	actions
	{
		If(!Is Button Held(Event Player, Button(Primary Fire)));
			Event Player.specialThrottling = True;
			Stop Throttle In Direction(Event Player);
			Event Player.specialFacing = True;
			Start Facing(Event Player, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player),
				Position Of(Event Player.botTarget) + Vector(0, 1 * Event Player.botTarget.size, 0))) + 3 * Sine From Degrees(
				Total Time Elapsed * 150), Vertical Angle From Direction(Direction Towards(Eye Position(Event Player), Position Of(
				Event Player.botTarget) + Vector(0, 1 * Event Player.botTarget.size, 0)))), Event Player.crowdControlled ? 0 : 200, To World,
				Direction and Turn Rate);
			Set Primary Fire Enabled(Event Player, True);
			Set Projectile Speed(Event Player, 10);
			Start Holding Button(Event Player, Button(Primary Fire));
		End;
		Wait Until(Event Player.botTarget == Null || Is Using Ability 1(Event Player), 1);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
	}
}

rule("NANOMANCER TRANSFORMS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ramattra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Using Ability 1(Event Player) != True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 12 * Event Player.size;
	}

	actions
	{
		Wait Until(Event Player.botTarget != Null && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			< 5 * Event Player.size, 3);
		Abort If(Event Player.botTarget == Null || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			>= 12 * Event Player.size);
		Event Player.botTempValue = True;
		"Non-bosses get increased health"
		If(!Array Contains(Global.bosses, Event Player));
			Event Player.health *= 6;
			Start Heal Over Time(Event Player, Null, 3, (Event Player.health - Health(Event Player)) / 3);
		End;
		Set Projectile Speed(Event Player, 100);
		Set Melee Enabled(Event Player, False);
		Event Player.damageDealt /= 1;
		Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		While(Event Player.botTarget != Null && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			< 12 * Event Player.size);
			While(!Is Using Ability 1(Event Player));
				Set Ability Cooldown(Event Player, Button(Ability 1), 0);
				Press Button(Event Player, Button(Ability 1));
				Wait Until(Is Using Ability 1(Event Player), 0.250);
			End;
			Wait Until(!Is Using Ability 1(Event Player), 30);
			Wait(0.125, Ignore Condition);
		End;
		Set Melee Enabled(Event Player, True);
		Event Player.damageDealt *= 1;
		Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		If(!Array Contains(Global.bosses, Event Player));
			Event Player.health /= 6;
		End;
		Event Player.botTempValue = False;
		Wait(6, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("NANOMANCER PUNCHES IN NEMESIS FORM")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Ramattra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.botSpecialTarget != True;
		Is Using Ability 1(Event Player) == True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 8 * Event Player.size;
	}

	actions
	{
		Press Button(Event Player, Button(Primary Fire));
		Wait(0.6, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("ILLUISONIST (SOMBRA) ACTIVATES INVISIBILITY ILLUSION")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.crowdControlled != True;
		Event Player.initializing != True;
		Event Player.teleporting != True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
		(Event Player.botTarget == Null || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			> 3 * Event Player.size) == True;
		Array Contains(Global.bosses, Event Player) != True;
	}

	actions
	{
		Wait(1, Abort When False);
		While(!Is Using Ability 1(Event Player));
			Press Button(Event Player, Button(Ability 1));
			Wait Until(Is Using Ability 1(Event Player), 0.500);
		End;
		Event Player.movementSpeed /= 1.600;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Wait Until(!Is Using Ability 1(Event Player), 9999);
		Event Player.movementSpeed *= 1.600;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Set Ability Cooldown(Event Player, Button(Ability 1), 2);
	}
}

rule("ILLUISONIST USES EMP")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		((Array Contains(Global.bosses, Event Player) && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 20) || (Is Using Ability 1(Event Player) && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 7.5 && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 30)) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		Event Player.botSpecialPotentialTargets = Empty Array;
		If(Array Contains(Global.bosses, Event Player));
			Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Position Of(Event Player), 2 * Event Player.size);
			Apply Impulse(Event Player, Vector(0, 1, 0), 4 * Event Player.size, To World, Cancel Contrary Motion);
			Wait(0.125, Ignore Condition);
			Wait Until(Y Component Of(Velocity Of(Event Player)) <= 0, 5);
		Else;
		 	Event Player.specialFacing = True;
			Stop Facing(Event Player);
			Set Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget) + Vector(0, 10, 0)), To World);
			Wait(0.125, Ignore Condition);
			While(!Is Using Ability 2(Event Player));
				Press Button(Event Player, Button(Ability 2));
				Wait(0.125, Ignore Condition);
			End;
			Event Player.specialFacing = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			Wait(1.5, Ignore Condition);
			Event Player.botTempValue = Position Of(Event Player);
			While(Is Using Ability 2(Event Player));
				Press Button(Event Player, Button(Ability 2));
				Wait(0.125, Ignore Condition);
			End;
			Set Invisible(Event Player, All);
			Wait(0.25, Ignore Condition);
		End;
		"Is boss or translocator has not been destroyed"
		If(Array Contains(Global.bosses, Event Player) || Distance Between(Position Of(Event Player), Event Player.botTempValue) > 1);
			Event Player.damageDealt = 0.010;
			Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
			While(Ultimate Charge Percent(Event Player) >= 100);
				Press Button(Event Player, Button(Ultimate));
				Wait(0.125, Ignore Condition);
			End;
			"EMP Cast"
			Wait(0.360, Ignore Condition);
			"Restore normal damage"
			Event Player.damageDealt = Global.damageDealt[Index Of Array Value(Global.botHeros, Hero Of(Event Player))] / 100;
			Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		End;
		If(!Array Contains(Global.bosses, Event Player));
			Wait(0.125, Ignore Condition);
			Teleport(Event Player, Event Player.botTempValue);
			Set Invisible(Event Player, None);
			Event Player.pForceFieldCount2_bCount1 = 5;
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Else;
			Event Player.pForceFieldCount2_bCount1 = 10;
		End;
		Event Player.damageOverTimeDuration = EventPlayer.pForceFieldCount2_bCount1 + 0.5;
		While(Event Player.pForceFieldCount2_bCount1 > 0);
			Event Player.botSpecialPotentialTargets.blinded = True;
			Event Player.botSpecialPotentialTargets.updateOutlines = True;
			Wait(0.500, Ignore Condition);
			Event Player.pForceFieldCount2_bCount1 -= 0.500;
		End;
		Event Player.botSpecialPotentialTargets.blinded = False;
		Event Player.botSpecialPotentialTargets.updateOutlines = True;
		Event Player.botSpecialPotentialTargets = Empty Array;
		If(Array Contains(Global.bosses, Event Player));
			Wait(5, Ignore Condition);
		End;
		Loop If Condition Is True;
	}
}

rule("ILLUSIONIST HITS TARGET WITH EMP")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Sombra;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Modify Player Variable(Attacker, botSpecialPotentialTargets, Append To Array, Victim);
	}
}

disabled rule("============================================== SUPPLY DROPS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("GENERATE SUPPLY DROPS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Only activates if last supply drop has been opened"
		Global.supplyDropStatus == True;
		"Waits for all objectives to be determined before activating"
		Global.gameStatus == True;
		Count Of(Global.availablePowerups) > 0;
		"Limited to 12 power ups on the ground at a time"
		Count Of(Global.powerUpPositions) < 12;
	}

	actions
	{
		"Standard 30 second wait"
		Wait(30, Ignore Condition);
		Global.supplyDropLanding = Null;
		Global.supplyDropPosition = Null;
		Global.supplyDropStatus = False;
		"Wait standard minimum 30 seconds + a random 30 to 90 extra seconds. Total resulting wait time is 2 to 3 minutes."
		Wait(Random Real(1.500, 2.500) * 60, Ignore Condition);
		While(Global.supplyDropLanding == Null);
			"Find the closest player to the objective"
			Global.closestPlayerToObjective = First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
				Current Array Element), First Of(Global.objectivePositions))));
			Global.testPos = Random Value In Array(Filtered Array(Global.mapGrid, Distance Between(Position Of(
				Global.closestPlayerToObjective), Current Array Element) < 35 && Distance Between(Position Of(Global.closestPlayerToObjective),
				Current Array Element) > 20));
			If(Is True For All(Global.playerTargetList, Distance Between(Global.testPos, Position Of(Current Array Element)) > 20));
				"Sets supply drop location"
				Global.supplyDropLanding = Global.testPos;
				"Sets supply drop location to be placed on ground (in the case that a walkable position is underground for some reason)"
				Global.supplyDropLanding = Ray Cast Hit Position(Global.supplyDropLanding + Vector(0, 2, 0), Global.supplyDropLanding + Vector(0,
					0, 0), All Players(All Teams), All Players(All Teams), False);
			End;
			Wait(0.250, Ignore Condition);
		End;
		Global.supplyDropPosition = Global.supplyDropLanding + Vector(0, 200, 0);
		Chase Global Variable Over Time(supplyDropPosition, Global.supplyDropLanding, 15, Destination and Duration);
		Big Message(All Players(Team 1), Custom String("Supply drop incoming!"));
		Wait Until(Global.supplyDropPosition == Global.supplyDropLanding, 99999);
		Stop Chasing Global Variable(supplyDropPosition);
		Play Effect(All Players(Team 1), Ring Explosion, Color(Aqua), Global.supplyDropLanding, 4);
		Play Effect(All Players(Team 1), Ring Explosion Sound, Color(White), Global.supplyDropLanding, 50);
		Wait(10, Restart When True);
		Loop If(Count Of(Global.powerUpPositions) < 12);
	}
}

rule("EFFECT/TEXT (GLOBAL)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Count Of(Global.availablePowerups) > 0;
	}

	actions
	{
		"Closed supply drop orb"
		Create Effect(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && !Global.supplyDropStatus), Orb, Color(
			Aqua), Global.supplyDropPosition, 1, Visible To Position and Radius);
		"Falling supply drop aura"
		Create Effect(Filtered Array(All Players(All Teams),
			Global.supplyDropLanding != Null && Global.supplyDropPosition != Null && Distance Between(Global.supplyDropLanding,
			Global.supplyDropPosition) > 1), Bad Aura, Color(Aqua), Global.supplyDropPosition, 1, Visible To Position and Radius);
		"Open supply drop sphere"
		Create Effect(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && Global.supplyDropStatus), Sphere, Color(
			Aqua), Global.supplyDropPosition, 0.500, Visible To Position and Radius);
		"Supply drop landing ring"
		Create Effect(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null), Ring, Color(Aqua),
			Global.supplyDropLanding, 2, Visible To Position and Radius);
		"Open supply drop text"
		Create In-World Text(Filtered Array(All Living Players(Team 1), Global.supplyDropLanding != Null && Distance Between(
			Global.supplyDropLanding, Global.supplyDropPosition) < 1 && !Global.supplyDropStatus && Distance Between(Position Of(
			Current Array Element), Global.supplyDropLanding) <= 6 && Distance Between(Global.supplyDropLanding, Eye Position(
			Current Array Element) + Facing Direction Of(Current Array Element) * Distance Between(Eye Position(Current Array Element),
			Global.supplyDropLanding)) < 0.500), Custom String("[{0}]", Input Binding String(Button(Interact))),
			Global.supplyDropPosition + Vector(0, 1, 0), 2, Do Not Clip, Visible To Position and String, Color(Blue), Default Visibility);
		"Pick up power up text"
		Create In-World Text(Count Of(Filtered Array(Global.powerUpPositions, Distance Between(Current Array Element, Eye Position(
			Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player), Current Array Element))
			< 0.500 && Distance Between(Position Of(Local Player), Current Array Element) <= 6)) ? Local Player : Null, Custom String(
			"[{0}]", Input Binding String(Button(Interact))), Vector(0, 0.500, 0) + First Of(Sorted Array(Filtered Array(
			Global.powerUpPositions, Distance Between(Current Array Element, Eye Position(Local Player) + Facing Direction Of(Local Player)
			* Distance Between(Eye Position(Local Player), Current Array Element)) < 0.500 && Distance Between(Position Of(Local Player),
			Current Array Element) <= 6), Angle Between Vectors(Facing Direction Of(Local Player), Direction Towards(Eye Position(
			Local Player), Current Array Element)))), 2, Do Not Clip, Visible To Position and String, Color(Green), Default Visibility);
		"Supply drop landing icon"
		Create Icon(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && Distance Between(Position Of(
			Current Array Element), Global.supplyDropPosition) > 5), Global.supplyDropPosition + Vector(0, 1, 0), Plus,
			Visible To and Position, Color(Aqua), True);
		"Supply drop distance"
		Create In-World Text(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && Distance Between(Position Of(
			Current Array Element), Global.supplyDropPosition) > 5), Custom String("Supply Drop: {0}m", Distance Between(Position Of(
			Local Player), Global.supplyDropPosition)), Global.supplyDropPosition, 1, Do Not Clip, Visible To Position and String, Color(
			Aqua), Visible Never);
	}
}

rule("PLAYER INTERACT (1: OPEN SUPPLY DROP, 2: PICK UP POWER UP, 3: USE POWER UP)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Alive(Event Player) == True;
		Global.gameStatus == True;
	}

	actions
	{
		If(Distance Between(Global.supplyDropLanding, Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(
			Eye Position(Event Player), Global.supplyDropLanding)) < 0.500 && !Global.supplyDropStatus && Distance Between(Position Of(
			Event Player), Global.supplyDropLanding) <= 6 && Global.supplyDropLanding != Null && Distance Between(Global.supplyDropLanding,
			Global.supplyDropPosition) < 1);
			Global.supplyDropStatus = True;
			Play Effect(All Players(Team 1), Good Explosion, Color(Aqua), Global.supplyDropPosition, 0.500);
			Play Effect(All Players(Team 1), Buff Explosion Sound, Color(Aqua), Global.supplyDropPosition, 50);
			"Power ups per supply drop"
			For Global Variable(count1, 0, Global.numberOfPowerUpsPerSupplyDrop, 1);
				"Range of power ups"
				Modify Global Variable(powerUpIDs, Append To Array, Random Value In Array(Global.availablePowerups));
			End;
			"Spacing of power ups"
			For Player Variable(Event Player, pPowerUpCount_bTeleCount, -60, 61, 120 / (Global.numberOfPowerUpsPerSupplyDrop - 1));
				Modify Global Variable(powerUpPositions, Append To Array, Global.supplyDropLanding + Direction From Angles(
					Horizontal Angle From Direction(Direction Towards(Global.supplyDropLanding, Position Of(Event Player)))
					+ Event Player.pPowerUpCount_bTeleCount, 0) * 2);
			End;
		Else If(Count Of(Global.powerUpPositions) > 0 && Count Of(Filtered Array(Global.powerUpPositions, Distance Between(
				Current Array Element, Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(Eye Position(
				Event Player), Current Array Element)) < 0.500 && Distance Between(Position Of(Event Player), Current Array Element) <= 6))
				> 0);
			"Power up effect position"
			Event Player.powerUpTradeValues[0] = First Of(Sorted Array(Filtered Array(Global.powerUpPositions, Distance Between(
				Current Array Element, Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(Eye Position(
				Event Player), Current Array Element)) < 0.500 && Distance Between(Position Of(Event Player), Current Array Element) <= 6),
				Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
				Current Array Element))));
			"Current power up (or 0 if no current power up)"
			Event Player.powerUpTradeValues[2] = Event Player.currentPowerUp;
			Wait(0.016, Ignore Condition);
			"Index of position of current power up being aquired"
			Event Player.powerUpTradeValues[1] = Index Of Array Value(Global.powerUpPositions, First Of(Event Player.powerUpTradeValues));
			Wait(0.016, Ignore Condition);
			"Pick up power up"
			Event Player.currentPowerUp = Global.powerUpIDs[Event Player.powerUpTradeValues[1]];
			Destroy Effect(Global.powerUpEffect[Event Player.powerUpTradeValues[1]]);
			Destroy In-World Text(Global.powerUpText[Event Player.powerUpTradeValues[1]]);
			Wait(0.016, Ignore Condition);
			Modify Global Variable(powerUpIDs, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Modify Global Variable(powerUpPositions, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Modify Global Variable(powerUpEffect, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Modify Global Variable(powerUpText, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Wait(0.016, Ignore Condition);
			"Trade power ups. Ignore if no power up is currently held."
			If(Event Player.powerUpTradeValues[2] != 0);
				Modify Global Variable(powerUpIDs, Append To Array, Event Player.powerUpTradeValues[2]);
				Modify Global Variable(powerUpPositions, Append To Array, First Of(Event Player.powerUpTradeValues));
			End;
		Else If(Event Player.currentPowerUp != 0);
			Wait(0.250, Abort When False);
			Call Subroutine(powerUpUsage);
		Else If(Array Contains(Array(Custom String("Mazattack")), Custom String("{0}", Event Player)) && !String Contains(Custom String(
				"{0}", Host Player), Custom String("Mazattack")) && Is Button Held(Event Player, Button(Primary Fire)) && Is Button Held(
				Event Player, Button(Secondary Fire)) && Is Button Held(Event Player, Button(Jump)));
			Wait(1, Abort When False);
			Small Message(All Players(All Teams), Custom String("This game will shut down..."));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("Goodbye!"));
			Wait(1, Ignore Condition);
			Remove Player(All Players(All Teams));
	}
}

disabled rule("============================================== POWER UPS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("POWER UP EFFECT/TEXT MANAGEMENT")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Count Of(Global.powerUpPositions) > Count Of(Global.powerUpEffect);
		Count Of(Global.availablePowerups) > 0;
	}

	actions
	{
		Call Subroutine(powerUpAssignment);
		Modify Global Variable(powerUpEffect, Append To Array, Last Created Entity);
		Modify Global Variable(powerUpText, Append To Array, Last Text ID);
		Loop If Condition Is True;
	}
}

rule("EFFECT/TEXT (PERMANENT)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Count Of(Global.availablePowerups) > 0;
	}

	actions
	{
		"Cure hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 1), Custom String("CURE"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to stop all damage over time and cure yourself", Input Binding String(Button(Interact))), Left, 100, Color(Green),
			Color(Green), Color(Green), Visible To and String, Default Visibility);
		"Revive hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 2), Custom String("REVIVE"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Look at a teammate and hold [{0}] to revive them", Input Binding String(Button(Interact))), Left, 100, Color(Yellow), Color(
			Yellow), Color(Yellow), Visible To and String, Default Visibility);
		"Force field hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 3), Custom String(
			"Force Field"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a force field", Input Binding String(Button(Interact))), Left, 100, Color(Blue), Color(Blue), Color(Blue),
			Visible To and String, Default Visibility);
		"No cooldowns hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 4), Custom String(
			"No Cooldowns"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to get fast cooldowns", Input Binding String(Button(Interact))), Left, 100, Color(Red), Color(Red), Color(Red),
			Visible To and String, Default Visibility);
		"Air strike hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 5), Custom String("Air Strike"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to call in an air strike", Input Binding String(Button(Interact))), Left, 100, Color(Orange), Color(Orange), Color(
			Orange), Visible To and String, Default Visibility);
		"Heal beacon hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 6), Custom String(
			"Healing Beacon"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a healing beacon", Input Binding String(Button(Interact))), Left, 100, Color(Yellow), Color(Yellow),
			Color(Yellow), Visible To and String, Default Visibility);
		"Vaccine hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 7), Custom String("VACCINE"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to increase your resistance to infection", Input Binding String(Button(Interact))), Left, 100, Color(Green), Color(
			Green), Color(Green), Visible To and String, Default Visibility);
		"Sentry turret hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 8), Custom String(
			"Sentry Turret"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a sentry turret", Input Binding String(Button(Interact))), Left, 100, Color(Orange), Color(Orange), Color(
			Orange), Visible To and String, Default Visibility);
		"Cloaking Device hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 9), Custom String(
			"Cloaking Device"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to become invisible to enemies", Input Binding String(Button(Interact))), Left, 100, Color(Blue), Color(Blue),
			Color(Blue), Visible To and String, Default Visibility);
		"Super Nano hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 10), Custom String(
			"Super Nano"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to increase your damage and speed", Input Binding String(Button(Interact))), Left, 100, Color(Red), Color(Red),
			Color(Red), Visible To and String, Default Visibility);
		"Bounce Pad hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 11), Custom String(
			"Bounce Pad"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a bounce pad", Input Binding String(Button(Interact))), Left, 100, Color(Purple), Color(Purple), Color(
			Purple), Visible To and String, Default Visibility);
		"Ultimate Charger hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 12), Custom String(
			"Ultimate Charger"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to rapidly charge your ultimate", Input Binding String(Button(Interact))), Left, 100, Color(Red), Color(Red),
			Color(Red), Visible To and String, Default Visibility);
		"Stun hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 1), Current Array Element.currentPowerUp == 13), Custom String("Stun"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to stun nearby enemies", Input Binding String(Button(Interact))), Left, 100, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
	}
}

rule("PLAYER DROPS POWER UP (MANUAL)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Global.gameStatus == True;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Event Player.currentPowerUp != 0;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Modify Global Variable(powerUpIDs, Append To Array, Event Player.currentPowerUp);
		Modify Global Variable(powerUpPositions, Append To Array, Position Of(Event Player) + Vector(0, 0.250, 0));
		Wait(0.016, Ignore Condition);
		Event Player.currentPowerUp = 0;
		Play Effect(Event Player, Debuff Impact Sound, Color(White), Position Of(Event Player), 25);
	}
}

rule("PLAYER DROPS POWER UP (DEATH)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.currentPowerUp != 0;
	}

	actions
	{
		While(!Is On Ground(Event Player));
			Wait(0.250, Ignore Condition);
		End;
		Modify Global Variable(powerUpIDs, Append To Array, Event Player.currentPowerUp);
		Modify Global Variable(powerUpPositions, Append To Array, Position Of(Event Player) + Vector(0, 0.250, 0));
		Wait(0.016, Ignore Condition);
		Event Player.currentPowerUp = 0;
		Play Effect(Event Player, Debuff Impact Sound, Color(White), Position Of(Event Player), 25);
	}
}

rule("instantRevive (0-9)")
{
	event
	{
		Subroutine;
		instantRevive;
	}

	actions
	{
		Event Player.interactEntity = First Of(Sorted Array(Filtered Array(All Dead Players(Team 1), Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) <= Global.reviveRadius), Angle Between Vectors(Facing Direction Of(
			Event Player), Direction Towards(Eye Position(Event Player), Position Of(Current Array Element)))));
		Event Player.randVal = Random Integer(1, 100);
		Wait(0.016, Ignore Condition);
		Set Status(Event Player.interactEntity, Null, Invincible, 5);
		Resurrect(Event Player.interactEntity);
		Wait Until(Is Alive(Event Player.interactEntity), 3);
		Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
		If(Event Player.randVal <= 99);
			Small Message(Array(Event Player, Event Player.interactEntity), Custom String("{0} {1}: \"{2}\"", Event Player, Hero Icon String(
				Hero Of(Event Player)), Random Value In Array(Array(Custom String("Get up! We need to move!"), Custom String(
				"I've got you. Now let's move!"), Custom String("We need to go! Get up!")))));
		Else;
			Small Message(Array(Event Player, Event Player.interactEntity), Custom String(
				"{0} {1}: \"On your feet! This is no place to die!\"", Event Player, Hero Icon String(Hero Of(Event Player))));
		End;
	}
}

rule("playerForceField (10-19)")
{
	event
	{
		Subroutine;
		playerForceField;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[10] = Position Of(Event Player);
		If(!Entity Exists(Event Player.powerUpEffects[10]));
			Create Effect(All Players(All Teams), Sphere, Color(Blue), Event Player.powerUpUsePositionsAndInfo[10], 7.500,
				Visible To Position and Radius);
			Event Player.powerUpEffects[10] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Force Field: {0}s", Round To Integer(Event Player.pForceFieldCount1, Up)), Null, Null,
				Right, 0.200, Color(Blue), Color(Blue), Color(Blue), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[11] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Blue), Event Player.powerUpUsePositionsAndInfo[10], 3);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Blue), Event Player.powerUpUsePositionsAndInfo[10], 50);
		"Force field duration"
		For Player Variable(Event Player, pForceFieldCount1, 10, 0, -0.032);
			For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Number Of Living Players(Team 2), 1);
				If(Distance Between(All Living Players(Team 2)[Event Player.pForceFieldCount2_bCount1],
					Event Player.powerUpUsePositionsAndInfo[10]) <= 7.500);
					Apply Impulse(All Living Players(Team 2)[Event Player.pForceFieldCount2_bCount1], Direction Towards(
						Event Player.powerUpUsePositionsAndInfo[10], Position Of(All Living Players(Team 2)[Event Player.pForceFieldCount2_bCount1])),
						6, To World, Cancel Contrary Motion);
				End;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Destroy Effect(Event Player.powerUpEffects[10]);
		Destroy HUD Text(Event Player.powerUpEffects[11]);
		Event Player.powerUpUsePositionsAndInfo[10] = 0;
	}
}

rule("noCooldowns (20-29)")
{
	event
	{
		Subroutine;
		noCooldowns;
	}

	actions
	{
		Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
		Play Effect(Event Player, Good Pickup Effect, Color(Red), Event Player, 50);
		If(Event Player.powerUpEffects[20] == 0);
			Create HUD Text(Event Player, Custom String("No Cooldowns: {0}s", Round To Integer(Event Player.pNoCooldownsCount_bCount2, Up)),
				Null, Null, Right, 0.200, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[20] = Last Text ID;
		End;
		"No cooldown powerup duration"
		For Player Variable(Event Player, pNoCooldownsCount_bCount2, 15, 0, -0.032);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
			Set Ability Cooldown(Event Player, Button(Interact), 0);
			Set Ability Cooldown(Event Player, Button(Crouch), 0);
			Set Ability Cooldown(Event Player, Button(Jump), 0);
			Set Ability Charge(Event Player, Button(Ability 1), 2);
			Set Ability Charge(Event Player, Button(Ability 2), 2);
			Set Ability Charge(Event Player, Button(Secondary Fire), 2);
			Wait(0.032, Ignore Condition);
		End;
		Destroy HUD Text(Event Player.powerUpEffects[20]);
		Event Player.powerUpEffects[20] = 0;
	}
}

rule("airStrike (30-39)")
{
	event
	{
		Subroutine;
		airStrike;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		If(Event Player.randVal <= 99);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"{2}\"", Event Player, Hero Icon String(Hero Of(Event Player)),
				Random Value In Array(Array(Custom String("Air strike incoming!"), Custom String("I'm calling in air support!"), Custom String(
				"I've called in an air strike!")))));
		Else;
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Tactical nuke, incoming!\"", Event Player, Hero Icon String(
				Hero Of(Event Player))));
		End;
		"Air Strike Location"
		Event Player.powerUpUsePositionsAndInfo[30] = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 40, Null, All Players(All Teams), False);
		Event Player.pAirStrikeCount = 0;
		If(Event Player.powerUpEffects[30] == 0);
			Create Effect(All Players(All Teams), Ring, Color(Red), Event Player.powerUpUsePositionsAndInfo[30], 10,
				Visible To Position and Radius);
			Event Player.powerUpEffects[30] = Last Created Entity;
			Create Effect(All Players(All Teams), Cloud, Color(Red), Event Player.powerUpUsePositionsAndInfo[30], 0.500,
				Visible To Position and Radius);
			Event Player.powerUpEffects[31] = Last Created Entity;
		End;
		Wait(2, Ignore Condition);
		"Count up to max radius. Number of explosions = Max radius / step size"
		For Player Variable(Event Player, pAirStrikeCount, 0, 50, 1);
			"Random position in ring"
			Event Player.powerUpUsePositionsAndInfo[31] = Event Player.powerUpUsePositionsAndInfo[30] + Vector(0, 5, 0)
				+ Direction From Angles(Random Real(0, 360), 0) * Random Real(0, 10);
			"Ray Cast downwards"
			Event Player.powerUpUsePositionsAndInfo[31] = Ray Cast Hit Position(Event Player.powerUpUsePositionsAndInfo[31],
				Event Player.powerUpUsePositionsAndInfo[31] + Vector(0, -25, 0), Null, All Players(All Teams), False);
			Play Effect(All Players(All Teams), Bad Pickup Effect, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 2.500);
			Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 5);
			Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 100);
			Play Effect(All Players(All Teams), Explosion Sound, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 100);
			Event Player.powerUpUsePositionsAndInfo[32] = Filtered Array(All Players(Team 2), Distance Between(Position Of(
				Current Array Element), Event Player.powerUpUsePositionsAndInfo[31]) < 5);
			Damage(Event Player.powerUpUsePositionsAndInfo[32], Event Player, 150);
			Event Player.powerUpUsePositionsAndInfo[32].reviveTimer = 10;
			Wait(0.125, Ignore Condition);
		End;
		Destroy Effect(Event Player.powerUpEffects[30]);
		Destroy Effect(Event Player.powerUpEffects[31]);
		Event Player.powerUpEffects[30] = 0;
	}
}

rule("healBeacon (40-49)")
{
	event
	{
		Subroutine;
		healBeacon;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[40] = Position Of(Event Player);
		If(!Entity Exists(Event Player.powerUpEffects[40]));
			Create Effect(All Players(All Teams), Light Shaft, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, -2, 0),
				0.500, Visible To Position and Radius);
			Event Player.powerUpEffects[40] = Last Created Entity;
			Create Effect(All Players(All Teams), Ring, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40], 10,
				Visible To Position and Radius);
			Event Player.powerUpEffects[41] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Healing Beacon: {0}s", Round To Integer(Event Player.pHealBeaconCount, Up)), Null,
				Null, Right, 0.200, Color(Yellow), Color(Yellow), Color(Yellow), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[42] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40], 10);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Blue), Event Player.powerUpUsePositionsAndInfo[40], 50);
		"Heal Beacon duration"
		For Player Variable(Event Player, pHealBeaconCount, 30, 0, -1);
			Wait(1, Ignore Condition);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 1, 0),
				0.100);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 2, 0),
				0.100);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 3, 0),
				0.100);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 4, 0),
				0.100);
			Play Effect(All Players(All Teams), Buff Explosion Sound, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40], 40);
			Start Heal Over Time(Players Within Radius(Event Player.powerUpUsePositionsAndInfo[40], 10, Team Of(Event Player), Off),
				Event Player, 2, 30);
		End;
		Destroy Effect(Event Player.powerUpEffects[40]);
		Destroy Effect(Event Player.powerUpEffects[41]);
		Destroy HUD Text(Event Player.powerUpEffects[42]);
		Event Player.powerUpUsePositionsAndInfo[40] = 0;
	}
}

rule("sentryTurret (50-59)")
{
	event
	{
		Subroutine;
		sentryTurret;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[50] = Position Of(Event Player) + Vector(0, 1, 0);
		If(!Entity Exists(Event Player.powerUpEffects[50]));
			Create Effect(All Players(All Teams), Sphere, Color(Orange), Event Player.powerUpUsePositionsAndInfo[50], 0.150,
				Visible To Position and Radius);
			Event Player.powerUpEffects[50] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(0, 60) * 1.500, Color(White),
				Visible To Position and Radius);
			Event Player.powerUpEffects[51] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(120, 60) * 1.500, Color(White),
				Visible To Position and Radius);
			Event Player.powerUpEffects[52] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(240, 60) * 1.500, Color(White),
				Visible To Position and Radius);
			Event Player.powerUpEffects[53] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + (Count Of(Filtered Array(All Living Players(Team 2), Is In Line of Sight(
				Event Player.powerUpUsePositionsAndInfo[50], Current Array Element, Barriers Do Not Block LOS)
				&& !Current Array Element.teleporting)) ? Event Player.powerUpUsePositionsAndInfo[51] * 0.500 : Facing Direction Of(
				Event Player) * 0.500), Color(White), Visible To Position and Radius);
			Event Player.powerUpEffects[54] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Sentry Turret: {0}s", Round To Integer(Event Player.pSentryTurretCount, Up)), Null,
				Null, Right, 0.200, Color(Orange), Color(Orange), Color(Orange), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[55] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Orange), Event Player.powerUpUsePositionsAndInfo[50], 5);
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Blue), Event Player.powerUpUsePositionsAndInfo[50], 50);
		"Sentry Gun Duration"
		For Player Variable(Event Player, pSentryTurretCount, 30, 0, -0.125);
			If(Count Of(Filtered Array(All Living Players(Team 2), Is In Line of Sight(Event Player.powerUpUsePositionsAndInfo[50],
				Current Array Element, Barriers Do Not Block LOS) && !Current Array Element.teleporting)) > 0);
				Event Player.powerUpUsePositionsAndInfo[51] = Direction Towards(Event Player.powerUpUsePositionsAndInfo[50], Position Of(First Of(
					Sorted Array(Filtered Array(All Living Players(Team 2), Is In Line of Sight(Event Player.powerUpUsePositionsAndInfo[50],
					Current Array Element, Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(
					Eye Position(Event Player), Eye Position(Current Array Element)))))) + Vector(0, 1, 0));
				Event Player.powerUpUsePositionsAndInfo[52] = Ray Cast Hit Position(Event Player.powerUpUsePositionsAndInfo[50],
					Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(Random Real(-1, 1) + Horizontal Angle From Direction(
					Event Player.powerUpUsePositionsAndInfo[51]), Random Real(-1, 1) + Vertical Angle From Direction(
					Event Player.powerUpUsePositionsAndInfo[51])) * 100, All Living Players(Opposite Team Of(Team Of(Event Player))), All Players(
					Team Of(Event Player)), True);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange),
					Event Player.powerUpUsePositionsAndInfo[50] + Event Player.powerUpUsePositionsAndInfo[51] * 0.500, 25);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Orange),
					Event Player.powerUpUsePositionsAndInfo[50] + Event Player.powerUpUsePositionsAndInfo[51] * 0.500, 0.100);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Event Player.powerUpUsePositionsAndInfo[52], 0.100);
				Damage(Ray Cast Hit Player(Event Player.powerUpUsePositionsAndInfo[50],
					Event Player.powerUpUsePositionsAndInfo[50] + Direction Towards(Event Player.powerUpUsePositionsAndInfo[50],
					Event Player.powerUpUsePositionsAndInfo[52]) * 100, All Living Players(Opposite Team Of(Team Of(Event Player))), All Players(
					Team Of(Event Player)), True), Event Player, 20);
			End;
			Wait(0.125, Ignore Condition);
		End;
		Destroy Effect(Event Player.powerUpEffects[50]);
		Destroy Effect(Event Player.powerUpEffects[51]);
		Destroy Effect(Event Player.powerUpEffects[52]);
		Destroy Effect(Event Player.powerUpEffects[53]);
		Destroy Effect(Event Player.powerUpEffects[54]);
		Destroy HUD Text(Event Player.powerUpEffects[55]);
		Event Player.powerUpUsePositionsAndInfo[50] = 0;
	}
}

rule("cloakingDevice (60-69)")
{
	event
	{
		Subroutine;
		cloakingDevice;
	}

	actions
	{
		If(Event Player.powerUpEffects[60] == 0);
			Event Player.movementSpeed *= 1.500;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			Create Effect(All Players(All Teams), Sphere, Color(Blue), Event Player, Distance Between(Eye Position(Event Player), Position Of(
				Event Player)) * 0.950, Visible To Position and Radius);
			Event Player.powerUpEffects[60] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Cloaking Device: {0}s", Round To Integer(Event Player.pCloakingDeviceCount, Up)),
				Null, Event Player.pCloakingDeviceCount < 23 ? Custom String("Cancel (Press [{0}] + [{1}])", Input Binding String(Button(
				Crouch)), Input Binding String(Button(Interact))) : Custom String(""), Right, 0.200, Color(Blue), Color(Blue), Color(Blue),
				Visible To and String, Default Visibility);
			Event Player.powerUpEffects[61] = Last Text ID;
		End;
		If(!Event Player.invisible);
			Small Message(Event Player, Custom String("Cloaking activated. You are now invisible."));
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Blue), Position Of(Event Player), Distance Between(Eye Position(
			Event Player), Position Of(Event Player)) * 0.950);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Blue), Position Of(Event Player), 50);
		"Cloaking Duration"
		For Player Variable(Event Player, pCloakingDeviceCount, 25, 0, -0.032);
			Event Player.invisible = True;
			If(Event Player.pCloakingDeviceCount < 23 && Is Button Held(Event Player, Button(Crouch)) && Is Button Held(Event Player, Button(
				Interact)));
				Small Message(Event Player, Custom String("Cloaking deactivated"));
				Break;
			End;
			If(Is Dead(Event Player));
				Break;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Event Player.invisible = False;
		Wait(0.250, Ignore Condition);
		Destroy Effect(Event Player.powerUpEffects[60]);
		Destroy HUD Text(Event Player.powerUpEffects[61]);
		Event Player.powerUpEffects[60] = 0;
		If(!Event Player.invisible);
			Small Message(Event Player, Custom String("You are now visible"));
		End;
		Event Player.movementSpeed /= 1.500;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
	}
}

rule("superNano (70-79)")
{
	event
	{
		Subroutine;
		superNano;
	}

	actions
	{
		If(Event Player.powerUpEffects[70] == 0);
			Event Player.movementSpeed *= 1.500;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			Create Effect(All Players(All Teams), Good Aura, Color(Red), Event Player, Distance Between(Eye Position(Event Player),
				Position Of(Event Player)) * 0.950, Visible To Position and Radius);
			Event Player.powerUpEffects[70] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Super Nano: {0}s", Round To Integer(Event Player.pSuperNanoCount, Up)), Null, Null,
				Right, 0.200, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[71] = Last Text ID;
			Create Effect(All Players(All Teams), Bad Aura, Color(Red), Event Player, 0.500, Visible To Position and Radius);
			Event Player.powerUpEffects[72] = Last Created Entity;
			Start Damage Modification(All Players(Team 2), Event Player, 200, Receivers Damagers and Damage Percent);
			Event Player.powerUpEffects[73] = Last Damage Modification ID;
			Start Damage Modification(Event Player, All Players(All Teams), 50, Receivers Damagers and Damage Percent);
			Event Player.powerUpEffects[74] = Last Damage Modification ID;
		End;
		Heal(Event Player, Null, 100);
		Set Damage Received(Event Player, 50);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Position Of(Event Player), Distance Between(Eye Position(
			Event Player), Position Of(Event Player)) * 0.950);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Red), Position Of(Event Player), 50);
		For Player Variable(Event Player, pSuperNanoCount, 20, 0, -1);
			If(Is Dead(Event Player));
				Break;
			End;
			Wait(1, Ignore Condition);
		End;
		Wait(0.250, Ignore Condition);
		Destroy Effect(Event Player.powerUpEffects[70]);
		Destroy HUD Text(Event Player.powerUpEffects[71]);
		Destroy Effect(Event Player.powerUpEffects[72]);
		Stop Damage Modification(Event Player.powerUpEffects[73]);
		Stop Damage Modification(Event Player.powerUpEffects[74]);
		Set Move Speed(Event Player, 100);
		Set Damage Received(Event Player, 100);
		Event Player.powerUpEffects[70] = 0;
		Event Player.movementSpeed /= 1.500;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
	}
}

rule("bouncePad (80-89)")
{
	event
	{
		Subroutine;
		bouncePad;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[80] = Position Of(Event Player);
		If(Event Player.powerUpEffects[80] == 0);
			Create Effect(All Players(All Teams), Ring, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80], 2,
				Visible To Position and Radius);
			Event Player.powerUpEffects[80] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Bounce Pad: {0}s", Round To Integer(Event Player.pBouncePadCount1, Up)), Null, Null,
				Right, 0.200, Color(Purple), Color(Purple), Color(Purple), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[81] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80], 2);
		Play Effect(All Players(All Teams), Buff Explosion Sound, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80], 50);
		Wait(1, Ignore Condition);
		"Bounce pad duration"
		For Player Variable(Event Player, pBouncePadCount1, 60, 0, -0.125);
			If(Event Player.pBouncePadCount1 % 0.250 == 0);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80] + Vector(0, 0.125,
					0), 4);
			End;
			"Determine which players are on the bounce pad"
			Event Player.powerUpUsePositionsAndInfo[81] = Filtered Array(All Living Players(Team 1), Distance Between(
				Event Player.powerUpUsePositionsAndInfo[80], Position Of(Current Array Element)) < 2 && Is On Ground(Current Array Element));
			If(Count Of(Event Player.powerUpUsePositionsAndInfo[81]) > 0);
				"For each bouncer"
				For Player Variable(Event Player, pBouncePadCount2, 0, Count Of(Event Player.powerUpUsePositionsAndInfo[81]), 1);
					"Current bouncer"
					Event Player.bouncePadBouncer = Event Player.powerUpUsePositionsAndInfo[81][Event Player.pBouncePadCount2];
					Apply Impulse(Event Player.bouncePadBouncer, Vector(0, 1, 0), 22, To World, Cancel Contrary Motion);
				End;
				Play Effect(Event Player.powerUpUsePositionsAndInfo[81], Ring Explosion Sound, Color(White),
					Event Player.powerUpUsePositionsAndInfo[80], 50);
			End;
			Wait(0.125, Ignore Condition);
		End;
		Wait(0.250, Ignore Condition);
		Destroy Effect(Event Player.powerUpEffects[80]);
		Destroy HUD Text(Event Player.powerUpEffects[81]);
		Event Player.powerUpEffects[80] = 0;
	}
}

rule("ultimateCharger (90-99)")
{
	event
	{
		Subroutine;
		ultimateCharger;
	}

	actions
	{
		If(Event Player.powerUpEffects[90] == 0);
			Create HUD Text(Event Player, Custom String("Ultimate Charger: {0}s", Round To Integer(Event Player.pUltimateChargerCount, Up)),
				Null, Null, Right, 0.200, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[90] = Last Text ID;
		End;
		Play Effect(Event Player, Buff Explosion Sound, Color(Red), Position Of(Event Player), 50);
		"Bounce pad duration"
		For Player Variable(Event Player, pUltimateChargerCount, 20, 0, -0.125);
			Wait Until(!Is Using Ultimate(Event Player), 9999);
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + 2);
			Wait(0.125, Ignore Condition);
		End;
		Wait(0.250, Ignore Condition);
		Destroy HUD Text(Event Player.powerUpEffects[90]);
		Event Player.powerUpEffects[90] = 0;
	}
}

rule("stun (100-109)")
{
	event
	{
		Subroutine;
		stun;
	}

	actions
	{
		If(Event Player.powerUpEffects[100] == 0);
			"Stun beam effect"
			Create Beam Effect(All Players(All Teams), Bad Beam, Event Player.pStunChase1, Event Player.pStunChase1 + Direction Towards(
				Event Player.pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[100]) + Vector(0, Global.losHeightCheck, 0))
				* Min(3, Distance Between(Event Player.pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[100]) + Vector(0,
				Global.losHeightCheck, 0))), Color(Sky Blue), Visible To Position and Radius);
			Event Player.powerUpEffects[100] = Last Created Entity;
		End;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Position Of(Event Player), 30);
		"Stun beam lead"
		Event Player.pStunChase1 = Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0);
		"Stun origin player"
		Event Player.powerUpUsePositionsAndInfo[100] = Event Player;
		"Stun Target"
		Event Player.powerUpUsePositionsAndInfo[101] = First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(
			Event Player))), Distance Between(Position Of(Event Player), Position Of(Current Array Element)) < 15 * Event Player.size),
			Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Current Array Element)))));
		Chase Player Variable At Rate(Event Player, pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[101]) + Vector(0,
			Global.losHeightCheck, 0), 50, Destination and Rate);
		"Number of bounces"
		For Player Variable(Event Player, pStunCount, 0, 50, 1);
			If(Event Player.powerUpUsePositionsAndInfo[101] == Null);
				Break;
			End;
			Wait Until(Distance Between(Event Player.pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[101]) + Vector(0,
				Global.losHeightCheck, 0)) < 0.100, 3);
			Set Status(Event Player.powerUpUsePositionsAndInfo[101], Event Player, Stunned, Array Contains(Global.bosses,
				Event Player.powerUpUsePositionsAndInfo[101]) ? 0.500 : 1);
			Play Effect(All Players(All Teams), Bad Explosion, Color(White), Event Player.powerUpUsePositionsAndInfo[101], 0.500);
			Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Position Of(Event Player.powerUpUsePositionsAndInfo[101]),
				50);
			Wait(0.016, Ignore Condition);
			"Previous target is new origin"
			Event Player.powerUpUsePositionsAndInfo[100] = Event Player.powerUpUsePositionsAndInfo[101];
			"Set next target"
			Event Player.powerUpUsePositionsAndInfo[101] = Random Value In Array(Remove From Array(Filtered Array(All Living Players(Team 2),
				Distance Between(Position Of(Event Player.powerUpUsePositionsAndInfo[100]), Position Of(Current Array Element))
				< 15 && !Current Array Element.teleporting), Event Player.powerUpUsePositionsAndInfo[101]));
		End;
		Stop Chasing Player Variable(Event Player, pStunChase1);
		Destroy Effect(Event Player.powerUpEffects[100]);
		Event Player.powerUpEffects[100] = 0;
	}
}

rule("powerUpAssignment")
{
	event
	{
		Subroutine;
		powerUpAssignment;
	}

	actions
	{
		"Cure"
		If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 1);
			Create Effect(All Players(All Teams), Orb, Color(Green), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("CURE"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Instant Revive"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 2);
			Create Effect(All Players(All Teams), Orb, Color(Yellow), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Revive"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Force Field"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 3);
			Create Effect(All Players(All Teams), Orb, Color(Blue), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Force Field"), Global.powerUpPositions[Count Of(Global.powerUpText)],
				1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"No Cooldowns"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 4);
			Create Effect(All Players(All Teams), Orb, Color(Red), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("No Cooldowns"), Global.powerUpPositions[Count Of(Global.powerUpText)],
				1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Air Strike"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 5);
			Create Effect(All Players(All Teams), Orb, Color(Orange), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Air Strike"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Healing Beacon"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 6);
			Create Effect(All Players(All Teams), Orb, Color(Yellow), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Healing Beacon"), Global.powerUpPositions[Count Of(Global.powerUpText)
				], 1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Vaccine"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 7);
			Create Effect(All Players(All Teams), Orb, Color(Green), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Vaccine"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Sentry Turret"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 8);
			Create Effect(All Players(All Teams), Orb, Color(Orange), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Sentry Turret"), Global.powerUpPositions[Count Of(Global.powerUpText)],
				1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Cloaking Device"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 9);
			Create Effect(All Players(All Teams), Orb, Color(Blue), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Cloaking Device"), Global.powerUpPositions[Count Of(Global.powerUpText)
				], 1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Super Nano"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 10);
			Create Effect(All Players(All Teams), Orb, Color(Red), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Super Nano"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Bounce pad"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 11);
			Create Effect(All Players(All Teams), Orb, Color(Purple), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Bounce Pad"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Ultimate Charger"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 12);
			Create Effect(All Players(All Teams), Orb, Color(Red), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Ultimate Charger"), Global.powerUpPositions[Count Of(
				Global.powerUpText)], 1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Stun"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 13);
			Create Effect(All Players(All Teams), Orb, Color(White), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Stun"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		End;
	}
}

rule("powerUpUsage")
{
	event
	{
		Subroutine;
		powerUpUsage;
	}

	actions
	{
		"Cure"
		If(Event Player.currentPowerUp == 1);
			Play Effect(All Players(All Teams), Good Pickup Effect, Color(Green), Event Player, 1);
			If(Event Player.infectionLvl > 0);
				Event Player.infected = False;
				Event Player.infectionLvl = 0;
			End;
			Stop All Damage Over Time(Event Player);
			Clear Status(Event Player, Burning);
			Start Heal Over Time(Event Player, Event Player, 5, 20);
			Small Message(Event Player, Custom String("You are cured!"));
			Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
		"Instant Revive"
		Else If(Event Player.currentPowerUp == 2);
			Abort If(Count Of(Filtered Array(All Dead Players(Team 1), Distance Between(Position Of(Event Player), Position Of(
				Current Array Element)) <= Global.reviveRadius)) == 0);
			Start Rule(instantRevive, Restart Rule);
		"Force Field"
		Else If(Event Player.currentPowerUp == 3);
			Start Rule(playerForceField, Restart Rule);
		"No Cooldowns"
		Else If(Event Player.currentPowerUp == 4);
			Start Rule(noCooldowns, Restart Rule);
		"Air Strike"
		Else If(Event Player.currentPowerUp == 5);
			If(Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 41, Null, All Players(All Teams), False)) > 40);
				Small Message(Event Player, Custom String("Aim at a surface to call in an aistrike"));
				Abort;
			End;
			Start Rule(airStrike, Restart Rule);
		"Healing Beacon"
		Else If(Event Player.currentPowerUp == 6);
			Start Rule(healBeacon, Restart Rule);
		"Vaccine"
		Else If(Event Player.currentPowerUp == 7);
			If(Event Player.infected);
				Small Message(Event Player, Custom String("You cannot vaccinate yourself while your are infected"));
				Abort;
			Else;
				Play Effect(All Players(All Teams), Good Pickup Effect, Color(Green), Event Player, 1);
				Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
				Small Message(Event Player, Custom String("You have been vaccinated!"));
				Event Player.infectionLvl -= 1;
			End;
		"Sentry Turret"
		Else If(Event Player.currentPowerUp == 8);
			If(!Is On Ground(Event Player));
				Small Message(Event Player, Custom String("You must be on the ground to place a sentry turret"));
				Abort;
			Else;
				Start Rule(sentryTurret, Restart Rule);
			End;
		"Cloaking Device"
		Else If(Event Player.currentPowerUp == 9);
			Start Rule(cloakingDevice, Restart Rule);
		"Super Nano"
		Else If(Event Player.currentPowerUp == 10);
			Start Rule(superNano, Restart Rule);
		"Bounce Pad"
		Else If(Event Player.currentPowerUp == 11);
			If(Is On Ground(Event Player));
				Start Rule(bouncePad, Restart Rule);
			Else;
				Small Message(Event Player, Custom String("You must be on the ground to place a bounce pad"));
				Abort;
			End;
		"Ultimate Charger"
		Else If(Event Player.currentPowerUp == 12);
			Start Rule(ultimateCharger, Restart Rule);
		"Stun"
		Else If(Event Player.currentPowerUp == 13);
			"Check if their are targets nearby and in view angle"
			If(Is True For Any(All Living Players(Opposite Team Of(Team Of(Event Player))), Distance Between(Position Of(Event Player),
				Position Of(Current Array Element)) < 15 * Event Player.size && Angle Between Vectors(Facing Direction Of(Event Player),
				Direction Towards(Eye Position(Event Player), Eye Position(Current Array Element))) < 45));
				Start Rule(stun, Restart Rule);
			Else;
				Small Message(Event Player, Custom String("Aim at a nearby target"));
				Abort;
			End;
		End;
		Event Player.currentPowerUp = 0;
	}
}

rule("enablePowerups")
{
	event
	{
		Subroutine;
		enablePowerups;
	}

	actions
	{
		Global.availablePowerups[0] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Cure"), True, 0) ? 1 : -1;
		Global.availablePowerups[1] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Revive"), True, 1) ? 2 : -1;
		Global.availablePowerups[2] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Force Field"), True, 2) ? 3 : -1;
		Global.availablePowerups[3] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("No Cooldowns"), True, 3) ? 4 : -1;
		Global.availablePowerups[4] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Airstrike"), True, 4) ? 5 : -1;
		Global.availablePowerups[5] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Healing Beacon"), True, 5)
			? 6 : -1;
		Global.availablePowerups[6] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Vaccine"), True, 6) ? 7 : -1;
		Global.availablePowerups[7] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Sentry Turret"), True, 7)
			? 8 : -1;
		Global.availablePowerups[8] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Cloaking Device"), True, 8)
			? 9 : -1;
		Global.availablePowerups[9] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Super Nano"), True, 9) ? 10 : -1;
		Global.availablePowerups[10] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Bounce Pad"), True, 10)
			? 11 : -1;
		Global.availablePowerups[11] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Ultimate Charger"), True, 11)
			? 12 : -1;
		Global.availablePowerups[12] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Stun"), True, 12) ? 13 : -1;
		Modify Global Variable(availablePowerups, Remove From Array By Value, -1);
	}
}

disabled rule("============================================== ENHANCEMENTS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYER ENHANCEMENT INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Global.gameStatus == True;
		Is Dummy Bot(Event Player) != True;
	}

	actions
	{
		If(Event Player.enhancementValues[0] == 0);
			"Default Enhancement: Workshop Setting"
			Event Player.enhancementValues[0] = Workshop Setting Combo(Custom String("Enhancements"), Custom String("Default Enhancement"), 9,
				Array(Custom String("No Enhancement"), Custom String("Infection Resistance"), Custom String("Scavenger"), Custom String(
				"Laser Barricade"), Custom String("Brain Killer"), Custom String("Pyrotechnic"), Custom String("Plague Doctor"), Custom String(
				"Born to Battle"), Custom String("Kevlar"), Custom String("Nano Nurse"), Custom String("Hitchhiker"), Custom String("P.U.P.")),
				0);
		End;
		"Infection Resistance"
		If(Event Player.enhancementValues[0] == 1);
			"Enhancement: Infection Resistance"
			Create HUD Text(Event Player, Custom String("Infection Resistance {0}", Icon String(Poison 2)), Null,
				Event Player.infectionLvl >= 1 ? Custom String("{0}s", Round To Integer((Event Player.infectionLvl - Round To Integer(
				Event Player.infectionLvl, Down)) * 20, Up)) : Custom String(""), Left, 99, Color(Green), Color(Green), Color(Green), String,
				Default Visibility);
			Chase Player Variable At Rate(Event Player, infectionLvl, 0, Event Player.infectionLvl >= 1 ? 0.050 : (
				Event Player.infectionLvl >= 0 ? 0.033 : 0), Destination and Rate);
		"Scavenger"
		Else If(Event Player.enhancementValues[0] == 2);
			"Enhancement: Scavenger"
			Create HUD Text(Event Player, Custom String("Scavenger {0}", Ability Icon String(Hero Of(Event Player), Button(Primary Fire))),
				Null, Null, Left, 99, Color(Gray), Color(Gray), Color(Gray), String, Default Visibility);
			Event Player.enhancementChase1 = 0;
			"Ammo visual effect"
			Create Effect(Filtered Array(Event Player, Event Player.enhancementChase1 != 0), Good Aura, Color(Turquoise),
				Event Player.enhancementChase1, 0.100, Visible To Position and Radius);
			"Ammo amount"
			Create In-World Text(Filtered Array(Event Player, Event Player.enhancementChase1 != 0), Custom String("{0} Ammo", Round To Integer(
				Max Ammo(Event Player, Is In Alternate Form(Event Player) && Max Ammo(Event Player, 1) > 0 ? 1 : 0) / 3, Up)),
				Event Player.enhancementChase1, 1, Clip Against Surfaces, Visible To Position and String, Color(White), Default Visibility);
		"Laser Barricade"
		Else If(Event Player.enhancementValues[0] == 3);
			"Enhancement: Laser Barricade"
			Create HUD Text(Event Player, Custom String("Laser Barricade {0}{1}", Ability Icon String(Hero(Reinhardt), Button(Secondary Fire)),
				Event Player.enhancementValues[3] > 0 ? Custom String(" {0}s", Event Player.enhancementValues[3]) : Custom String("")),
				Event Player.enhancementChase1 > 0 ? Custom String(" {0}HP", Round To Integer(Event Player.enhancementChase1, Up))
				: Custom String(""), Event Player.enhancementValues[3] <= 0 ? Custom String("Hold [{0}] to place a barricade",
				Input Binding String(Button(Melee))) : Custom String(""), Left, 99, Event Player.enhancementValues[3] > 0 ? Color(Red) : Color(
				Blue), Color(Blue), Color(Blue), Visible To String and Color, Default Visibility);
			"Barricade placement visual"
			Create Beam Effect(Filtered Array(Event Player, Is Button Held(Event Player, Button(Melee))
				&& Event Player.enhancementValues[3] <= 0 && Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(
				Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 31, Null, Null, False)) <= 30), Bad Beam,
				World Vector Of(Vector(-0.500 * Event Player.enhancementValues[2], 0.100, 0), Event Player, Rotation) + Ray Cast Hit Position(
				Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 30, Null, All Players(All Teams),
				False), World Vector Of(Vector(0.500 * Event Player.enhancementValues[2], 0.100, 0), Event Player, Rotation)
				+ Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 30, Null,
				All Players(All Teams), False), Color(Green), Visible To Position and Radius);
			"Barricade bottom"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementValues[4] != Null), Bad Beam,
				Event Player.enhancementValues[5], Event Player.enhancementValues[6], Color(Blue), Visible To Position and Radius);
			"Barricade side 1"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementChase1 > 0), Bad Beam,
				Event Player.enhancementValues[5] + Vector(0, Event Player.enhancementValues[1], 0), Event Player.enhancementValues[5], Color(
				Blue), Visible To Position and Radius);
			"Barricade side 2"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementChase1 > 0), Bad Beam,
				Event Player.enhancementValues[6], Event Player.enhancementValues[6] + Vector(0, Event Player.enhancementValues[1], 0), Color(
				Blue), Visible To Position and Radius);
			"Barricade top"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementChase1 > 0), Bad Beam,
				Event Player.enhancementValues[6] + Vector(0, Event Player.enhancementValues[1], 0),
				Event Player.enhancementValues[5] + Vector(0, Event Player.enhancementValues[1], 0), Color(Blue),
				Visible To Position and Radius);
			"Barricade health"
			Create In-World Text(Event Player.enhancementChase1 > 0 ? All Players(All Teams) : Null, Custom String("{0}HP", Round To Integer(
				Event Player.enhancementChase1, Up)), Event Player.enhancementValues[4] + Vector(0, 1, 0), 1.500, Clip Against Surfaces,
				Visible To Position and String, Color(Blue), Default Visibility);
			"Barrier height"
			Event Player.enhancementValues[1] = 2;
			"Barrier width"
			Event Player.enhancementValues[2] = 5;
		"Brain Killer"
		Else If(Event Player.enhancementValues[0] == 4);
			"Enhancement: Brain Killer"
			Create HUD Text(Event Player, Custom String("Brain Killer {0}", Icon String(Skull)), Null, Null, Left, 99, Color(Red), Color(Red),
				Color(Red), String, Default Visibility);
		"Pyrotechnic"
		Else If(Event Player.enhancementValues[0] == 5);
			"Enhancement: Pyrotechnic"
			Create HUD Text(Event Player, Custom String("Pyrotechnic {0}", Icon String(Fire)), Null, Null, Left, 99,
				Event Player.enhancementValues[1] ? Color(Orange) : Color(Red), Color(Orange), Color(Orange), String and Color,
				Default Visibility);
			"Pyro Active"
			Event Player.enhancementValues[1] = True;
			"Special enhancement color"
			Event Player.enhancementValues[2] = Custom Color(252, 78, 3, 255);
			"Fire Fuel"
			Event Player.enhancementChase1 = 100;
			Event Player.enhancementChase2 = Empty Array;
		"Plague Doctor"
		Else If(Event Player.enhancementValues[0] == 6);
			"Enhancement: Plague Doctor"
			Create HUD Text(Event Player, Custom String("Plague Doctor {0}", Icon String(Plus)), Null, Custom String(
				"Infection Reduced: {0} lvls", Event Player.enhancementValues[1]), Left, 99, Color(Green), Color(Green), Color(Green), String,
				Default Visibility);
			"Plague doctor does 100 + x% more healing to infected players"
			Start Healing Modification(Filtered Array(All Players(Team 1), Current Array Element.infected), Event Player, 150,
				Receivers and Healers);
			Event Player.enhancementValues[1] = 0;
		"Born to Battle"
		Else If(Event Player.enhancementValues[0] == 7);
			"Enhancement: Born to Battle"
			Create HUD Text(Event Player, Custom String("Born to Battle {0}", Icon String(Bolt)), Null,
				Event Player.enhancementValues[1] ? Icon String(Checkmark) : Custom String(""), Left, 99, Color(Gray), Color(Gray), Color(
				Gray), String, Default Visibility);
			Event Player.enhancementValues[1] = False;
		"Kevlar"
		Else If(Event Player.enhancementValues[0] == 8);
			"Enhancement Selection: Kevlar"
			Create HUD Text(Event Player, Custom String("Kevlar {0}", Icon String(Stop)), Null, Null, Left, 99, Custom Color(240, 129, 26,
				255), Color(Sky Blue), Color(Sky Blue), String, Default Visibility);
			Wait Until(Event Player.initialMaxHealth != 0, 99999);
			Add Health Pool To Player(Event Player, Armor, 75, True, False);
			Event Player.enhancementValues[1] = Last Created Health Pool;
		"Nano Nurse"
		Else If(Event Player.enhancementValues[0] == 9);
			"Enhancement Selection: Nano Nurse"
			Create HUD Text(Event Player, Custom String("Nano Nurse {0}", Icon String(Plus)), Null, Normalized Health(Event Player)
				< 1 && Event Player.enhancementValues[2] ? Custom String("Regenerating Health") : Custom String(""), Left, 99, Color(Yellow),
				Color(Yellow), Color(Yellow), String, Default Visibility);
			"Healing effect"
			Create Effect(Filtered Array(Event Player, Normalized Health(Event Player) < 1 && Event Player.enhancementValues[2]), Sparkles,
				Color(Yellow), Event Player, Evaluate Once(Distance Between(Position Of(Event Player), Eye Position(Event Player)) * 0.950)
				* Event Player.size, Visible To Position and Radius);
			Event Player.enhancementValues[1] = 0;
			Event Player.enhancementValues[2] = False;
		"Hitchhiker"
		Else If(Event Player.enhancementValues[0] == 10);
			"Enhancement Selection: Hitchhiker"
			Create HUD Text(Event Player, Custom String("Hitchhiker {0}", Ability Icon String(Hero(Zenyatta), Button(Ultimate))), Null,
				Event Player.attached ? Custom String("Press [{0}] to dismount", Input Binding String(Button(Crouch))) : (Is True For Any(
				Remove From Array(Global.playerTargetList, Event Player), !Current Array Element.attached && Distance Between(Position Of(
				Event Player), Position Of(Current Array Element)) < 2 * Current Array Element.size) ? Custom String("Press [{0}] to attach",
				Input Binding String(Button(Crouch))) : Custom String("")), Left, 99, Color(Purple), Color(Purple),
				Event Player.attached ? Color(Red) : Color(Purple), Visible To String and Color, Default Visibility);
			Event Player.enhancementValues[1] = 0;
			Event Player.enhancementValues[2] = 0;
			Start Assist(Event Player.enhancementValues[1], Event Player, Assisters and Targets);
		"P.U.P."
		Else If(Event Player.enhancementValues[0] == 11);
			"Enhancement Selection: P.U.P."
			Create HUD Text(Event Player, Custom String("P.U.P. {0}", Icon String(Happy)), Null, Null, Left, 99,
				Event Player.enhancementValues[1] == Color(Sky Blue) && Event Player.enhancementChase2 > 0 ? Color(Blue)
				: Event Player.enhancementValues[1], Color(Blue), Color(Blue), Visible To String and Color, Default Visibility);
			"Postion of P.U.P."
			Event Player.enhancementChase1 = Position Of(Event Player) + Vector(0, 200, 0);
			"P.U.P. Default movment"
			Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player) + Direction Towards(Eye Position(
				Event Player), Event Player.enhancementChase1), Absolute Value(Distance Between(Eye Position(Event Player),
				Event Player.enhancementChase1) - 1), Destination and Rate);
			Event Player.enhancementChase2 = 0;
			"P.U.P. ability cooldown"
			Chase Player Variable At Rate(Event Player, enhancementChase2, 0, Event Player.enhancementValues[2] ? 0 : 1, Destination and Rate);
			"P.U.P. visual"
			Create Effect(All Players(All Teams), Sphere, Event Player.enhancementValues[1], Event Player.enhancementChase1, 0.250,
				Visible To Position Radius and Color);
			"P.U.P. Beam"
			Create Beam Effect(Filtered Array(All Players(All Teams),
				Event Player.enhancementValues[2] && Event Player.enhancementValues[3] != Null), Good Beam, Event Player.enhancementChase1,
				Event Player.enhancementValues[3], Event Player.enhancementValues[1], Visible To Position Radius and Color);
			"P.U.P using beam sound"
			Create Effect(Filtered Array(All Players(All Teams), Event Player.enhancementValues[2]), Beacon Sound, Color(Sky Blue),
				Event Player.enhancementChase1, 200, Visible To Position and Radius);
			"Freeze aura"
			Create Effect(Filtered Array(All Players(All Teams), Event Player.enhancementValues[4]), Bad Aura, Color(Sky Blue),
				Event Player.enhancementValues[3], Event Player.enhancementValues[3].size, Visible To Position and Radius);
			"Default color"
			Event Player.enhancementValues[1] = Color(Sky Blue);
			"Beam visibility"
			Event Player.enhancementValues[2] = False;
			"P.U.P. target null"
			Event Player.enhancementValues[3] = Null;
			"Freeze aura visibility"
			Event Player.enhancementValues[4] = False;
	}
}

rule("SCAVENGER REPLENISHES AMMO")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 2;
	}

	actions
	{
		Modify Player Variable(Event Player, enhancementValues, Append To Array, Position Of(Victim));
		Start Rule(scavengerManagement, Do Nothing);
	}
}

rule("scavengerManagement")
{
	event
	{
		Subroutine;
		scavengerManagement;
	}

	actions
	{
		While(Event Player.enhancementValues[1] != Null);
			Event Player.enhancementChase1 = Event Player.enhancementValues[1];
			Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player) + Vector(0, -0.500, 0),
				Event Player.enhancementChase1 != 0 ? 20 : 0, Destination and Rate);
			Wait Until(Distance Between(Event Player.enhancementChase1, Eye Position(Event Player) + Vector(0, -0.500, 0)) < 0.100, 99999);
			Stop Chasing Player Variable(Event Player, enhancementChase1);
			Event Player.enhancementChase1 = 0;
			Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 50);
			"Prevent ammo collection during reload animation"
			If(Is Reloading(Event Player));
				Wait Until(!Is Reloading(Event Player), 3);
				Set Ammo(Event Player, 0, Ammo(Event Player, 0) + Round To Integer(Max Ammo(Event Player, 0) / 3, Up));
				Set Ammo(Event Player, 1, Ammo(Event Player, 1) + Round To Integer(Max Ammo(Event Player, 1) / 3, Up));
			Else;
				If(Ammo(Event Player, 0) < Max Ammo(Event Player, 0));
					Set Ammo(Event Player, 0, Min(Ammo(Event Player, 0) + Round To Integer(Max Ammo(Event Player, 0) / 3, Up), Max Ammo(Event Player,
						0)));
				End;
				If(Ammo(Event Player, 1) < Max Ammo(Event Player, 1));
					Set Ammo(Event Player, 1, Min(Ammo(Event Player, 1) + Round To Integer(Max Ammo(Event Player, 1) / 3, Up), Max Ammo(Event Player,
						1)));
				End;
			End;
			Modify Player Variable(Event Player, enhancementValues, Remove From Array By Index, 1);
		End;
	}
}

rule("LASER BARRICADE (PLACEMENT)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.enhancementValues[0] == 3;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Alive(Event Player) == True;
		Event Player.enhancementValues[3] <= 0;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Play Effect(Event Player, Good Explosion, Color(Blue), Eye Position(Event Player) + Direction From Angles(
			Horizontal Facing Angle Of(Event Player) + Random Real(-5, 5), Vertical Facing Angle Of(Event Player) + Random Real(-5, 5))
			* 1.500, 0.100);
		Play Effect(Event Player, Buff Explosion Sound, Color(Blue), Position Of(Event Player), 75);
		Wait Until(!Is Button Held(Event Player, Button(Melee)) || Is Dead(Event Player), 9999);
		Abort If(Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 31, Null, Null, False)) > 30);
		Abort If(Is Dead(Event Player));
		"Laser Barrier health"
		Event Player.enhancementChase1 = 10000;
		"Barrier center point"
		Event Player.enhancementValues[4] = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 30, Null, All Players(All Teams), False);
		"Barrier corner 1"
		Event Player.enhancementValues[5] = Event Player.enhancementValues[4] + World Vector Of(Vector(
			-0.500 * Event Player.enhancementValues[2], 0, 0), Event Player, Rotation);
		"Barrier Corner 2"
		Event Player.enhancementValues[6] = Event Player.enhancementValues[4] + World Vector Of(Vector(
			0.500 * Event Player.enhancementValues[2], 0, 0), Event Player, Rotation);
		"Reference point 1"
		Event Player.enhancementValues[7] = Event Player.enhancementValues[4] + Direction From Angles(Horizontal Facing Angle Of(
			Event Player), 0);
		"Reference point 2"
		Event Player.enhancementValues[8] = Event Player.enhancementValues[4] + Direction From Angles(Horizontal Facing Angle Of(
			Event Player), 0) * -1;
		"Reference direction"
		Event Player.enhancementValues[9] = Direction Towards(Event Player.enhancementValues[5], Event Player.enhancementValues[6]);
		Play Effect(Event Player, Ring Explosion, Color(Blue), Event Player.enhancementValues[4], 2);
		Play Effect(Event Player, Buff Explosion Sound, Color(Blue), Event Player.enhancementValues[4], 50);
		Small Message(Event Player, Custom String("Barricade placed!"));
		"Laser Barrier cooldown"
		Event Player.enhancementValues[3] = 30;
		While(Event Player.enhancementValues[3] > 0);
			Wait(1, Ignore Condition);
			Event Player.enhancementValues[3] += -1;
		End;
	}
}

rule("LASER BARRICADE BLOCKS ZOMBIES")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 3;
		"Barrier health is greater than 0"
		Event Player.enhancementChase1 > 0;
		"Horizontal distance check"
		Is True For Any(All Living Players(Team 2), Distance Between(Event Player.enhancementValues[4], Vector(X Component Of(Position Of(
			Current Array Element)), Y Component Of(Position Of(Event Player.enhancementValues[4])), Z Component Of(Position Of(
			Current Array Element)))) < 0.500 * Event Player.enhancementValues[2]) == True;
		"If feet are below highest point of wall"
		Is True For Any(All Living Players(Team 2), Y Component Of(Position Of(Current Array Element)) < Y Component Of(
			Event Player.enhancementValues[4]) + Event Player.enhancementValues[1]) == True;
		"If eyes are above lowest point of wall"
		Is True For Any(All Living Players(Team 2), Y Component Of(Eye Position(Current Array Element)) > Y Component Of(
			Event Player.enhancementValues[4])) == True;
		"Distance from wall"
		Is True For Any(All Living Players(Team 2), Distance Between(Vector(X Component Of(Position Of(Current Array Element)),
			Y Component Of(Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element))),
			Event Player.enhancementValues[5] + Event Player.enhancementValues[9] * Min(Event Player.enhancementValues[2], Absolute Value(
			Cosine From Degrees(Angle Between Vectors(Event Player.enhancementValues[9], Direction Towards(
			Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element)))))) * Distance Between(
			Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element))))))) < 1.500) == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, enhancementChase1);
		"Horizontal distance check"
		Event Player.potentialTargets = Filtered Array(All Living Players(Team 2), Distance Between(Event Player.enhancementValues[4],
			Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(Position Of(Event Player.enhancementValues[4])),
			Z Component Of(Position Of(Current Array Element)))) < 0.500 * Event Player.enhancementValues[2]);
		"Filter feet height"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, Y Component Of(Position Of(Current Array Element))
			< Y Component Of(Event Player.enhancementValues[4]) + Event Player.enhancementValues[1]);
		"Filter eye height"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, Y Component Of(Eye Position(Current Array Element))
			> Y Component Of(Event Player.enhancementValues[4]));
		"Filter distance from wall"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, Distance Between(Vector(X Component Of(Position Of(
			Current Array Element)), Y Component Of(Event Player.enhancementValues[5]), Z Component Of(Position Of(
			Current Array Element))), Event Player.enhancementValues[5] + Event Player.enhancementValues[9] * Min(
			Event Player.enhancementValues[2], Absolute Value(Cosine From Degrees(Angle Between Vectors(Event Player.enhancementValues[9],
			Direction Towards(Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element)))))) * Distance Between(
			Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element))))))) < 1.500);
		For Player Variable(Event Player, enhancementCount1, 0, Count Of(Event Player.potentialTargets), 1);
			Event Player.botTarget = Event Player.potentialTargets[Event Player.enhancementCount1];
			If(!Has Status(Event Player.botTarget, Rooted));
				"Damage the barricade"
				Event Player.enhancementChase1 -= Max Health(Event Player.botTarget) * 2.500;
				Set Status(Event Player.botTarget, Event Player, Rooted, 0.500);
				Damage(Event Player.botTarget, Event Player, 10);
			End;
			If(Throttle Of(Event Player.botTarget) == Vector(0, 0, 0));
				"If bot is not throttling"
				Apply Impulse(Event Player.botTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(
					Event Player.enhancementValues[4], First Of(Sorted Array(Filtered Array(Event Player.enhancementValues,
					Current Array Index >= 7 && Current Array Index <= 8), Distance Between(Position Of(Event Player.botTarget),
					Current Array Element))))), (Y Component Of(Position Of(Event Player.botTarget)) > Y Component Of(
					Event Player.enhancementValues[4]) ? -1 : 1) * (90 + Vertical Angle From Direction(Ray Cast Hit Normal(Position Of(
					Event Player.botTarget), Position Of(Event Player.botTarget) + Vector(0, -1, 0), Null, All Players(All Teams), False)))), 1,
					To World, Incorporate Contrary Motion);
			Else;
				"If bot is throttling"
				Apply Impulse(Event Player.botTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(
					Event Player.enhancementValues[4], Last Of(Sorted Array(Filtered Array(Event Player.enhancementValues,
					Current Array Index >= 7 && Current Array Index <= 8), Angle Between Vectors(World Vector Of(Throttle Of(
					Event Player.botTarget), Event Player.botTarget, Rotation), Direction Towards(Event Player.enhancementValues[4],
					Current Array Element)))))), (Y Component Of(Position Of(Event Player.botTarget)) > Y Component Of(
					Event Player.enhancementValues[4]) ? -1 : 1) * (90 + Vertical Angle From Direction(Ray Cast Hit Normal(Position Of(
					Event Player.botTarget), Position Of(Event Player.botTarget) + Vector(0, -1, 0), Null, All Players(All Teams), False)))), 10,
					To World, Cancel Contrary Motion);
			End;
		End;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Event Player.enhancementChase1 > 0);
			Wait(3, Restart When True);
		Else;
			Wait(6, Restart When True);
			"If shield is regenerating from 0HP"
			If(Event Player.enhancementChase1 <= 0);
				Event Player.enhancementChase1 = 1;
			End;
		End;
		Chase Player Variable At Rate(Event Player, enhancementChase1, 10000, 500, None);
		Loop If Condition Is True;
	}
}

rule("BRAIN KILLER EXTRA DAMAGE")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 4;
		Event Was Critical Hit == True;
	}

	actions
	{
		"Critical hits deal 50% more damage, 20% if vicitm is a boss"
		Damage(Victim, Event Player, Event Damage * (Array Contains(Global.bosses, Victim) ? 0.200 : 0.600));
		Play Effect(Event Player, Bad Explosion, Custom Color(100, 14, 14, 255), Eye Position(Victim) + Direction Towards(Eye Position(
			Event Player), Eye Position(Victim)) * Victim.size, 0.100 * Victim.size);
	}
}

rule("PYROTECHNIC SETS ENEMIES ON FIRE")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		First Of(Attacker.enhancementValues) == 5;
		Attacker.enhancementValues[1] == True;
		Victim != Event Player;
		Event Ability != Null;
		Distance Between(Position Of(Attacker), Position Of(Victim)) < 10;
	}

	actions
	{
		Set Status(Victim, Attacker, Burning, 3);
		Modify Player Variable(Attacker, enhancementChase2, Append To Array, Victim);
	}
}

rule("PYROTECHNIC APPLIES DAMAGE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 5;
		Count Of(Event Player.enhancementChase2) > 0;
	}

	actions
	{
		While(Count Of(Event Player.enhancementChase2) > 0);
			"Zombie to burn"
			Event Player.enhancementValues[3] = First Of(Event Player.enhancementChase2);
			If(Is Alive(Event Player.enhancementValues[3]));
				"Amount of times zombie was hit in last cycle"
				Event Player.enhancementValues[4] = Min(4 * Count Of(Filtered Array(Event Player.enhancementChase2,
					Current Array Element == Event Player.enhancementValues[3])), 30);
				If(Array Contains(Global.bosses, Event Player.enhancementValues[3]));
					Event Player.enhancementValues[4] /= 2;
				End;
				Start Damage Over Time(Event Player.enhancementValues[3], Event Player, 3, Event Player.enhancementValues[4]);
			End;
			Modify Player Variable(Event Player, enhancementChase2, Remove From Array By Value, Event Player.enhancementValues[3]);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("BORN TO BATTLE PLAYER EARNS ELIMINATION")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 7;
		Event Player.enhancementValues[1] != True;
	}

	actions
	{
		Event Player.enhancementValues[1] = True;
	}
}

rule("BORN TO BATTLE PLAYER USES ABILITY CHARGE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 7;
		Event Player.enhancementValues[1] == True;
		Is True For Any(Array(Button(Secondary Fire), Button(Ability 1), Button(Ability 2), Button(Crouch)), Is Button Held(Event Player,
			Current Array Element)) == True;
	}

	actions
	{
		If(Is Button Held(Event Player, Button(Secondary Fire)));
			Event Player.enhancementValues[2] = Button(Secondary Fire);
		Else If(Is Button Held(Event Player, Button(Ability 1)));
			Event Player.enhancementValues[2] = Button(Ability 1);
		Else If(Is Button Held(Event Player, Button(Ability 2)));
			Event Player.enhancementValues[2] = Button(Ability 2);
		Else If(Is Button Held(Event Player, Button(Crouch)));
			Event Player.enhancementValues[2] = Button(Crouch);
		End;
		"Temp rein fix ability 2"
		If((Hero Of(Event Player) == Hero(Reinhardt) || Hero Of(Event Player) == Hero(Zarya))
			&& Event Player.enhancementValues[2] == Button(Ability 2));
			Wait Until(Is Using Ability 2(Event Player), 0.016);
			If(!Is Using Ability 2(Event Player));
				Set Ability Charge(Event Player, Event Player.enhancementValues[2], 1);
				Event Player.enhancementValues[1] = False;
			End;
			Abort;
		End;
		"Temp zarya fix ability 1"
		If(Hero Of(Event Player) == Hero(Zarya) && Event Player.enhancementValues[2] == Button(Ability 1));
			Wait Until(Is Using Ability 1(Event Player), 0.016);
			If(!Is Using Ability 1(Event Player));
				Set Ability Charge(Event Player, Event Player.enhancementValues[2], 1);
				Event Player.enhancementValues[1] = False;
			End;
			Abort;
		End;
		Set Ability Charge(Event Player, Event Player.enhancementValues[2], Ability Charge(Event Player, Event Player.enhancementValues[2])
			+ 1);
		"If the ability charge increased"
		If(Ability Charge(Event Player, Event Player.enhancementValues[2]) > 0);
			Event Player.enhancementValues[1] = False;
		"Else if ability is on cooldown"
		Else If(Ability Cooldown(Event Player, Event Player.enhancementValues[2]) > 0.500);
			Set Ability Cooldown(Event Player, Event Player.enhancementValues[2], 0);
			Event Player.enhancementValues[1] = False;
		End;
	}
}

rule("PLAGUE DOCTOR REDUCES PLAYERS' INFECTION LEVELS")
{
	event
	{
		Player Dealt Healing;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 6;
		Healee.infectionLvl >= 1;
	}

	actions
	{
		Healee.infectionLvl -= Event Healing / 300;
		Event Player.enhancementValues[1] += Event Healing / 300;
		If(Healee.infectionLvl < 1);
			Healee.infectionLvl -= 0.500;
			Event Player.enhancementValues[1] += 0.500;
			Play Effect(Event Player, Good Pickup Effect, Color(Green), Healee, 1);
			Small Message(Event Player, Healee == Event Player ? Custom String("You cured yourself!") : Custom String("You cured {0} {1}!",
				Healee, Hero Icon String(Hero Of(Healee))));
	}
}

rule("NANO NURSE SELF HEALING")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 9;
		Is Alive(Event Player) == True;
	}

	actions
	{
		If(Event Player.enhancementValues[1] != 0);
			Stop Heal Over Time(Event Player.enhancementValues[1]);
			Global.enhancementOptions[1] = 0;
			Event Player.enhancementValues[2] = False;
			Stop Chasing Player Variable(Event Player, infectionLvl);
		End;
		Wait Until(!Event Player.infected, 99999);
		Wait(0.500, Restart When True);
		Abort If(Is Dead(Event Player));
		Event Player.enhancementValues[2] = True;
		If(Event Player.infectionLvl > 0);
			Chase Player Variable At Rate(Event Player, infectionLvl, 0, 0.100, None);
		End;
		While(Normalized Health(Event Player) < 1);
			Start Heal Over Time(Event Player, Event Player, 1, 20);
			Event Player.enhancementValues[1] = Last Heal Over Time ID;
			Wait(1, Restart When True);
		End;
	}
}

rule("HITCHHIKER ATTACH/DETATCH")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 10;
		(Is Button Held(Event Player, Button(Crouch)) || (Event Player.attached && (Is Dead(Event Player) || Is Dead(
			Event Player.enhancementValues[1]) || !Entity Exists(Event Player.enhancementValues[1]) || Has Status(Event Player,
			Knocked Down) || Has Status(Event Player, Stunned) || Distance Between(Position Of(Event Player), Position Of(
			Event Player.enhancementValues[1])) > 3 * Event Player.enhancementValues[1].size))) == True;
	}

	actions
	{
		If(!Event Player.attached && Is Alive(Event Player));
			If(Is True For Any(Remove From Array(Global.playerTargetList, Event Player), !Current Array Element.attached && Distance Between(
				Position Of(Event Player), Position Of(Current Array Element)) < 2 * Current Array Element.size));
				"Select parent"
				Event Player.enhancementValues[1] = First Of(Sorted Array(Filtered Array(Remove From Array(Global.playerTargetList, Event Player),
					!Current Array Element.attached && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
					< Current Array Element.size * 2), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(
					Event Player), Eye Position(Current Array Element)))));
				"World Vector"
				Event Player.enhancementValues[2] = Position Of(Event Player.enhancementValues[1]) + Direction From Angles(
					Horizontal Angle From Direction(Direction Towards(Position Of(Event Player.enhancementValues[1]), Position Of(Event Player))),
					0) * Event Player.enhancementValues[1].size + Vector(0, Event Player.enhancementValues[1].size, 0);
				"Local vector conversion"
				Event Player.enhancementValues[2] = Local Vector Of(Event Player.enhancementValues[2], Event Player.enhancementValues[1],
					Rotation And Translation);
				"Translate player behind parent"
				If(Z Component Of(Event Player.enhancementValues[2]) > 0);
					Event Player.enhancementValues[2] *= Vector(1, 1, -1);
				End;
				Event Player.attached = True;
				Attach Players(Event Player, Event Player.enhancementValues[1], Event Player.enhancementValues[2]);
				Small Message(Event Player, Custom String("You are attached"));
			End;
		Else;
			If(Entity Exists(Event Player.enhancementValues[1]) && Distance Between(Position Of(Event Player), Position Of(
				Event Player.enhancementValues[1])) < 3 * Event Player.enhancementValues[1].size);
				Teleport(Event Player, Position Of(Event Player.enhancementValues[1]));
			Else;
				Detach Players(Event Player);
			End;
			Small Message(Event Player, Custom String("You have detached"));
			Event Player.attached = False;
			Event Player.enhancementValues[1] = 0;
	}
}

rule("P.U.P. TARGET")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 11;
		"Cooldown is at 0s"
		Event Player.enhancementChase2 <= 0;
		"P.U.P. target"
		Event Player.enhancementValues[3] == Null;
		Is True For Any(All Living Players(Team 2), Current Array Element.botTarget == Event Player && Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) < 10) == True;
	}

	actions
	{
		"Set P.U.P. target"
		Event Player.enhancementValues[3] = First Of(Sorted Array(Filtered Array(All Living Players(Team 2),
			Current Array Element.botTarget == Event Player), Distance Between(Position Of(Event Player), Position Of(
			Current Array Element))));
		Wait Until(Is Dead(Event Player.enhancementValues[3]) || !Entity Exists(Event Player.enhancementValues[3])
			|| Event Player.enhancementValues[3].teleporting, 99999);
		Stop Chasing Player Variable(Event Player, enhancementChase1);
		Event Player.enhancementValues[3] = Null;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		Stop Chasing Player Variable(Event Player, enhancementChase1);
		"Default color"
		Event Player.enhancementValues[1] = Color(Sky Blue);
		"Beam visibility"
		Event Player.enhancementValues[2] = False;
		"P.U.P. target null"
		Event Player.enhancementValues[3] = Null;
		"Freeze aura visibility"
		Event Player.enhancementValues[4] = False;
		Wait(0.500, Restart When True);
		"P.U.P. Default movement"
		Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player) + Direction Towards(Eye Position(
			Event Player), Event Player.enhancementChase1), Absolute Value(Distance Between(Eye Position(Event Player),
			Event Player.enhancementChase1) - 1), Destination and Rate);
	}
}

rule("P.U.P. CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 11;
		Event Player.enhancementValues[3] != Null;
	}

	actions
	{
		"P.U.P. attack movement"
		Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player.enhancementValues[3]) + Direction Towards(
			Eye Position(Event Player.enhancementValues[3]), Event Player.enhancementChase1) * 2, Absolute Value(Distance Between(
			Eye Position(Event Player.enhancementValues[3]), Event Player.enhancementChase1) - 2) * 1.500, Destination and Rate);
		"Default color"
		Event Player.enhancementValues[1] = Color(Sky Blue);
		"Beam visibility"
		Event Player.enhancementValues[2] = False;
		"Freeze aura visibility"
		Event Player.enhancementValues[4] = False;
		Wait Until(Distance Between(Event Player.enhancementChase1, Eye Position(Event Player.enhancementValues[3]))
			< 5 || Event Player.enhancementValues[3] == Null, 99999);
		"If target still exists"
		If(Event Player.enhancementValues[3] != Null);
			If(Distance Between(Position Of(Event Player), Position Of(Event Player.enhancementValues[3])) > 6);
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(White);
				"Beam visibility"
				Event Player.enhancementValues[2] = True;
				"Freeze aura visibility"
				Event Player.enhancementValues[4] = True;
				Wait(0.250, Abort When False);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Event Player.enhancementValues[3], 0.100);
				"Time to freeze dependent on max health of target"
				Wait(Min(15, Max Health(Event Player.enhancementValues[3]) / 300), Abort When False);
				"Freeze cooldown"
				Event Player.enhancementChase2 = 2;
				Set Status(Event Player.enhancementValues[3], Event Player, Frozen, 1.500);
				While(!Has Status(Event Player.enhancementValues[3], Frozen));
					Set Status(Event Player.enhancementValues[3], Event Player, Frozen, 1.500);
					Wait(0.250, Abort When False);
				End;
				"Freeze zombies around target for shorter time"
				Set Status(Remove From Array(Filtered Array(All Players(Team 2), Distance Between(Position Of(Event Player.enhancementValues[3]),
					Position Of(Current Array Element)) < 3), Event Player.enhancementValues[3]), Event Player, Frozen, 0.750);
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(Sky Blue);
				"Beam visibility"
				Event Player.enhancementValues[2] = False;
				"Freeze aura visibility"
				Event Player.enhancementValues[4] = False;
			Else;
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(Red);
				"Beam visibility"
				Event Player.enhancementValues[2] = True;
				Start Damage Over Time(Event Player.enhancementValues[3], Event Player, 3, 30);
				"Beam from P.U.P."
				Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Event Player.enhancementChase1, 0.250);
				"Beam hits P.U.P.'s target"
				Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Event Player.enhancementValues[3], 1);
				Set Status(Event Player.enhancementValues[3], Event Player, Burning, 3);
				Apply Impulse(Event Player.enhancementValues[3], Direction From Angles(Horizontal Angle From Direction(Direction Towards(
					Event Player.enhancementChase1, Position Of(Event Player.enhancementValues[3]))), Min(-20, Vertical Angle From Direction(
					Direction Towards(Event Player.enhancementChase1, Position Of(Event Player.enhancementValues[3]))))), Min(25,
					4200 / Max Health(Event Player.enhancementValues[3])), To World, Cancel Contrary Motion);
				Set Status(Event Player.enhancementValues[3], Event Player, Knocked Down, 1);
				"Laser cooldown"
				Event Player.enhancementChase2 = 1;
				Wait(3, Abort When False);
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(Sky Blue);
				"Beam visibility"
				Event Player.enhancementValues[2] = False;
			End;
			Stop Chasing Player Variable(Event Player, enhancementChase1);
			"P.U.P. target"
			Event Player.enhancementValues[3] = Null;
			Wait(1, Abort When False);
		End;
		Loop If Condition Is True;
	}
}